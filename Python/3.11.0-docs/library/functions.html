
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>内置函数 &#8212; Python 3.11.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="内置常量" href="constants.html" />
    <link rel="prev" title="概述" href="intro.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/functions.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="intro.html"
                          title="上一章">概述</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="constants.html"
                          title="下一章">内置常量</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/functions.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="constants.html" title="内置常量"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="intro.html" title="概述"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 标准库</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">内置函数</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="built-in-functions">
<span id="built-in-funcs"></span><h1>内置函数<a class="headerlink" href="#built-in-functions" title="永久链接至标题">¶</a></h1>
<p>Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="4"><p>内置函数</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="line-block">
<div class="line"><strong>A</strong></div>
<div class="line"><a class="reference internal" href="#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a></div>
<div class="line"><a class="reference internal" href="#aiter" title="aiter"><code class="xref py py-func docutils literal notranslate"><span class="pre">aiter()</span></code></a></div>
<div class="line"><a class="reference internal" href="#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a></div>
<div class="line"><a class="reference internal" href="#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a></div>
<div class="line"><a class="reference internal" href="#anext" title="anext"><code class="xref py py-func docutils literal notranslate"><span class="pre">anext()</span></code></a></div>
<div class="line"><a class="reference internal" href="#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>B</strong></div>
<div class="line"><a class="reference internal" href="#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a></div>
<div class="line"><a class="reference internal" href="#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a></div>
<div class="line"><a class="reference internal" href="#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-bytearray"><code class="docutils literal notranslate"><span class="pre">bytearray()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-bytes"><code class="docutils literal notranslate"><span class="pre">bytes()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>C</strong></div>
<div class="line"><a class="reference internal" href="#callable" title="callable"><code class="xref py py-func docutils literal notranslate"><span class="pre">callable()</span></code></a></div>
<div class="line"><a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a></div>
<div class="line"><a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a></div>
<div class="line"><a class="reference internal" href="#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>D</strong></div>
<div class="line"><a class="reference internal" href="#delattr" title="delattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">delattr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-dict"><code class="docutils literal notranslate"><span class="pre">dict()</span></code></a></div>
<div class="line"><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a></div>
<div class="line"><a class="reference internal" href="#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><strong>E</strong></div>
<div class="line"><a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a></div>
<div class="line"><a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a></div>
<div class="line"><a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>F</strong></div>
<div class="line"><a class="reference internal" href="#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a></div>
<div class="line"><a class="reference internal" href="#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a></div>
<div class="line"><a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-frozenset"><code class="docutils literal notranslate"><span class="pre">frozenset()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>G</strong></div>
<div class="line"><a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>H</strong></div>
<div class="line"><a class="reference internal" href="#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a></div>
<div class="line"><a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a></div>
<div class="line"><a class="reference internal" href="#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>I</strong></div>
<div class="line"><a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a></div>
<div class="line"><a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a></div>
<div class="line"><a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a></div>
<div class="line"><a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a></div>
<div class="line"><a class="reference internal" href="#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a></div>
<div class="line"><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><strong>L</strong></div>
<div class="line"><a class="reference internal" href="#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-list"><code class="docutils literal notranslate"><span class="pre">list()</span></code></a></div>
<div class="line"><a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>M</strong></div>
<div class="line"><a class="reference internal" href="#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a></div>
<div class="line"><a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-memoryview"><code class="docutils literal notranslate"><span class="pre">memoryview()</span></code></a></div>
<div class="line"><a class="reference internal" href="#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>N</strong></div>
<div class="line"><a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>O</strong></div>
<div class="line"><a class="reference internal" href="#object" title="object"><code class="xref py py-func docutils literal notranslate"><span class="pre">object()</span></code></a></div>
<div class="line"><a class="reference internal" href="#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a></div>
<div class="line"><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a></div>
<div class="line"><a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>P</strong></div>
<div class="line"><a class="reference internal" href="#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a></div>
<div class="line"><a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a></div>
<div class="line"><a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><strong>R</strong></div>
<div class="line"><a class="reference internal" href="#func-range"><code class="docutils literal notranslate"><span class="pre">range()</span></code></a></div>
<div class="line"><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a></div>
<div class="line"><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>S</strong></div>
<div class="line"><a class="reference internal" href="#func-set"><code class="docutils literal notranslate"><span class="pre">set()</span></code></a></div>
<div class="line"><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a></div>
<div class="line"><a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a></div>
<div class="line"><a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-str"><code class="docutils literal notranslate"><span class="pre">str()</span></code></a></div>
<div class="line"><a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a></div>
<div class="line"><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>T</strong></div>
<div class="line"><a class="reference internal" href="#func-tuple"><code class="docutils literal notranslate"><span class="pre">tuple()</span></code></a></div>
<div class="line"><a class="reference internal" href="#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>V</strong></div>
<div class="line"><a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>Z</strong></div>
<div class="line"><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>_</strong></div>
<div class="line"><a class="reference internal" href="#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a></div>
</div>
</td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="abs">
<span class="sig-name descname"><span class="pre">abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#abs" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个数的绝对值。 参数可以是整数、浮点数或任何实现了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__abs__()</span></code> 的对象。 如果参数是一个复数，则返回它的模。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="aiter">
<span class="sig-name descname"><span class="pre">aiter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">async_iterable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#aiter" title="永久链接至目标">¶</a></dt>
<dd><p>返回  <a class="reference internal" href="../glossary.html#term-asynchronous-iterable"><span class="xref std std-term">asynchronous iterable</span></a> 的 <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 。相当于调用 <code class="docutils literal notranslate"><span class="pre">x.__aiter__()</span></code>。</p>
<p>注意：与 <a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 不同，<a class="reference internal" href="#aiter" title="aiter"><code class="xref py py-func docutils literal notranslate"><span class="pre">aiter()</span></code></a> 没有两个参数的版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="all">
<span class="sig-name descname"><span class="pre">all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#all" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>iterable</em> 的所有元素均为真值（或可迭代对象为空）则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。 等价于：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anext">
<em class="property"><span class="pre">awaitable</span> </em><span class="sig-name descname"><span class="pre">anext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">async_iterator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anext" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">awaitable</span> </em><span class="sig-name descname"><span class="pre">anext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">async_iterator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>当进入 await 状态时，从给定 <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 返回下一数据项，迭代完毕则返回 <em>default</em>。</p>
<p>这是内置函数 <a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 的异步版本，类似于：</p>
<p>调用 <em>async_iterator</em> 的 <a class="reference internal" href="../reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 方法，返回一个 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>。等待返回迭代器的下一个值。若有给出 <em>default</em>，则在迭代完毕后会返回给出的值，否则会触发 <a class="reference internal" href="exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="any">
<span class="sig-name descname"><span class="pre">any</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#any" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>iterable</em> 的任一元素为真值则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 如果可迭代对象为空，返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ascii">
<span class="sig-name descname"><span class="pre">ascii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ascii" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 类似，返回一个字符串，表示对象的可打印形式，但在  <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 返回的字符串中，非 ASCII 字符会用 <code class="docutils literal notranslate"><span class="pre">\x</span></code>、<code class="docutils literal notranslate"><span class="pre">\u</span></code> 和 <code class="docutils literal notranslate"><span class="pre">\U</span></code> 进行转义。生成的字符串类似于 Python 2 中 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 的返回结果。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bin">
<span class="sig-name descname"><span class="pre">bin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bin" title="永久链接至目标">¶</a></dt>
<dd><p>将整数转变为以“0b”前缀的二进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，它必须定义 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>  方法，以便返回整数值。下面是一些例子：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;0b11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&#39;-0b1010&#39;</span>
</pre></div>
</div>
<p>若要控制是否显示前缀“0b”，可以采用以下两种方案：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;#b&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">(&#39;0b1110&#39;, &#39;1110&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">14</span><span class="si">:</span><span class="s1">#b</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">14</span><span class="si">:</span><span class="s1">b</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0b1110&#39;, &#39;1110&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bool">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bool" title="永久链接至目标">¶</a></dt>
<dd><p>返回布尔值，<code class="docutils literal notranslate"><span class="pre">True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">False</span></code>。<em>x</em> 用标准的 <a class="reference internal" href="stdtypes.html#truth"><span class="std std-ref">真值测试过程</span></a> 进行转换。如果 <em>x</em> 为 False 或省略，则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>；否则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 <a class="reference internal" href="#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> 类是 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的子类（见 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a> ）。它不能再被继承。它唯一的实例就是 <code class="docutils literal notranslate"><span class="pre">False</span></code> 和 <code class="docutils literal notranslate"><span class="pre">True</span></code> （参阅 <a class="reference internal" href="stdtypes.html#bltin-boolean-values"><span class="std std-ref">布尔值</span></a> ）。</p>
<div class="versionchanged" id="index-0">
<p><span class="versionmodified changed">在 3.7 版更改: </span><em>x</em> 现在只能作为位置参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="breakpoint">
<span class="sig-name descname"><span class="pre">breakpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#breakpoint" title="永久链接至目标">¶</a></dt>
<dd><p>This function drops you into the debugger at the call site.  Specifically,
it calls <a class="reference internal" href="sys.html#sys.breakpointhook" title="sys.breakpointhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code></a>, passing <code class="docutils literal notranslate"><span class="pre">args</span></code> and <code class="docutils literal notranslate"><span class="pre">kws</span></code> straight
through.  By default, <code class="docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code> calls
<a class="reference internal" href="pdb.html#pdb.set_trace" title="pdb.set_trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdb.set_trace()</span></code></a> expecting no arguments.  In this case, it is
purely a convenience function so you don't have to explicitly import
<a class="reference internal" href="pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> or type as much code to enter the debugger.  However,
<a class="reference internal" href="sys.html#sys.breakpointhook" title="sys.breakpointhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code></a> can be set to some other function and
<a class="reference internal" href="#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a> will automatically call that, allowing you to drop into
the debugger of choice.
If <a class="reference internal" href="sys.html#sys.breakpointhook" title="sys.breakpointhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code></a> is not accessible, this function will
raise <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>.</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">builtins.breakpoint</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">breakpointhook</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
</dd></dl>

<span class="target" id="func-bytearray"></span><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytearray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytearray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytearray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 bytes 数组。 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 类是一个可变序列，包含范围为 0 &lt;= x &lt; 256 的整数。它有可变序列大部分常见的方法，见 <a class="reference internal" href="stdtypes.html#typesseq-mutable"><span class="std std-ref">可变序列类型</span></a> 的描述；同时有 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型的大部分方法，参见 <a class="reference internal" href="stdtypes.html#bytes-methods"><span class="std std-ref">bytes 和 bytearray 操作</span></a>。</p>
<p>可选形参 <em>source</em> 可以用不同的方式来初始化数组：</p>
<ul class="simple">
<li><p>如果是一个 <em>string</em>，您必须提供 <em>encoding</em> 参数（<em>errors</em> 参数仍是可选的）；<a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 会使用 <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 方法来将 string 转变成 bytes。</p></li>
<li><p>如果是一个 <em>integer</em>，会初始化大小为该数字的数组，并使用 null 字节填充。</p></li>
<li><p>如果是一个遵循 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">缓冲区接口</span></a> 的对象，该对象的只读缓冲区将被用来初始化字节数组。</p></li>
<li><p>如果是一个 <em>iterable</em> 可迭代对象，它的元素的范围必须是 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 的整数，它会被用作数组的初始内容。</p></li>
</ul>
<p>如果没有实参，则创建大小为 0 的数组。</p>
<p>另见 <a class="reference internal" href="stdtypes.html#binaryseq"><span class="std std-ref">二进制序列类型 --- bytes, bytearray, memoryview</span></a> 和 <a class="reference internal" href="stdtypes.html#typebytearray"><span class="std std-ref">bytearray 对象</span></a>。</p>
</dd></dl>

<span class="target" id="func-bytes"></span><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的“bytes”对象，这是一个不可变序列，包含范围为 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 的整数。<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 是 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 的不可变版本——带有同样不改变序列的方法，支持同样的索引、切片操作。</p>
<p>因此，构造函数的实参和 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 相同。</p>
<p>字节对象还可以用字面值创建，参见 <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">字符串与字节串字面值</span></a>。</p>
<p>另见 <a class="reference internal" href="stdtypes.html#binaryseq"><span class="std std-ref">二进制序列类型 --- bytes, bytearray, memoryview</span></a>，<a class="reference internal" href="stdtypes.html#typebytes"><span class="std std-ref">bytes 对象</span></a> 和 <a class="reference internal" href="stdtypes.html#bytes-methods"><span class="std std-ref">bytes 和 bytearray 操作</span></a>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="callable">
<span class="sig-name descname"><span class="pre">callable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#callable" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数 <em>object</em> 是可调用的就返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，否则返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。 如果返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，调用仍可能失败，但如果返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则调用 <em>object</em> 将肯定不会成功。 请注意类是可调用的（调用类将返回一个新的实例）；如果实例所属的类有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code> 则它就是可调用的。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能: </span>这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加入。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="chr">
<span class="sig-name descname"><span class="pre">chr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chr" title="永久链接至目标">¶</a></dt>
<dd><p>返回 Unicode 码位为整数 <em>i</em> 的字符的字符串格式。例如，<code class="docutils literal notranslate"><span class="pre">chr(97)</span></code> 返回字符串 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>，<code class="docutils literal notranslate"><span class="pre">chr(8364)</span></code> 返回字符串 <code class="docutils literal notranslate"><span class="pre">'€'</span></code>。这是 <a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> 的逆函数。</p>
<p>实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 <em>i</em> 超过这个范围，会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="classmethod">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-name descname"><span class="pre">classmethod</span></span><a class="headerlink" href="#classmethod" title="永久链接至目标">¶</a></dt>
<dd><p>把一个方法封装成类方法。</p>
<p>类方法隐含的第一个参数就是类，就像实例方法接收实例作为参数一样。要声明一个类方法，按惯例请使用以下方案：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> 这样的形式称为函数的 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> -- 详情参阅 <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">函数定义</span></a>。</p>
<p>类方法的调用可以在类上进行 (例如 <code class="docutils literal notranslate"><span class="pre">C.f()</span></code>) 也可以在实例上进行 (例如 <code class="docutils literal notranslate"><span class="pre">C().f()</span></code>)。 其所属类以外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。</p>
<p>类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅本节中的 <a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>。 有关类方法的更多信息，请参阅 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">标准类型层级结构</span></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版更改: </span>类方法现在可以包装其他 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">描述器</span></a> 例如 <a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span>类方法现在继承了方法的属性（<code class="docutils literal notranslate"><span class="pre">__module__</span></code>、<code class="docutils literal notranslate"><span class="pre">__name__</span></code>、<code class="docutils literal notranslate"><span class="pre">__qualname__</span></code>、<code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>），并拥有一个新的``__wrapped__`` 属性。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版更改: </span>Class methods can no longer wrap other <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptors</span></a> such as
<a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="compile">
<span class="sig-name descname"><span class="pre">compile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dont_inherit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#compile" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>source</em> 编译成代码或 AST 对象。代码对象可以被 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 或 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 执行。<em>source</em> 可以是常规的字符串、字节字符串，或者 AST 对象。参见 <a class="reference internal" href="ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块的文档了解如何使用 AST 对象。</p>
<p><em>filename</em> 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 <code class="docutils literal notranslate"><span class="pre">'&lt;string&gt;'</span></code>）。</p>
<p><em>mode</em> 实参指定了编译代码必须用的模式。如果 <em>source</em> 是语句序列，可以是 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code>；如果是单一表达式，可以是 <code class="docutils literal notranslate"><span class="pre">'eval'</span></code>；如果是单个交互式语句，可以是 <code class="docutils literal notranslate"><span class="pre">'single'</span></code>。（在最后一种情况下，如果表达式执行结果不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将会被打印出来。）</p>
<p>可选参数 <em>flags</em> 和 <em>dont_inherit</em> 控制应当激活哪个 <a class="reference internal" href="ast.html#ast-compiler-flags"><span class="std std-ref">编译器选项</span></a> 以及应当允许哪个 <a class="reference internal" href="../reference/simple_stmts.html#future"><span class="std std-ref">future 特性</span></a>。 如果两者都未提供 (或都为零) 则代码会应用与调用 <a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 的代码相同的旗标来编译。 如果给出了 <em>flags</em> 参数而未给出 <em>dont_inherit</em> (或者为零) 则会在无论如何都将被使用的旗标之外还会额外使用 <em>flags</em> 参数所指定的编译器选项和 future 语句。 如果 <em>dont_inherit</em> 为非零整数，则只使用 <em>flags</em> 参数 -- 外围代码中的旗标 (future 特性和编译器选项) 会被忽略。</p>
<p>编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选项。 指明特定 future 特性所需的比特位可以在 <a class="reference internal" href="__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">_Feature</span></code> 实例的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">compiler_flag</span></code> 属性中找到。 <a class="reference internal" href="ast.html#ast-compiler-flags"><span class="std std-ref">编译器旗标</span></a> 可以在 <a class="reference internal" href="ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块中查找带有 <code class="docutils literal notranslate"><span class="pre">PyCF_</span></code> 前缀的名称。</p>
<p><em>optimize</em> 实参指定编译器的优化级别；默认值 <code class="docutils literal notranslate"><span class="pre">-1</span></code>  选择与解释器的 <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 选项相同的优化级别。显式级别为 <code class="docutils literal notranslate"><span class="pre">0</span></code> （没有优化；<code class="docutils literal notranslate"><span class="pre">__debug__</span></code>  为真）、<code class="docutils literal notranslate"><span class="pre">1</span></code> （断言被删除， <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 为假）或 <code class="docutils literal notranslate"><span class="pre">2</span></code> （文档字符串也被删除）。</p>
<p>如果编译的源码不合法，此函数会触发 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 异常；如果源码包含 null 字节，则会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
<p>如果您想分析 Python 代码的 AST 表示，请参阅 <a class="reference internal" href="ast.html#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.parse()</span></code></a>。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">compile</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">source</span></code>, <code class="docutils literal notranslate"><span class="pre">filename</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">'single'</span></code>  或 <code class="docutils literal notranslate"><span class="pre">'eval'</span></code> 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal notranslate"><span class="pre">code</span></code></a> 模块更容易检测语句的完整性。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为 Python AST 编译器的栈深度限制而崩溃。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>Windows 和 Mac 的换行符均可使用。而且在 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code> 模式下的输入不必再以换行符结尾了。另增加了 <em>optimize</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>之前 <em>source</em> 中包含 null 字节的话会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能: </span><code class="docutils literal notranslate"><span class="pre">ast.PyCF_ALLOW_TOP_LEVEL_AWAIT</span></code> 现在可在旗标中传入以启用对最高层级 <code class="docutils literal notranslate"><span class="pre">await</span></code>, <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 和 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 的支持。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="complex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#complex" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回值为 <em>real</em> + <em>imag</em>*1j 的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了 <em>imag</em>，则默认值为零，构造函数会像 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 和 <a class="reference internal" href="#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 一样进行数值转换。如果两个实参都省略，则返回 <code class="docutils literal notranslate"><span class="pre">0j</span></code>。</p>
<p>对于一个普通 Python 对象 <code class="docutils literal notranslate"><span class="pre">x</span></code>，<code class="docutils literal notranslate"><span class="pre">complex(x)</span></code> 会委托给 <code class="docutils literal notranslate"><span class="pre">x.__complex__()</span></code>。  如果 <code class="docutils literal notranslate"><span class="pre">__complex__()</span></code> 未定义则将回退至 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code>。 如果 <code class="docutils literal notranslate"><span class="pre">__float__()</span></code> 未定义则将回退至 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当从字符串转换时，字符串在 <code class="docutils literal notranslate"><span class="pre">+</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-</span></code> 的周围必须不能有空格。例如 <code class="docutils literal notranslate"><span class="pre">complex('1+2j')</span></code> 是合法的，但 <code class="docutils literal notranslate"><span class="pre">complex('1</span> <span class="pre">+</span> <span class="pre">2j')</span></code> 会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
</div>
<p><a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a> 描述了复数类型。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>如果 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code> 未定义则回退至 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="delattr">
<span class="sig-name descname"><span class="pre">delattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#delattr" title="永久链接至目标">¶</a></dt>
<dd><p>This is a relative of <a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>.  The arguments are an object and a
string.  The string must be the name of one of the object's attributes.  The
function deletes the named attribute, provided the object allows it.  For
example, <code class="docutils literal notranslate"><span class="pre">delattr(x,</span> <span class="pre">'foobar')</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x.foobar</span></code>.
<em>name</em> need not be a Python identifier (see <a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>).</p>
</dd></dl>

<span class="target" id="func-dict"></span><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwarg</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwarg</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwarg</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建一个新的字典。<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 对象是一个字典类。参见 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 和 <a class="reference internal" href="stdtypes.html#typesmapping"><span class="std std-ref">映射类型 --- dict</span></a> 了解这个类。</p>
<p>其他容器类型，请参见内置的 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 和 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 类，以及 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dir">
<span class="sig-name descname"><span class="pre">dir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dir" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。</p>
<p>如果对象有一个名为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code> 的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义 <code class="xref py py-func docutils literal notranslate"><span class="pre">__getattr__()</span></code> 或 <code class="xref py py-func docutils literal notranslate"><span class="pre">__getattribute__()</span></code> 函数的对象能够自定义 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 来报告它们的属性。</p>
<p>如果对象未提供 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code> 方法，该函数会尽量从对象的  <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性和其类型对象中收集信息。得到的列表不一定是完整，如果对象带有自定义 <code class="xref py py-func docutils literal notranslate"><span class="pre">__getattr__()</span></code> 方法时，结果可能不准确。</p>
<p>默认的 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：</p>
<ul class="simple">
<li><p>如果对象是模块对象，则列表包含模块的属性名称。</p></li>
<li><p>如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。</p></li>
<li><p>否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。</p></li>
</ul>
<p>返回的列表按字母表排序。例如：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>   <span class="c1"># show the names in the module namespace  </span>
<span class="go">[&#39;__builtins__&#39;, &#39;__name__&#39;, &#39;struct&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>   <span class="c1"># show the names in the struct module </span>
<span class="go">[&#39;Struct&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;,</span>
<span class="go"> &#39;__initializing__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;,</span>
<span class="go"> &#39;_clearcache&#39;, &#39;calcsize&#39;, &#39;error&#39;, &#39;pack&#39;, &#39;pack_into&#39;,</span>
<span class="go"> &#39;unpack&#39;, &#39;unpack_from&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;area&#39;, &#39;location&#39;, &#39;perimeter&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>因为 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="divmod">
<span class="sig-name descname"><span class="pre">divmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#divmod" title="永久链接至目标">¶</a></dt>
<dd><p>以两个（非复数）数字为参数，在作整数除法时，返回商和余数。若操作数为混合类型，则适用二进制算术运算符的规则。对于整数而言，结果与 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">//</span> <span class="pre">b,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code> 相同。对于浮点数则结果为``(q, a % b)``，其中 <em>q</em> 通常为 <code class="docutils literal notranslate"><span class="pre">math.floor(a</span> <span class="pre">/</span> <span class="pre">b)</span></code>，但可能比它小 1。在任何情况下，<code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> 都非常接近 <em>a</em>，如果 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> 非零，则结果符号与 <em>b</em> 相同，并且 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">abs(a</span> <span class="pre">%</span> <span class="pre">b)</span> <span class="pre">&lt;</span> <span class="pre">abs(b)</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="enumerate">
<span class="sig-name descname"><span class="pre">enumerate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#enumerate" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个枚举对象。<em>iterable</em> 必须是一个序列，或 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>，或其他支持迭代的对象。 <a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> 返回的迭代器的 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法返回一个元组，里面包含一个计数值（从 <em>start</em> 开始，默认为 0）和通过迭代 <em>iterable</em> 获得的值。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seasons</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Spring&#39;</span><span class="p">,</span> <span class="s1">&#39;Summer&#39;</span><span class="p">,</span> <span class="s1">&#39;Fall&#39;</span><span class="p">,</span> <span class="s1">&#39;Winter&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">))</span>
<span class="go">[(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</span>
</pre></div>
</div>
<p>等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span><span class="p">,</span> <span class="n">elem</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="func-eval"></span><dl class="py function">
<dt class="sig sig-object py" id="eval">
<span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expression</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eval" title="永久链接至目标">¶</a></dt>
<dd><p>实参是一个字符串，以及可选的 globals 和 locals。<em>globals</em> 实参必须是一个字典。<em>locals</em> 可以是任何映射对象。</p>
<p>表达式解析参数 <em>expression</em> 并作为 Python 表达式进行求值（从技术上说是一个条件列表），采用 <em>globals</em> 和 <em>locals</em> 字典作为全局和局部命名空间。 如果存在 <em>globals</em> 字典，并且不包含 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 键的值，则在解析 <em>expression</em> 之前会插入以该字符串为键以对内置模块 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 的字典的引用为值的项。 这样就可以在将 <em>globals</em> 传给 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 之前通过向其传入你自己的 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 字典来控制可供被执行代码可以使用哪些内置模块。 如果 <em>locals</em> 字典被省略则它默认为 <em>globals</em> 字典。 如果两个字典都被省略，则将使用调用 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 的环境中的 <em>globals</em> 和 <em>locals</em> 来执行该表达式。 注意，<em>eval()</em> 无法访问闭包环境中的 <a class="reference internal" href="../glossary.html#term-nested-scope"><span class="xref std std-term">嵌套作用域</span></a> (非局部变量)。</p>
<p>返回值就是表达式的求值结果。 语法错误将作为异常被报告。 例如：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;x+1&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>该函数还可用于执行任意代码对象（比如由 <a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 创建的对象）。 这时传入的是代码对象，而非一个字符串了。如果代码对象已用参数为  <em>mode</em> 的 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code> 进行了编译，那么 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 的返回值将为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>提示： <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数支持语句的动态执行。 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 和 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数分别返回当前的全局和本地字典，可供传给 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 或 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 使用。</p>
<p>如果给出的源数据是个字符串，那么其前后的空格和制表符将被剔除。</p>
<p>另外可以参阅 <a class="reference internal" href="ast.html#ast.literal_eval" title="ast.literal_eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.literal_eval()</span></code></a>，该函数可以安全执行仅包含文字的表达式字符串。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">exec</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">code_object</span></code>。</p>
</dd></dl>

<span class="target" id="index-1"></span><dl class="py function">
<dt class="sig sig-object py" id="exec">
<span class="sig-name descname"><span class="pre">exec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#exec" title="永久链接至目标">¶</a></dt>
<dd><p>这个函数支持动态执行 Python 代码。 <em>object</em> 必须是字符串或者代码对象。 如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。 <a class="footnote-reference brackets" href="#id2" id="id1">1</a> 如果是代码对象，它将被直接执行。 在任何情况下，被执行的代码都应当是有效的文件输入（见参考手册中的 <a class="reference internal" href="../reference/toplevel_components.html#file-input"><span class="std std-ref">文件输入</span></a>  一节）。 请注意即使在传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数的代码的上下文中，<a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a>, <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 和 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句也不能在函数定义以外使用。 该函数的返回值是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>无论在什么情况下，如果省略了可选部分，代码将运行于当前作用域中。如果只提供了 <em>globals</em>，则必须为字典对象（而不能是字典的子类），同时用于存放全局变量和局部变量。如果提供了 <em>globals</em> 和 <em>locals</em>，则将分别用于全局变量和局部变量。<em>locals</em> 可以是任意字典映射对象。请记住，在模块级别，globals 和 locals 是同一个字典。如果 exec 获得两个独立的对象作为 <em>globals</em> 和 <em>locals</em>，代码执行起来就像嵌入到某个类定义中一样。</p>
<p>如果 <em>globals</em> 字典不包含 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 键值，则将为该键插入对内建 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 模块字典的引用。因此，在将执行的代码传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 之前，可以通过将自己的 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 字典插入到 <em>globals</em> 中来控制可以使用哪些内置代码。</p>
<p>The <em>closure</em> argument specifies a closure--a tuple of cellvars.
It's only valid when the <em>object</em> is a code object containing free variables.
The length of the tuple must exactly match the number of free variables
referenced by the code object.</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">exec</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">code_object</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>内置 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 和 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数各自返回当前的全局和本地字典，因此可以将它们传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 的第二个和第三个实参。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>默认情况下，<em>locals</em> 的行为如下面 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数描述的一样：不要试图改变默认的 <em>locals</em> 字典。 如果您需要在 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数返回时查看代码对 <em>locals</em> 的影响，请明确地传递 <em>locals</em> 字典。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版更改: </span>Added the <em>closure</em> parameter.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#filter" title="永久链接至目标">¶</a></dt>
<dd><p>用 <em>iterable</em>  中函数 <em>function</em> 返回真的那些元素，构建一个新的迭代器。<em>iterable</em> 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 <em>function</em> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则会假设它是一个身份函数，即 <em>iterable</em> 中所有返回假的元素会被移除。</p>
<p>请注意， <code class="docutils literal notranslate"><span class="pre">filter(function,</span> <span class="pre">iterable)</span></code> 相当于一个生成器表达式，当 function 不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的时候为 <code class="docutils literal notranslate"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">function(item))</span></code>；function 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的时候为 <code class="docutils literal notranslate"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">item)</span></code> 。</p>
<p>请参阅 <a class="reference internal" href="itertools.html#itertools.filterfalse" title="itertools.filterfalse"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.filterfalse()</span></code></a> 了解，只有 <em>function</em> 返回 false 时才选取 <em>iterable</em> 中元素的补充函数。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="float">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#float" title="永久链接至目标">¶</a></dt>
<dd><p id="index-2">返回从数字或字符串 <em>x</em> 生成的浮点数。</p>
<p>如果参数是个字符串，则应包含一个十进制数字，前面可选带上符号，也可选前后带有空白符。符号可以是``'+'`` 或 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>；<code class="docutils literal notranslate"><span class="pre">'+'</span></code> 符号对值没有影响。参数也可以是一个代表 NaN（非数字）或正负无穷大的字符串。更确切地说，在去除前导和尾部的空白符后，输入参数必须符合以下语法：</p>
<pre>
<strong id="grammar-token-float-sign"><span id="grammar-token-sign"></span>sign          </strong> ::=  &quot;+&quot; | &quot;-&quot;
<strong id="grammar-token-float-infinity"><span id="grammar-token-infinity"></span>infinity      </strong> ::=  &quot;Infinity&quot; | &quot;inf&quot;
<strong id="grammar-token-float-nan"><span id="grammar-token-nan"></span>nan           </strong> ::=  &quot;nan&quot;
<strong id="grammar-token-float-numeric_value"><span id="grammar-token-numeric-value"></span>numeric_value </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code> | <a class="reference internal" href="#grammar-token-float-infinity"><code class="xref docutils literal notranslate"><span class="pre">infinity</span></code></a> | <a class="reference internal" href="#grammar-token-float-nan"><code class="xref docutils literal notranslate"><span class="pre">nan</span></code></a>
<strong id="grammar-token-float-numeric_string"><span id="grammar-token-numeric-string"></span>numeric_string</strong> ::=  [<a class="reference internal" href="#grammar-token-float-sign"><code class="xref docutils literal notranslate"><span class="pre">sign</span></code></a>] <a class="reference internal" href="#grammar-token-float-numeric_value"><code class="xref docutils literal notranslate"><span class="pre">numeric_value</span></code></a>
</pre>
<p>这里的 <code class="docutils literal notranslate"><span class="pre">floatnumber</span></code> 是指 Python 的浮点数格式，在 <a class="reference internal" href="../reference/lexical_analysis.html#floating"><span class="std std-ref">浮点数字面值</span></a> 中有介绍。大小写没有关系，所以“inf”、“Inf”、“INFINITY”、“iNfINity”都可接受为正无穷的拼写形式。</p>
<p>另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p>
<p>对于一个普通 Python 对象 <code class="docutils literal notranslate"><span class="pre">x</span></code>，<code class="docutils literal notranslate"><span class="pre">float(x)</span></code> 会委托给 <code class="docutils literal notranslate"><span class="pre">x.__float__()</span></code>。 如果 <code class="docutils literal notranslate"><span class="pre">__float__()</span></code> 未定义则将回退至 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>。</p>
<p>如果没有实参，则返回 <code class="docutils literal notranslate"><span class="pre">0.0</span></code> 。</p>
<p>示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1.23&#39;</span><span class="p">)</span>
<span class="go">1.23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;   -12345</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">-12345.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;1e-003&#39;</span><span class="p">)</span>
<span class="go">0.001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1E6&#39;</span><span class="p">)</span>
<span class="go">1000000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
</div>
<p><a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a> 描述了浮点类型。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span><em>x</em> 现在只能作为位置参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>如果 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code> 未定义则回退至 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>。</p>
</div>
</dd></dl>

<span class="target" id="index-3"></span><dl class="py function">
<dt class="sig sig-object py" id="format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_spec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#format" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>value</em> 转换为“格式化后”的形式，格式由 <em>format_spec</em> 进行控制。<em>format_spec</em> 的解释方式取决于 <em>value</em> 参数的类型；但大多数内置类型使用一种标准的格式化语法： <a class="reference internal" href="string.html#formatspec"><span class="std std-ref">格式规格迷你语言</span></a>。</p>
<p>默认的 <em>format_spec</em> 是一个空字符串，它通常给出与调用 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(value)</span></code></a> 相同的结果。</p>
<p>调用 <code class="docutils literal notranslate"><span class="pre">format(value,</span> <span class="pre">format_spec)</span></code> 会转换成  <code class="docutils literal notranslate"><span class="pre">type(value).__format__(value,</span> <span class="pre">format_spec)</span></code> ，所以实例字典中的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code> 方法将不会调用。如果方法搜索回退到 <a class="reference internal" href="#object" title="object"><code class="xref py py-mod docutils literal notranslate"><span class="pre">object</span></code></a> 类但  <em>format_spec</em> 不为空，或者如果 <em>format_spec</em> 或返回值不是字符串，则会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当 <em>format_spec</em> 不是空字符串时， <code class="docutils literal notranslate"><span class="pre">object().__format__(format_spec)</span></code> 会触发  <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</div>
</dd></dl>

<span class="target" id="func-frozenset"></span><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">frozenset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">set()</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 对象，它包含可选参数 <em>iterable</em> 中的元素。 <code class="docutils literal notranslate"><span class="pre">frozenset</span></code> 是一个内置的类。有关此类的文档，请参阅 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 和 <a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">集合类型 --- set, frozenset</span></a>。</p>
<p>请参阅内建的 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>、<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 类，以及 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块来了解其它的容器。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="getattr">
<span class="sig-name descname"><span class="pre">getattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#getattr" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">getattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return the value of the named attribute of <em>object</em>.  <em>name</em> must be a string.
If the string is the name of one of the object's attributes, the result is the
value of that attribute.  For example, <code class="docutils literal notranslate"><span class="pre">getattr(x,</span> <span class="pre">'foobar')</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">x.foobar</span></code>.  If the named attribute does not exist, <em>default</em> is returned if
provided, otherwise <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> is raised.
<em>name</em> need not be a Python identifier (see <a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于 <a class="reference internal" href="../reference/expressions.html#private-name-mangling"><span class="std std-ref">私有名称混合</span></a> 发生在编译时，因此必须 手动混合私有属性（以两个下划线打头的属性）名称以使使用 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 来提取它。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="globals">
<span class="sig-name descname"><span class="pre">globals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#globals" title="永久链接至目标">¶</a></dt>
<dd><p>返回实现当前模块命名空间的字典。对于函数内的代码，这是在定义函数时设置的，无论函数在哪里被调用都保持不变。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hasattr">
<span class="sig-name descname"><span class="pre">hasattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hasattr" title="永久链接至目标">¶</a></dt>
<dd><p>该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。（此功能是通过调用 <code class="docutils literal notranslate"><span class="pre">getattr(object,</span> <span class="pre">name)</span></code> 看是否有 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 异常来实现的。）</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hash">
<span class="sig-name descname"><span class="pre">hash</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hash" title="永久链接至目标">¶</a></dt>
<dd><p>返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果对象实现了自己的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法，请注意，<a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 根据机器的字长来截断返回值。另请参阅 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="help">
<span class="sig-name descname"><span class="pre">help</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#help" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">help</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。</p>
<p>请注意，如果在调用 <a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> 时，目标函数的形参列表中存在斜杠（/），则意味着斜杠之前的参数只能是位置参数。详情请参阅 <a class="reference internal" href="../faq/programming.html#faq-positional-only-arguments"><span class="std std-ref">有关仅限位置形参的 FAQ 条目</span></a>。</p>
<p>该函数通过 <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 模块加入到内置命名空间。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span><a class="reference internal" href="pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 和 <a class="reference internal" href="inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 的变更使得可调用对象的签名信息更加全面和一致。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hex">
<span class="sig-name descname"><span class="pre">hex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hex" title="永久链接至目标">¶</a></dt>
<dd><p>将整数转换为以“0x”为前缀的小写十六进制字符串。如果 <em>x</em> 不是 Python <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，则必须定义返回整数的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code> 方法。一些例子：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="go">&#39;0xff&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="o">-</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&#39;-0x2a&#39;</span>
</pre></div>
</div>
<p>如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%#x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;#x&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">255</span><span class="si">:</span><span class="s1">#x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">255</span><span class="si">:</span><span class="s1">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">255</span><span class="si">:</span><span class="s1">X</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
<p>另请参阅 <a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 将十六进制字符串转换为以 16 为基数的整数。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果要获取浮点数的十六进制字符串形式，请使用 <a class="reference internal" href="stdtypes.html#float.hex" title="float.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.hex()</span></code></a> 方法。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id">
<span class="sig-name descname"><span class="pre">id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 <a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 值。</p>
<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> This is the address of the object in memory.</p>
</div>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">builtins.id</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">id</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="input">
<span class="sig-name descname"><span class="pre">input</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#input" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prompt</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果存在 <em>prompt</em> 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>。例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;--&gt; &#39;</span><span class="p">)</span>  
<span class="go">--&gt; Monty Python&#39;s Flying Circus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">&quot;Monty Python&#39;s Flying Circus&quot;</span>
</pre></div>
</div>
<p>如果加载了 <a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 模块，<a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a> 将使用它来提供复杂的行编辑和历史记录功能。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">builtins.input</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">prompt</span></code>。</p>
<p class="audit-hook"><p>在成功读取输入之后引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">builtins.input/result</span></code> 附带结果。</p>
</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="int">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#int" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个基于数字或字符串 <em>x</em> 构造的整数对象，或者在未给出参数时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 如果 <em>x</em> 定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code>，<code class="docutils literal notranslate"><span class="pre">int(x)</span></code> 将返回 <code class="docutils literal notranslate"><span class="pre">x.__int__()</span></code>。 如果 <em>x</em> 定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>，它将返回 <code class="docutils literal notranslate"><span class="pre">x.__index__()</span></code>。 如果 <em>x</em> 定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code>，它将返回 <code class="docutils literal notranslate"><span class="pre">x.__trunc__()</span></code>。 对于浮点数，它将向零舍入。</p>
<p>如果 <em>x</em> 不是数字，或者有 <em>base</em> 参数，<em>x</em> 必须是字符串、<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>、表示进制为 <em>base</em> 的 <a class="reference internal" href="../reference/lexical_analysis.html#integers"><span class="std std-ref">整数字面值</span></a> 的 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 实例。该文字前可以有 <code class="docutils literal notranslate"><span class="pre">+</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-</span></code> （中间不能有空格），前后可以有空格。一个进制为 n 的数字包含 0 到 n-1 的数，其中 <code class="docutils literal notranslate"><span class="pre">a</span></code> 到 <code class="docutils literal notranslate"><span class="pre">z</span></code> （或 <code class="docutils literal notranslate"><span class="pre">A</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Z</span></code> ）表示 10 到 35。默认的 <em>base</em> 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可以在代码中用 <code class="docutils literal notranslate"><span class="pre">0b</span></code>/<code class="docutils literal notranslate"><span class="pre">0B</span></code> 、 <code class="docutils literal notranslate"><span class="pre">0o</span></code>/<code class="docutils literal notranslate"><span class="pre">0O</span></code> 、 <code class="docutils literal notranslate"><span class="pre">0x</span></code>/<code class="docutils literal notranslate"><span class="pre">0X</span></code> 前缀来表示。进制为 0 将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中的一个。所以 <code class="docutils literal notranslate"><span class="pre">int('010',</span> <span class="pre">0)</span></code> 是非法的，但 <code class="docutils literal notranslate"><span class="pre">int('010')</span></code> 和 <code class="docutils literal notranslate"><span class="pre">int('010',</span> <span class="pre">8)</span></code> 是合法的。</p>
<p>整数类型定义请参阅 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>如果 <em>base</em> 不是 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的实例，但 <em>base</em> 对象有 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__index__</span></code></a> 方法，则会调用该方法来获取进制数。以前的版本使用 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__int__</span></code></a> 而不是 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__index__</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span><em>x</em> 现在只能作为位置参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>如果 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code> 未定义则回退至 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版更改: </span>The delegation to <code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code> is deprecated.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版更改: </span><a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> string inputs and string representations can be limited to
help avoid denial of service attacks. A <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised when
the limit is exceeded while converting a string <em>x</em> to an <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or
when converting an <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> into a string would exceed the limit.
See the <a class="reference internal" href="stdtypes.html#int-max-str-digits"><span class="std std-ref">integer string conversion length limitation</span></a> documentation.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="isinstance">
<span class="sig-name descname"><span class="pre">isinstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classinfo</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#isinstance" title="永久链接至目标">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the <em>object</em> argument is an instance of the <em>classinfo</em>
argument, or of a (direct, indirect, or <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">virtual</span></a>) subclass thereof.  If <em>object</em> is not
an object of the given type, the function always returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.
If <em>classinfo</em> is a tuple of type objects (or recursively, other such
tuples) or a <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">union 类型</span></a> of multiple types, return <code class="docutils literal notranslate"><span class="pre">True</span></code> if
<em>object</em> is an instance of any of the types.
If <em>classinfo</em> is not a type or tuple of types and such tuples,
a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is raised. <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> may not be
raised for an invalid type if an earlier check succeeds.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span><em>classinfo</em> 可以是一个 <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">union 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="issubclass">
<span class="sig-name descname"><span class="pre">issubclass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classinfo</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#issubclass" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>class</em> 是 <em>classinfo</em> 的子类（直接、间接或 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">虚的</span></a> ），则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。类将视为自己的子类。<em>classinfo</em> 可为类对象的元组（或递归地，其他这样的元组）或 <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">union 类型</span></a>，这时如果 <em>class</em> 是 <em>classinfo</em> 中任何条目的子类，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。任何其他情况都会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span><em>classinfo</em> 可以是一个 <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">union 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="iter">
<span class="sig-name descname"><span class="pre">iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#iter" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sentinel</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，<em>object</em> 必须是支持 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> 协议（有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> 方法）的集合对象，或必须支持序列协议（有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> 方法，且数字参数从 <code class="docutils literal notranslate"><span class="pre">0</span></code> 开始）。如果它不支持这些协议，会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。如果有第二个实参 <em>sentinel</em>，那么 <em>object</em> 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法时都会不带实参地调用 <em>object</em>；如果返回的结果是 <em>sentinel</em> 则触发 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>，否则返回调用结果。</p>
<p>另请参阅 <a class="reference internal" href="stdtypes.html#typeiter"><span class="std std-ref">迭代器类型</span></a>。</p>
<p>适合 <a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mydata.db&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">process_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="len">
<span class="sig-name descname"><span class="pre">len</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#len" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。</p>
<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> <code class="docutils literal notranslate"><span class="pre">len</span></code> 对于大于 <a class="reference internal" href="sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> 的长度如 <a class="reference internal" href="stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range(2</span> <span class="pre">**</span> <span class="pre">100)</span></code></a> 会引发 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p>
</div>
</dd></dl>

<span class="target" id="func-list"></span><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">list</span></span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>虽然被称为函数，<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 实际上是一种可变序列类型，详情请参阅 <a class="reference internal" href="stdtypes.html#typesseq-list"><span class="std std-ref">列表</span></a> 和 <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">序列类型 --- list, tuple, range</span></a>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="locals">
<span class="sig-name descname"><span class="pre">locals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#locals" title="永久链接至目标">¶</a></dt>
<dd><p>更新并返回表示当前本地符号表的字典。 在函数代码块但不是类代码块中调用 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 时将返回自由变量。 请注意在模块层级上，<a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 和 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 是同一个字典。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>不要更改此字典的内容；更改不会影响解释器使用的局部变量或自由变量的值。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">iterables</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#map" title="永久链接至目标">¶</a></dt>
<dd><p>Return an iterator that applies <em>function</em> to every item of <em>iterable</em>,
yielding the results.  If additional <em>iterables</em> arguments are passed,
<em>function</em> must take that many arguments and is applied to the items from all
iterables in parallel.  With multiple iterables, the iterator stops when the
shortest iterable is exhausted.  For cases where the function inputs are
already arranged into argument tuples, see <a class="reference internal" href="itertools.html#itertools.starmap" title="itertools.starmap"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.starmap()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#max" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。</p>
<p>如果只提供了一个位置参数，它必须是非空 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>，返回可迭代对象中最大的元素；如果提供了两个及以上的位置参数，则返回最大的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code class="docutils literal notranslate"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc,</span> <span class="pre">reverse=True)[0]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">heapq.nlargest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> 保持一致。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能: </span>keyword-only 实参 <em>default</em> 。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span><em>key</em> 可以为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</div>
</dd></dl>

<span class="target" id="func-memoryview"></span><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">memoryview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 <a class="reference internal" href="stdtypes.html#typememoryview"><span class="std std-ref">内存视图</span></a>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#min" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。</p>
<p>如果只提供了一个位置参数，它必须是 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code class="docutils literal notranslate"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc)[0]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">heapq.nsmallest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> 保持一致。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能: </span>keyword-only 实参 <em>default</em> 。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span><em>key</em> 可以为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="next">
<span class="sig-name descname"><span class="pre">next</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#next" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">next</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>通过调用 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> 的 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法获取下一个元素。如果迭代器耗尽，则返回给定的 <em>default</em>，如果没有默认值则触发 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="object">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">object</span></span><a class="headerlink" href="#object" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个不带特征的新对象。<a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 是所有类的基类。它带有所有 Python 类实例均通用的方法。本函数不接受任何参数。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 没有 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>，因此无法将任意属性赋给 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的实例。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oct">
<span class="sig-name descname"><span class="pre">oct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#oct" title="永久链接至目标">¶</a></dt>
<dd><p>将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，那它需要定义 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>  方法返回一个整数。一些例子：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;0o10&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="o">-</span><span class="mi">56</span><span class="p">)</span>
<span class="go">&#39;-0o70&#39;</span>
</pre></div>
</div>
<p>若要将整数转换为八进制字符串，并可选择是否带有“0o”前缀，可采用如下方法：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%#o</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%o</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">10</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;#o&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">10</span><span class="si">:</span><span class="s1">#o</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">10</span><span class="si">:</span><span class="s1">o</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
<blockquote>
<div><span class="target" id="index-4"></span></div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="open">
<span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closefd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opener</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#open" title="永久链接至目标">¶</a></dt>
<dd><p>打开 <em>file</em> 并返回对应的 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>。 如果该文件不能被打开，则引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。 请参阅 <a class="reference internal" href="../tutorial/inputoutput.html#tut-files"><span class="std std-ref">读写文件</span></a> 获取此函数的更多用法示例。</p>
<p><em>file</em> 是一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>，表示将要打开的文件的路径（绝对路径或者相对当前工作目录的路径），也可以是要封装文件对应的整数类型文件描述符。（如果给出的是文件描述符，则当返回的 I/O 对象关闭时它也会关闭，除非将 <em>closefd</em> 设为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。）</p>
<p><em>mode</em> is an optional string that specifies the mode in which the file is
opened.  It defaults to <code class="docutils literal notranslate"><span class="pre">'r'</span></code> which means open for reading in text mode.
Other common values are <code class="docutils literal notranslate"><span class="pre">'w'</span></code> for writing (truncating the file if it
already exists), <code class="docutils literal notranslate"><span class="pre">'x'</span></code> for exclusive creation, and <code class="docutils literal notranslate"><span class="pre">'a'</span></code> for appending
(which on <em>some</em> Unix systems, means that <em>all</em> writes append to the end of
the file regardless of the current seek position).  In text mode, if
<em>encoding</em> is not specified the encoding used is platform-dependent:
<a class="reference internal" href="locale.html#locale.getencoding" title="locale.getencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getencoding()</span></code></a> is called to get the current locale encoding.
(For reading and writing raw bytes use binary mode and leave
<em>encoding</em> unspecified.)  The available modes are:</p>
<span class="target" id="filemodes"></span><table class="docutils align-default" id="index-5">
<colgroup>
<col style="width: 13%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>字符</p></th>
<th class="head"><p>含意</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'r'</span></code></p></td>
<td><p>读取（默认）</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'w'</span></code></p></td>
<td><p>写入，并先截断文件</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'x'</span></code></p></td>
<td><p>排它性创建，如果文件已存在则失败</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'a'</span></code></p></td>
<td><p>打开文件用于写入，如果文件存在则在末尾追加</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code></p></td>
<td><p>二进制模式</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'t'</span></code></p></td>
<td><p>文本模式（默认）</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'+'</span></code></p></td>
<td><p>打开用于更新（读取与写入）</p></td>
</tr>
</tbody>
</table>
<p>默认模式为 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> （打开文件用于读取文本，与 <code class="docutils literal notranslate"><span class="pre">'rt'</span></code> 同义）。<code class="docutils literal notranslate"><span class="pre">'w+'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'w+b'</span></code> 模式将打开文件并清空内容。而 <code class="docutils literal notranslate"><span class="pre">'r+'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'r+b'</span></code> 模式将打开文件但不清空内容。</p>
<p>正如在 <a class="reference internal" href="io.html#io-overview"><span class="std std-ref">概述</span></a> 中提到的，Python区分二进制和文本I/O。以二进制模式打开的文件（包括 <em>mode</em> 参数中的 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> ）返回的内容为 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象，不进行任何解码。在文本模式下（默认情况下，或者在 <em>mode</em> 参数中包含 <code class="docutils literal notranslate"><span class="pre">'t'</span></code> ）时，文件内容返回为 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ，首先使用指定的 <em>encoding</em> （如果给定）或者使用平台默认的的字节编码解码。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此与平台无关。</p>
</div>
<p><em>buffering</em> 是一个可选的整数，用于设置缓冲策略。 传入 0 来关闭缓冲（只允许在二进制模式下），传入 1 来选择行缓冲（只在文本模式下可用），传入一个整数 &gt; 1 来表示固定大小的块缓冲区的字节大小。注意，这样指定缓冲区的大小适用于二进制缓冲的 I/O ，但 <code class="docutils literal notranslate"><span class="pre">TextIOWrapper</span></code> （即用 <code class="docutils literal notranslate"><span class="pre">mode='r+'</span></code> 打开的文件）会有另一种缓冲。要禁用在 <code class="docutils literal notranslate"><span class="pre">TextIOWrapper</span></code> 缓冲，考虑使用 <a class="reference internal" href="io.html#io.TextIOWrapper.reconfigure" title="io.TextIOWrapper.reconfigure"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.TextIOWrapper.reconfigure()</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">write_through</span></code> 标志来。当没有给出 <em>buffering</em> 参数时，默认的缓冲策略工作如下。</p>
<ul class="simple">
<li><p>二进制文件以固定大小的块进行缓冲；使用启发式方法选择缓冲区的大小，尝试确定底层设备的“块大小”或使用 <a class="reference internal" href="io.html#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">io.DEFAULT_BUFFER_SIZE</span></code></a>。在许多系统上，缓冲区的长度通常为4096或8192字节。</p></li>
<li><p>“交互式”文本文件（ <a class="reference internal" href="io.html#io.IOBase.isatty" title="io.IOBase.isatty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isatty()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的文件）使用行缓冲。其他文本文件使用上述策略用于二进制文件。</p></li>
</ul>
<p><em>encoding</em> is the name of the encoding used to decode or encode the file.
This should only be used in text mode.  The default encoding is platform
dependent (whatever <a class="reference internal" href="locale.html#locale.getencoding" title="locale.getencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getencoding()</span></code></a> returns), but any
<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a> supported by Python can be used.
See the <a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> module for the list of supported encodings.</p>
<p><em>errors</em> 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。可以使用各种标准错误处理程序（列在 <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">错误处理方案</span></a> ），但是使用 <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a> 注册的任何错误处理名称也是有效的。标准名称包括:</p>
<ul class="simple">
<li><p>如果存在编码错误，<code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。 默认值 <code class="docutils literal notranslate"><span class="pre">None</span></code> 具有相同的效果。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> 忽略错误。请注意，忽略编码错误可能会导致数据丢失。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> 会将替换标记（例如 <code class="docutils literal notranslate"><span class="pre">'?'</span></code> ）插入有错误数据的地方。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code> 将把任何不正确的字节表示为 U+DC80 至 U+DCFF 范围内的下方替代码位。 当在写入数据时使用 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> 错误处理句柄时这些替代码位会被转回到相同的字节。 这适用于处理具有未知编码格式的文件。</p></li>
<li><p>只有在写入文件时才支持 <code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code>。编码不支持的字符将替换为相应的XML字符引用 <code class="docutils literal notranslate"><span class="pre">&amp;#nnn;</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> 用Python的反向转义序列替换格式错误的数据。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> （也只在编写时支持）用 <code class="docutils literal notranslate"><span class="pre">\N{...}</span></code> 转义序列替换不支持的字符。</p></li>
</ul>
<p id="open-newline-parameter"><span id="index-6"></span><em>newline</em> determines how to parse newline characters from the stream.
It can be <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">''</span></code>, <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>, and
<code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>.  It works as follows:</p>
<ul class="simple">
<li><p>从流中读取输入时，如果 <em>newline</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则启用通用换行模式。输入中的行可以以 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>，<code class="docutils literal notranslate"><span class="pre">'\r'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code> 结尾，这些行被翻译成 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 在返回呼叫者之前。如果它是 <code class="docutils literal notranslate"><span class="pre">''</span></code>，则启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入行仅由给定字符串终止，并且行结尾将返回给未调用的调用者。</p></li>
<li><p>将输出写入流时，如果 <em>newline</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则写入的任何 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 字符都将转换为系统默认行分隔符 <a class="reference internal" href="os.html#os.linesep" title="os.linesep"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.linesep</span></code></a>。如果 <em>newline</em> 是 <code class="docutils literal notranslate"><span class="pre">''</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>，则不进行翻译。如果 <em>newline</em> 是任何其他合法值，则写入的任何 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 字符将被转换为给定的字符串。</p></li>
</ul>
<p>如果 <em>closefd</em> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 且给出的不是文件名而是文件描述符，那么当文件关闭时，底层文件描述符将保持打开状态。如果给出的是文件名，则 <em>closefd</em> 必须为 <code class="docutils literal notranslate"><span class="pre">True</span></code> （默认值），否则将触发错误。</p>
<p>可以通过传递可调用的 <em>opener</em> 来使用自定义开启器。然后通过使用参数（ <em>file</em>，<em>flags</em> ）调用 <em>opener</em> 获得文件对象的基础文件描述符。 <em>opener</em> 必须返回一个打开的文件描述符（使用 <a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.open</span></code></a> as <em>opener</em> 时与传递 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的效果相同）。</p>
<p>新创建的文件是 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">不可继承的</span></a>。</p>
<p>下面的示例使用 <a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> 函数的 <a class="reference internal" href="os.html#dir-fd"><span class="std std-ref">dir_fd</span></a> 的形参，从给定的目录中用相对路径打开文件:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dir_fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDONLY</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">opener</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">dir_fd</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;spamspam.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">opener</span><span class="o">=</span><span class="n">opener</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;This will be written to somedir/spamspam.txt&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">dir_fd</span><span class="p">)</span>  <span class="c1"># don&#39;t leak a file descriptor</span>
</pre></div>
</div>
<p><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 函数所返回的 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> 类型取决于所用模式。 当使用 <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 以文本模式 (<code class="docutils literal notranslate"><span class="pre">'w'</span></code>, <code class="docutils literal notranslate"><span class="pre">'r'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wt'</span></code>, <code class="docutils literal notranslate"><span class="pre">'rt'</span></code> 等) 打开文件时，它将返回 <a class="reference internal" href="io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> (具体为 <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>) 的一个子类。 当使用缓冲以二进制模式打开文件时，返回的类是 <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> 的一个子类。 具体的类会有多种：在只读的二进制模式下，它将返回 <a class="reference internal" href="io.html#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedReader</span></code></a>；在写入二进制和追加二进制模式下，它将返回 <a class="reference internal" href="io.html#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedWriter</span></code></a>，而在读/写模式下，它将返回 <a class="reference internal" href="io.html#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedRandom</span></code></a>。 当禁用缓冲时，则会返回原始流，即 <a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.RawIOBase</span></code></a> 的一个子类 <a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>。</p>
<p id="index-7">另请参阅文件操作模块，如 <a class="reference internal" href="fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fileinput</span></code></a>、<a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> （声明了 <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>）、<a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a>、<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.path</span></code></a>、<a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tempfile</span></code></a> 和 <a class="reference internal" href="shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a>。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">open</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">file</span></code>, <code class="docutils literal notranslate"><span class="pre">mode</span></code>, <code class="docutils literal notranslate"><span class="pre">flags</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">mode</span></code> 与 <code class="docutils literal notranslate"><span class="pre">flags</span></code> 参数可以在原始调用的基础上被修改或传递。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span></p>
<ul class="simple">
<li><p>增加了 <em>opener</em> 形参。</p></li>
<li><p>增加了 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 模式。</p></li>
<li><p>过去触发的 <a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>，现在是 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的别名。</p></li>
<li><p>如果文件已存在但使用了排它性创建模式（ <code class="docutils literal notranslate"><span class="pre">'x'</span></code> ），现在会触发 <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a>。</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span></p>
<ul class="simple">
<li><p>文件现在禁止继承。</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span></p>
<ul class="simple">
<li><p>如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 异常 (原因详见 <span class="target" id="index-21"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a>)。</p></li>
<li><p>增加了 <code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> 错误处理接口。</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span></p>
<ul class="simple">
<li><p>增加对实现了 <a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 对象的支持。</p></li>
<li><p>在 Windows 上，打开一个控制台缓冲区将返回 <a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.RawIOBase</span></code></a> 的子类，而不是 <a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>。</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版更改: </span>The <code class="docutils literal notranslate"><span class="pre">'U'</span></code> mode has been removed.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ord">
<span class="sig-name descname"><span class="pre">ord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ord" title="永久链接至目标">¶</a></dt>
<dd><p>对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 <code class="docutils literal notranslate"><span class="pre">ord('a')</span></code> 返回整数 <code class="docutils literal notranslate"><span class="pre">97</span></code>， <code class="docutils literal notranslate"><span class="pre">ord('€')</span></code> （欧元符号）返回 <code class="docutils literal notranslate"><span class="pre">8364</span></code> 。这是 <a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> 的逆函数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pow">
<span class="sig-name descname"><span class="pre">pow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pow" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>base</em> 的 <em>exp</em> 次幂；如果 <em>mod</em> 存在，则返回 <em>base</em> 的 <em>exp</em> 次幂对 <em>mod</em> 取余（比 <code class="docutils literal notranslate"><span class="pre">pow(base,</span> <span class="pre">exp)</span> <span class="pre">%</span> <span class="pre">mod</span></code> 更高效）。 两参数形式 <code class="docutils literal notranslate"><span class="pre">pow(base,</span> <span class="pre">exp)</span></code> 等价于乘方运算符: <code class="docutils literal notranslate"><span class="pre">base**exp</span></code>。</p>
<p>参数必须为数值类型。 对于混用的操作数类型，则适用二元算术运算符的类型强制转换规则。 对于 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 操作数，结果具有与操作数相同的类型（转换后），除非第二个参数为负值；在这种情况下，所有参数将被转换为浮点数并输出浮点数结果。 例如，<code class="docutils literal notranslate"><span class="pre">pow(10,</span> <span class="pre">2)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">100</span></code>，但 <code class="docutils literal notranslate"><span class="pre">pow(10,</span> <span class="pre">-2)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">0.01</span></code>。 对于 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 或 <a class="reference internal" href="#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 类型的负基和一个非整数的指数，会产生一个复杂的结果。 例如， <code class="docutils literal notranslate"><span class="pre">pow(-9,</span> <span class="pre">0.5)</span></code> 返回一个接近于 <code class="docutils literal notranslate"><span class="pre">3j</span></code> 的值。</p>
<p>对于 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 操作数 <em>base</em> 和 <em>exp</em>，如果给出 <em>mod</em>，则 <em>mod</em> 必须为整数类型并且 <em>mod</em> 必须不为零。 如果给出 <em>mod</em> 并且 <em>exp</em> 为负值，则 <em>base</em> 必须相对于 <em>mod</em> 不可整除。 在这种情况下，将会返回 <code class="docutils literal notranslate"><span class="pre">pow(inv_base,</span> <span class="pre">-exp,</span> <span class="pre">mod)</span></code>，其中 <em>inv_base</em> 为 <em>base</em> 的倒数对 <em>mod</em> 取余。</p>
<p>下面的例子是 <code class="docutils literal notranslate"><span class="pre">38</span></code> 的倒数对 <code class="docutils literal notranslate"><span class="pre">97</span></code> 取余:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">pow</span><span class="p">(</span><span class="mi">38</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="mi">97</span><span class="p">)</span>
<span class="go">23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">23</span> <span class="o">*</span> <span class="mi">38</span> <span class="o">%</span> <span class="mi">97</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>对于 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 操作数，三参数形式的 <code class="docutils literal notranslate"><span class="pre">pow</span></code> 现在允许第二个参数为负值，即可以计算倒数的余数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>允许关键字参数。 之前只支持位置参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="print">
<span class="sig-name descname"><span class="pre">print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">objects</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\n'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flush</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#print" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>objects</em> 打印输出至 <em>file</em> 指定的文本流，以 <em>sep</em> 分隔并在末尾加上 <em>end</em>。 <em>sep</em> 、 <em>end</em> 、 <em>file</em> 和 <em>flush</em> 必须以关键字参数的形式给出。</p>
<p>所有非关键字参数都会被转换为字符串，就像是执行了 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 一样，并会被写入到流，以 <em>sep</em> 且在末尾加上 <em>end</em>。 <em>sep</em> 和 <em>end</em> 都必须为字符串；它们也可以为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，这意味着使用默认值。 如果没有给出 <em>objects</em>，则 <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 将只写入 <em>end</em>。</p>
<p><em>file</em> 参数必须是一个具有 <code class="docutils literal notranslate"><span class="pre">write(string)</span></code> 方法的对象；如果参数不存在或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则将使用 <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>。 由于要打印的参数会被转换为文本字符串，因此 <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 不能用于二进制模式的文件对象。 对于这些对象，应改用 <code class="docutils literal notranslate"><span class="pre">file.write(...)</span></code>。</p>
<p>输出是否缓存通常取决于 <em>file</em>，但如果 <em>flush</em> 关键字参数为 True，输出流会被强制刷新。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>flush</em> 关键字参数。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="property">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">property</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fget</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#property" title="永久链接至目标">¶</a></dt>
<dd><p>返回 property 属性。</p>
<p><em>fget</em> 是获取属性值的函数。 <em>fset</em> 是用于设置属性值的函数。 <em>fdel</em> 是用于删除属性值的函数。并且 <em>doc</em> 为属性对象创建文档字符串。</p>
<p>一个典型的用法是定义一个托管属性 <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s2">&quot;I&#39;m the &#39;x&#39; property.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果 <em>c</em> 为 <em>C</em> 的实例，<code class="docutils literal notranslate"><span class="pre">c.x</span></code> 将调用 getter，<code class="docutils literal notranslate"><span class="pre">c.x</span> <span class="pre">=</span> <span class="pre">value</span></code> 将调用 setter， <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">c.x</span></code> 将调用 deleter。</p>
<p>如果给出，<em>doc</em> 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 <em>fget</em> 的文档字符串（如果存在）。 这令使用 <a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 作为 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> 来创建只读的特征属性可以很容易地实现:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parrot</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span> <span class="o">=</span> <span class="mi">100000</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span>
</pre></div>
</div>
<p>以上 <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> 装饰器会将 <code class="xref py py-meth docutils literal notranslate"><span class="pre">voltage()</span></code> 方法转化为一个具有相同名称的只读属性的 &quot;getter&quot;，并将 <em>voltage</em> 的文档字符串设置为 &quot;Get the current voltage.&quot;</p>
<p>特征属性对象具有 <code class="xref py py-attr docutils literal notranslate"><span class="pre">getter</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">setter</span></code> 以及 <code class="xref py py-attr docutils literal notranslate"><span class="pre">deleter</span></code> 方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。  这最好是用一个例子来解释:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;I&#39;m the &#39;x&#39; property.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
</pre></div>
</div>
<p>上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称 (在本例中为 <code class="docutils literal notranslate"><span class="pre">x</span></code>。)</p>
<p>返回的特征属性对象同样具有与构造器参数相对应的属性 <code class="docutils literal notranslate"><span class="pre">fget</span></code>, <code class="docutils literal notranslate"><span class="pre">fset</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fdel</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>特征属性对象的文档字符串现在是可写的。</p>
</div>
</dd></dl>

<span class="target" id="func-range"></span><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>虽然被称为函数，但 <a class="reference internal" href="stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> 实际上是一个不可变的序列类型，参见在 <a class="reference internal" href="stdtypes.html#typesseq-range"><span class="std std-ref">range 对象</span></a> 与 <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">序列类型 --- list, tuple, range</span></a> 中的文档说明。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="repr">
<span class="sig-name descname"><span class="pre">repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#repr" title="永久链接至目标">¶</a></dt>
<dd><p>Return a string containing a printable representation of an object.  For many
types, this function makes an attempt to return a string that would yield an
object with the same value when passed to <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>; otherwise, the
representation is a string enclosed in angle brackets that contains the name
of the type of the object together with additional information often
including the name and address of the object.  A class can control what this
function returns for its instances by defining a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code> method.
If <a class="reference internal" href="sys.html#sys.displayhook" title="sys.displayhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.displayhook()</span></code></a> is not accessible, this function will raise
<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="reversed">
<span class="sig-name descname"><span class="pre">reversed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#reversed" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个反向的 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>。 <em>seq</em> 必须是一个具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code> 方法的对象或者是支持该序列协议（具有从 <code class="docutils literal notranslate"><span class="pre">0</span></code> 开始的整数类型参数的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> 方法和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> 方法）。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="round">
<span class="sig-name descname"><span class="pre">round</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndigits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#round" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>number</em> 舍入到小数点后 <em>ndigits</em> 位精度的值。 如果 <em>ndigits</em> 被省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则返回最接近输入值的整数。</p>
<p>对于支持 <a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 方法的内置类型，结果值会舍入至最接近的 10 的负 <em>ndigits</em> 次幂的倍数；如果与两个倍数同样接近，则选用偶数。因此，<code class="docutils literal notranslate"><span class="pre">round(0.5)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">round(-0.5)</span></code> 均得出 <code class="docutils literal notranslate"><span class="pre">0</span></code> 而 <code class="docutils literal notranslate"><span class="pre">round(1.5)</span></code> 则为 <code class="docutils literal notranslate"><span class="pre">2</span></code>。<em>ndigits</em> 可为任意整数值（正数、零或负数）。如果省略了 <em>ndigits</em> 或为 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则返回值将为整数。否则返回值与 <em>number</em> 的类型相同。</p>
<p>对于一般的 Python 对象 <code class="docutils literal notranslate"><span class="pre">number</span></code>, <code class="docutils literal notranslate"><span class="pre">round</span></code> 将委托给 <code class="docutils literal notranslate"><span class="pre">number.__round__</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对浮点数执行 <a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 的行为可能会令人惊讶：例如，<code class="docutils literal notranslate"><span class="pre">round(2.675,</span> <span class="pre">2)</span></code> 将给出 <code class="docutils literal notranslate"><span class="pre">2.67</span></code> 而不是期望的 <code class="docutils literal notranslate"><span class="pre">2.68</span></code>。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。 请参阅 <a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><span class="std std-ref">浮点算术：争议和限制</span></a> 了解更多信息。</p>
</div>
</dd></dl>

<span class="target" id="func-set"></span><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">set</span></span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 对象，可以选择带有从 <em>iterable</em> 获取的元素。 <code class="docutils literal notranslate"><span class="pre">set</span></code> 是一个内置类型。 请查看 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 和 <a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">集合类型 --- set, frozenset</span></a> 获取关于这个类的文档。</p>
<p>有关其他容器请参看内置的 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 类，以及 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="setattr">
<span class="sig-name descname"><span class="pre">setattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#setattr" title="永久链接至目标">¶</a></dt>
<dd><p>本函数与 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 相对应。其参数为一个对象、一个字符串和一个任意值。字符串可以为某现有属性的名称，或为新属性。只要对象允许，函数会将值赋给属性。如 <code class="docutils literal notranslate"><span class="pre">setattr(x,</span> <span class="pre">'foobar',</span> <span class="pre">123)</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">x.foobar</span> <span class="pre">=</span> <span class="pre">123</span></code>。</p>
<p><em>name</em> need not be a Python identifier as defined in <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">标识符和关键字</span></a>
unless the object chooses to enforce that, for example in a custom
<a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> or via <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>.
An attribute whose name is not an identifier will not be accessible using
the dot notation, but is accessible through <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> etc..</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于 <a class="reference internal" href="../reference/expressions.html#private-name-mangling"><span class="std std-ref">私有名称混合</span></a> 发生在编译时，因此必须手动混合私有属性（以两个下划线打头的属性）名称以便使用 <a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a> 来设置它。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="slice">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slice" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个 <a class="reference internal" href="../glossary.html#term-slice"><span class="xref std std-term">slice</span></a> 对象，代表由 <code class="docutils literal notranslate"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> 指定索引集的切片。 其中参数 <em>start</em> 和 <em>step</em> 的默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。切片对象具有只读数据属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code> 、<code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code>，只是返回对应的参数值（或默认值）。这几个属性没有其他明确的功能；不过 NumPy 和其他第三方扩展会用到。在使用扩展索引语法时，也会生成切片对象。例如： <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">a[start:stop,</span> <span class="pre">i]</span></code>。 另一种方案是返回迭代器对象，可参阅 <a class="reference internal" href="itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> 。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sorted">
<span class="sig-name descname"><span class="pre">sorted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sorted" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>iterable</em> 中的项返回一个新的已排序列表。</p>
<p>具有两个可选参数，它们都必须指定为关键字参数。</p>
<p><em>key</em> 指定带有单个参数的函数，用于从 <em>iterable</em> 的每个元素中提取用于比较的键 (例如 <code class="docutils literal notranslate"><span class="pre">key=str.lower</span></code>)。 默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> (直接比较元素)。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则每个列表元素将按反向顺序比较进行排序。</p>
<p>使用 <a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cmp_to_key()</span></code></a> 可将老式的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p>
<p>内置的 <a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 --- 这有利于进行多重排序（例如先按部门、再按薪级排序）。</p>
<p>排序算法只使用 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> 在项目之间比较。 虽然定义一个 <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> 方法就足以进行排序，但 <span class="target" id="index-22"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a> 建议实现所有六个 <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">富比较</span></a> 。 这将有助于避免在与其他排序工具（如 <a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> ）使用相同的数据时出现错误，这些工具依赖于不同的底层方法。实现所有六个比较也有助于避免混合类型比较的混乱，因为混合类型比较可以调用反射到 <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> 的方法。</p>
<p>有关排序示例和简要排序教程，请参阅 <a class="reference internal" href="../howto/sorting.html#sortinghowto"><span class="std std-ref">排序指南</span></a> 。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="staticmethod">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-name descname"><span class="pre">staticmethod</span></span><a class="headerlink" href="#staticmethod" title="永久链接至目标">¶</a></dt>
<dd><p>将方法转换为静态方法。</p>
<p>静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code> 这样的形式称为函数的 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> -- 详情参阅 <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">函数定义</span></a>。</p>
<p>静态方法既可以由类中调用（如 <code class="docutils literal notranslate"><span class="pre">C.f()</span></code>），也可以由实例中调用（如```C().f()``）。此外，还可以作为普通的函数进行调用（如``f()``）。</p>
<p>Python 的静态方法与 Java 或 C++ 类似。另请参阅 <a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> ，可用于创建另一种类构造函数。</p>
<p>像所有装饰器一样，也可以像常规函数一样调用 <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> ，并对其结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，请使用此语法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">regular_function</span><span class="p">():</span>
    <span class="o">...</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">regular_function</span><span class="p">)</span>
</pre></div>
</div>
<p>想了解更多有关静态方法的信息，请参阅 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">标准类型层级结构</span></a> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span>静态方法继承了方法的多个属性（<code class="docutils literal notranslate"><span class="pre">__module__</span></code>、<code class="docutils literal notranslate"><span class="pre">__name__</span></code>、<code class="docutils literal notranslate"><span class="pre">__qualname__</span></code>、<code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>），还拥有一个新的``__wrapped__`` 属性，并且现在还可以作为普通函数进行调用。</p>
</div>
</dd></dl>

<span class="target" id="func-str"><span id="index-10"></span></span><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 版本的 <em>object</em> 。有关详细信息，请参阅 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">str</span></code> 是内置字符串 <a class="reference internal" href="../glossary.html#term-class"><span class="xref std std-term">class</span></a> 。更多关于字符串的信息查看 <a class="reference internal" href="stdtypes.html#textseq"><span class="std std-ref">文本序列类型 --- str</span></a>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sum">
<span class="sig-name descname"><span class="pre">sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sum" title="永久链接至目标">¶</a></dt>
<dd><p>从 <em>start</em> 开始自左向右对 <em>iterable</em> 的项求和并返回总计值。 <em>iterable</em> 的项通常为数字，而 start 值则不允许为字符串。</p>
<p>对某些用例来说，存在 <a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> 的更好替代。 拼接字符串序列的更好更快方式是调用 <code class="docutils literal notranslate"><span class="pre">''.join(sequence)</span></code>。 要以扩展精度对浮点值求和，请参阅 <a class="reference internal" href="math.html#math.fsum" title="math.fsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fsum()</span></code></a>。 要拼接一系列可迭代对象，请考虑使用 <a class="reference internal" href="itertools.html#itertools.chain" title="itertools.chain"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.chain()</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span><em>start</em> 形参可用关键字参数形式来指定。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="super">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">super</span></span><a class="headerlink" href="#super" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">super</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_or_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个代理对象，它会将方法调用委托给 <em>type</em> 的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。</p>
<p>The <em>object_or_type</em> determines the <a class="reference internal" href="../glossary.html#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a>
to be searched.  The search starts from the class right after the
<em>type</em>.</p>
<p>For example, if <a class="reference internal" href="stdtypes.html#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code></a> of <em>object_or_type</em> is
<code class="docutils literal notranslate"><span class="pre">D</span> <span class="pre">-&gt;</span> <span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">C</span> <span class="pre">-&gt;</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">object</span></code> and the value of <em>type</em> is <code class="docutils literal notranslate"><span class="pre">B</span></code>,
then <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> searches <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">-&gt;</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">object</span></code>.</p>
<p>The <a class="reference internal" href="stdtypes.html#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code></a> attribute of the <em>object_or_type</em> lists the method
resolution search order used by both <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> and <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>.  The
attribute is dynamic and can change whenever the inheritance hierarchy is
updated.</p>
<p>如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">type)</span></code> 必须为真值。 如果第二个参数为一个类型，则 <code class="docutils literal notranslate"><span class="pre">issubclass(type2,</span> <span class="pre">type)</span></code> 必须为真值（这适用于类方法）。</p>
<p><em>super</em> 有两个典型用例。 在具有单继承的类层级结构中，<em>super</em> 可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。 这种用法与其他编程语言中 <em>super</em> 的用法非常相似。</p>
<p>第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独有而不存在于静态编码语言或仅支持单继承的语言当中。 这使用实现“菱形图”成为可能，即有多个基类实现相同的方法。 好的设计强制要求这样的方法在每个情况下都具有相同的调用签名（因为调用顺序是在运行时确定的，也因为这个顺序要适应类层级结构的更改，还因为这个顺序可能包括在运行时之前未知的兄弟类）。</p>
<p>对于以上两个用例，典型的超类调用看起来是这样的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>    <span class="c1"># This does the same thing as:</span>
                               <span class="c1"># super(C, self).method(arg)</span>
</pre></div>
</div>
<p>除了方法查找之外，<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 也可用于属性查找。 一个可能的应用场合是在上级或同级类中调用 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">描述器</span></a>。</p>
<p>请注意 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 是作为显式加点属性查找的绑定过程的一部分来实现的，例如 <code class="docutils literal notranslate"><span class="pre">super().__getitem__(name)</span></code>。 它做到这一点是通过实现自己的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> 方法，这样就能以可预测的顺序搜索类，并且支持协作多重继承。 对应地，<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 在像 <code class="docutils literal notranslate"><span class="pre">super()[name]</span></code> 这样使用语句或操作符进行隐式查找时则未被定义。</p>
<p>还要注意的是，除了零个参数的形式以外，<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 并不限于在方法内部使用。 两个参数的形式明确指定参数并进行相应的引用。 零个参数的形式仅适用于类定义内部，因为编译器需要填入必要的细节以正确地检索到被定义的类，还需要让普通方法访问当前实例。</p>
<p>对于有关如何使用 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 来如何设计协作类的实用建议，请参阅 <a class="reference external" href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">使用 super() 的指南</a>。</p>
</dd></dl>

<span class="target" id="func-tuple"></span><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tuple</span></span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>虽然被称为函数，但 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 实际上是一个不可变的序列类型，参见在 <a class="reference internal" href="stdtypes.html#typesseq-tuple"><span class="std std-ref">元组</span></a> 与 <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">序列类型 --- list, tuple, range</span></a> 中的文档说明。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="type">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#type" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span></dt>
<dd><p id="index-11">传入一个参数时，返回 <em>object</em> 的类型。 返回值是一个 type 对象，通常与 <a class="reference internal" href="stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__class__</span></code></a> 所返回的对象相同。</p>
<p>推荐使用 <a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 内置函数来检测对象的类型，因为它会考虑子类的情况。</p>
<p>传入三个参数时，返回一个新的 type 对象。 这在本质上是 <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 语句的一种动态形式，<em>name</em> 字符串即类名并会成为 <a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 属性；<em>bases</em> 元组包含基类并会成为 <a class="reference internal" href="stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a> 属性；如果为空则会添加所有类的终极基类 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>。 <em>dict</em> 字典包含类主体的属性和方法定义；它在成为 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性之前可能会被拷贝或包装。 下面两条语句会创建相同的 <a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 对象:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>另请参阅 <a class="reference internal" href="stdtypes.html#bltin-type-objects"><span class="std std-ref">类型对象</span></a>。</p>
<p>提供给三参数形式的关键字参数会被传递给适当的元类机制 (通常为 <a class="reference internal" href="../reference/datamodel.html#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a>)，相当于类定义中关键字 (除了 <em>metaclass</em>) 的行为方式。</p>
<p>另请参阅 <a class="reference internal" href="../reference/datamodel.html#class-customization"><span class="std std-ref">自定义类创建</span></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span><a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 的子类如果未重载 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>，将不再能使用一个参数的形式来获取对象的类型。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="vars">
<span class="sig-name descname"><span class="pre">vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vars" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回模块、类、实例或任何其它具有 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性的对象的 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性。</p>
<p>模块和实例这样的对象具有可更新的 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性；但是，其它对象的 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性可能会设为限制写入（例如，类会使用 <a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.MappingProxyType</span></code></a> 来防止直接更新字典）。</p>
<p>不带参数时，<a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a> 的行为类似 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a>。 请注意，locals 字典仅对于读取起作用，因为对 locals 字典的更新会被忽略。</p>
<p>如果指定了一个对象但它没有 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性（例如，当它所属的类定义了 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 属性时）则会引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zip">
<span class="sig-name descname"><span class="pre">zip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">iterables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zip" title="永久链接至目标">¶</a></dt>
<dd><p>在多个迭代器上并行迭代，从每个迭代器返回一个数据项组成元组。</p>
<p>示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;sugar&#39;</span><span class="p">,</span> <span class="s1">&#39;spice&#39;</span><span class="p">,</span> <span class="s1">&#39;everything nice&#39;</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(1, &#39;sugar&#39;)</span>
<span class="go">(2, &#39;spice&#39;)</span>
<span class="go">(3, &#39;everything nice&#39;)</span>
</pre></div>
</div>
<p>更正式的说法： <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 返回元组的迭代器，其中第 <em>i</em> 个元组包含的是每个参数迭代器的第 <em>i</em> 个元素。</p>
<p>不妨换一种方式认识 <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> ：它会把行变成列，把列变成行。这类似于 <a class="reference external" href="https://en.wikipedia.org/wiki/Transpose">矩阵转置</a> 。</p>
<p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 是延迟执行的：直至迭代时才会对元素进行处理，比如 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 循环或放入 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 中。</p>
<p>值得考虑的是，传给 <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 的可迭代对象可能长度不同；有时是有意为之，有时是因为准备这些对象的代码存在错误。Python 提供了三种不同的处理方案：</p>
<ul>
<li><p>默认情况下，<a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 在最短的迭代完成后停止。较长可迭代对象中的剩余项将被忽略，结果会裁切至最短可迭代对象的长度：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;fee&#39;</span><span class="p">,</span> <span class="s1">&#39;fi&#39;</span><span class="p">,</span> <span class="s1">&#39;fo&#39;</span><span class="p">,</span> <span class="s1">&#39;fum&#39;</span><span class="p">]))</span>
<span class="go">[(0, &#39;fee&#39;), (1, &#39;fi&#39;), (2, &#39;fo&#39;)]</span>
</pre></div>
</div>
</li>
<li><p>通常 <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 用于可迭代对象等长的情况下。这时建议用 <code class="docutils literal notranslate"><span class="pre">strict=True</span></code> 的选项。输出与普通的 <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 相同：。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>
</pre></div>
</div>
<p>与默认行为不同的是，它会检查可迭代对象的长度是否相同，如果不相同则触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;fee&#39;</span><span class="p">,</span> <span class="s1">&#39;fi&#39;</span><span class="p">,</span> <span class="s1">&#39;fo&#39;</span><span class="p">,</span> <span class="s1">&#39;fum&#39;</span><span class="p">],</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">zip() argument 2 is longer than argument 1</span>
</pre></div>
</div>
<p>如果未指定 <code class="docutils literal notranslate"><span class="pre">strict=True</span></code> 参数，所有导致可迭代对象长度不同的错误都会被抑制，这可能会在程序的其他地方表现为难以发现的错误。</p>
</li>
<li><p>为了让所有的可迭代对象具有相同的长度，长度较短的可用常量进行填充。这可由 <a class="reference internal" href="itertools.html#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.zip_longest()</span></code></a> 来完成。</p></li>
</ul>
<p>极端例子是只有一个可迭代对象参数，<a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 会返回一个一元组的迭代器。如果未给出参数，则返回一个空的迭代器。</p>
<p>小技巧：</p>
<ul>
<li><p>可确保迭代器的求值顺序是从左到右的。这样就能用 <code class="docutils literal notranslate"><span class="pre">zip(*[iter(s)]*n,</span> <span class="pre">strict=True)</span></code> 将数据列表按长度 n 进行分组。这将重复 <em>相同</em> 的迭代器 <code class="docutils literal notranslate"><span class="pre">n</span></code> 次，输出的每个元组都包含 <code class="docutils literal notranslate"><span class="pre">n</span></code> 次调用迭代器的结果。这样做的效果是把输入拆分为长度为 n 的块。</p></li>
<li><p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 与 <code class="docutils literal notranslate"><span class="pre">*</span></code> 运算符相结合可以用来拆解一个列表:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span>增加了 <code class="docutils literal notranslate"><span class="pre">strict</span></code> 参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="import__">
<span id="__import__"></span><span class="sig-name descname"><span class="pre">__import__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fromlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#import__" title="永久链接至目标">¶</a></dt>
<dd><div class="admonition note" id="index-12">
<p class="admonition-title">备注</p>
<p>与 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 不同，这是一个日常 Python 编程中不需要用到的高级函数。</p>
</div>
<p>此函数会由 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句发起调用。 它可以被替换 (通过导入 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 模块并赋值给 <code class="docutils literal notranslate"><span class="pre">builtins.__import__</span></code>) 以便修改 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 语句的语义，但是 <strong>强烈</strong> 不建议这样做，因为使用导入钩子 (参见 <span class="target" id="index-23"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都会假定所用的是默认实现。 同样也不建议直接使用 <a class="reference internal" href="#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 而应该用 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>。</p>
<p>本函数会导入模块 <em>name</em>，利用 <em>globals</em> 和 <em>locals</em> 来决定如何在包的上下文中解释该名称。<em>fromlist</em> 给出了应从 <em>name</em> 模块中导入的对象或子模块的名称。标准的实现代码完全不会用到 <em>locals</em> 参数，只用到了 <em>globals</em> 用于确定 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句所在的包上下文。</p>
<p><em>level</em> 指定是使用绝对还是相对导入。 <code class="docutils literal notranslate"><span class="pre">0</span></code> (默认值) 意味着仅执行绝对导入。 <em>level</em> 为正数值表示相对于模块调用 <a class="reference internal" href="#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 的目录，将要搜索的父目录层数 (详情参见 <span class="target" id="index-24"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a>)。</p>
<p>当 <em>name</em> 变量的形式为 <code class="docutils literal notranslate"><span class="pre">package.module</span></code> 时，通常将会返回最高层级的包（第一个点号之前的名称），而 <em>不是</em> 以 <em>name</em> 命名的模块。 但是，当给出了非空的 <em>fromlist</em> 参数时，则将返回以 <em>name</em> 命名的模块。</p>
<p>例如，语句 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spam</span></code> 的结果将为与以下代码作用相同的字节码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>语句 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spam.ham</span></code> 的结果将为以下调用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>请注意在这里 <a class="reference internal" href="#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 是如何返回顶层模块的，因为这是通过 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句被绑定到特定名称的对象。</p>
<p>另一方面，语句 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">spam.ham</span> <span class="pre">import</span> <span class="pre">eggs,</span> <span class="pre">sausage</span> <span class="pre">as</span> <span class="pre">saus</span></code> 的结果将为</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_temp</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">eggs</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">eggs</span>
<span class="n">saus</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">sausage</span>
</pre></div>
</div>
<p>在这里， <code class="docutils literal notranslate"><span class="pre">spam.ham</span></code> 模块会由 <a class="reference internal" href="#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 返回。 要导入的对象将从此对象中提取并赋值给它们对应的名称。</p>
<p>如果您只想按名称导入模块（可能在包中），请使用 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span><em>level</em> 的值不再支持负数（默认值也修改为0）。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版更改: </span>当使用了命令行参数 <a class="reference internal" href="../using/cmdline.html#cmdoption-E"><code class="xref std std-option docutils literal notranslate"><span class="pre">-E</span></code></a> 或 <a class="reference internal" href="../using/cmdline.html#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 时，环境变量 <span class="target" id="index-25"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONCASEOK"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONCASEOK</span></code></a> 现在将被忽略。</p>
</div>
</dd></dl>

<p class="rubric">备注</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>解析器只接受 Unix 风格的行结束符。如果您从文件中读取代码，请确保用换行符转换模式转换 Windows 或 Mac 风格的换行符。</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="intro.html"
                          title="上一章">概述</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="constants.html"
                          title="下一章">内置常量</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/functions.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="constants.html" title="内置常量"
             >下一页</a> |</li>
        <li class="right" >
          <a href="intro.html" title="概述"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">内置函数</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 11月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0创建。
    </div>

  </body>
</html>