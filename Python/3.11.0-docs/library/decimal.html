
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>decimal --- 十进制定点和浮点运算 &#8212; Python 3.11.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="fractions --- 分数" href="fractions.html" />
    <link rel="prev" title="cmath --- 关于复数的数学函数" href="cmath.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/decimal.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> --- 十进制定点和浮点运算</a><ul>
<li><a class="reference internal" href="#quick-start-tutorial">快速入门教程</a></li>
<li><a class="reference internal" href="#decimal-objects">Decimal 对象</a><ul>
<li><a class="reference internal" href="#logical-operands">逻辑操作数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-objects">上下文对象</a></li>
<li><a class="reference internal" href="#constants">常量</a></li>
<li><a class="reference internal" href="#rounding-modes">舍入模式</a></li>
<li><a class="reference internal" href="#signals">信号</a></li>
<li><a class="reference internal" href="#floating-point-notes">浮点数说明</a><ul>
<li><a class="reference internal" href="#mitigating-round-off-error-with-increased-precision">通过提升精度来解决舍入错误</a></li>
<li><a class="reference internal" href="#special-values">特殊的值</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-threads">使用线程</a></li>
<li><a class="reference internal" href="#recipes">例程</a></li>
<li><a class="reference internal" href="#decimal-faq">Decimal 常见问题</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="cmath.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code> --- 关于复数的数学函数</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="fractions.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code> --- 分数</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/decimal.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="fractions --- 分数"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="cmath --- 关于复数的数学函数"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" accesskey="U">数字和数学模块</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> --- 十进制定点和浮点运算</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-decimal">
<span id="decimal-decimal-fixed-point-and-floating-point-arithmetic"></span><h1><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> --- 十进制定点和浮点运算<a class="headerlink" href="#module-decimal" title="永久链接至标题">¶</a></h1>
<p><strong>源码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/decimal.py">Lib/decimal.py</a></p>
<hr class="docutils" />
<p>The <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> module provides support for fast correctly rounded
decimal floating point arithmetic. It offers several advantages over the
<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> datatype:</p>
<ul>
<li><p>Decimal 类型的“设计是基于考虑人类习惯的浮点数模型，并且因此具有以下最高指导原则 —— 计算机必须提供与人们在学校所学习的算术相一致的算术。” —— 摘自 decimal 算术规范描述。</p></li>
<li><p>Decimal 数字的表示是完全精确的。 相比之下，<code class="xref py py-const docutils literal notranslate"><span class="pre">1.1</span></code> 和 <code class="xref py py-const docutils literal notranslate"><span class="pre">2.2</span></code> 这样的数字在二进制浮点中没有精确的表示。 最终用户通常不希望 <code class="docutils literal notranslate"><span class="pre">1.1</span> <span class="pre">+</span> <span class="pre">2.2</span></code> 如二进制浮点数表示那样被显示为 <code class="xref py py-const docutils literal notranslate"><span class="pre">3.3000000000000003</span></code>。</p></li>
<li><p>精确性会延续到算术类操作中。 对于 decimal 浮点数，<code class="docutils literal notranslate"><span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">-</span> <span class="pre">0.3</span></code> 会精确地等于零。 而对于二进制浮点数，结果则为 <code class="xref py py-const docutils literal notranslate"><span class="pre">5.5511151231257827e-017</span></code> 。 虽然接近于零，但其中的误差将妨碍可靠的相等性检验，并且误差还会不断累积。 因此，decimal 更适合具有严格相等不变性要求的会计类应用。</p></li>
<li><p>十进制模块包含有效位的概念，因此 <code class="docutils literal notranslate"><span class="pre">1.30</span> <span class="pre">+</span> <span class="pre">1.20</span></code> 的结果是 <code class="xref py py-const docutils literal notranslate"><span class="pre">2.50</span></code> 。 保留尾随零以表示有效位。 这是货币的惯用表示方法。乘法则沿用 “教科书“ 中：保留被乘数中的所有数字的方法。 例如， <code class="docutils literal notranslate"><span class="pre">1.3</span> <span class="pre">*</span> <span class="pre">1.2</span></code> 结果是 <code class="xref py py-const docutils literal notranslate"><span class="pre">1.56</span></code> 而 <code class="docutils literal notranslate"><span class="pre">1.30</span> <span class="pre">*</span> <span class="pre">1.20</span></code> 结果是 <code class="xref py py-const docutils literal notranslate"><span class="pre">1.5600</span></code> 。</p></li>
<li><p>与基于硬件的二进制浮点不同，十进制模块具有用户可更改的精度（默认为28位），可以与给定问题所需的一样大：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1428571428571428571428571429&#39;)</span>
</pre></div>
</div>
</li>
<li><p>二进制和 decimal 浮点数都是根据已发布的标准实现的。 虽然内置浮点类型只公开其功能的一小部分，但 decimal 模块公开了标准的所有必需部分。 在需要时，程序员可以完全控制舍入和信号处理。 这包括通过使用异常来阻止任何不精确操作来强制执行精确算术的选项。</p></li>
<li><p>decimal 模块旨在支持“无偏差，精确无舍入的十进制算术（有时称为定点数算术）和有舍入的浮点数算术”。 —— 摘自 decimal 算术规范说明。</p></li>
</ul>
<p>该模块的设计以三个概念为中心：decimal 数值，算术上下文和信号。</p>
<p>decimal 数值是不可变对象。 它由符号，系数和指数位组成。 为了保持有效位，系数位不会截去末尾零。 decimal 数值也包括特殊值例如 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> ，<code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code> 和 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 。 该标准还区分 <code class="xref py py-const docutils literal notranslate"><span class="pre">-0</span></code> 和 <code class="xref py py-const docutils literal notranslate"><span class="pre">+0</span></code> 。</p>
<p>算术的上下文是指定精度、舍入规则、指数限制、指示操作结果的标志以及确定符号是否被视为异常的陷阱启用器的环境。 舍入选项包括 <a class="reference internal" href="#decimal.ROUND_CEILING" title="decimal.ROUND_CEILING"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_CEILING</span></code></a> 、 <a class="reference internal" href="#decimal.ROUND_DOWN" title="decimal.ROUND_DOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_DOWN</span></code></a> 、 <a class="reference internal" href="#decimal.ROUND_FLOOR" title="decimal.ROUND_FLOOR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_FLOOR</span></code></a> 、 <a class="reference internal" href="#decimal.ROUND_HALF_DOWN" title="decimal.ROUND_HALF_DOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 、 <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_UP</span></code></a> 、 <a class="reference internal" href="#decimal.ROUND_UP" title="decimal.ROUND_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_UP</span></code></a> 以及 <a class="reference internal" href="#decimal.ROUND_05UP" title="decimal.ROUND_05UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_05UP</span></code></a>.</p>
<p>信号是在计算过程中出现的异常条件组。 根据应用程序的需要，信号可能会被忽略，被视为信息，或被视为异常。 十进制模块中的信号有：<a class="reference internal" href="#decimal.Clamped" title="decimal.Clamped"><code class="xref py py-const docutils literal notranslate"><span class="pre">Clamped</span></code></a> 、 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 、 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 、 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> 、 <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a> 、 <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal notranslate"><span class="pre">Subnormal</span></code></a> 、 <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-const docutils literal notranslate"><span class="pre">Overflow</span></code></a> 、 <a class="reference internal" href="#decimal.Underflow" title="decimal.Underflow"><code class="xref py py-const docutils literal notranslate"><span class="pre">Underflow</span></code></a> 以及 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 。</p>
<p>对于每个信号，都有一个标志和一个陷阱启动器。 遇到信号时，其标志设置为 1 ，然后，如果陷阱启用器设置为 1 ，则引发异常。 标志是粘性的，因此用户需要在监控计算之前重置它们。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<ul class="simple">
<li><p>IBM's General Decimal Arithmetic Specification, <a class="reference external" href="https://speleotrove.com/decimal/decarith.html">The General Decimal Arithmetic
Specification</a>.</p></li>
</ul>
</div>
<section id="quick-start-tutorial">
<span id="decimal-tutorial"></span><h2>快速入门教程<a class="headerlink" href="#quick-start-tutorial" title="永久链接至标题">¶</a></h2>
<p>通常使用 decimal 的方式是先导入该模块，通过 <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 查看当前上下文，并在必要时为精度、舍入或启用的陷阱设置新值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,</span>
<span class="go">        InvalidOperation])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">7</span>       <span class="c1"># Set a new precision</span>
</pre></div>
</div>
<p>可以基于整数、字符串、浮点数或元组构造 Decimal 实例。 基于整数或浮点数构造将执行该整数或浮点值的精确转换。 Decimal 数字包括特殊值例如 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 表示“非数字”，正的和负的 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> 和 <code class="xref py py-const docutils literal notranslate"><span class="pre">-0</span></code></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.14&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.4142135623730951&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.5&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<p>如果 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 信号被捕获，构造函数中的小数和浮点数的意外混合或排序比较会引发异常</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">getcontext</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">FloatOperation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3.7</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mf">3.5</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<p>新 Decimal 的重要性仅由输入的位数决定。 上下文精度和舍入仅在算术运算期间发挥作用。</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.0&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415926535&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85987&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_UP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85988&#39;)</span>
</pre></div>
</div>
<p>如果超出了 C 版本的内部限制，则构造一个 decimal 将引发 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1e9999999999999999999&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.InvalidOperation</span>: <span class="n">[&lt;class &#39;decimal.InvalidOperation&#39;&gt;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改.</span></p>
</div>
<p>Decimal 数字能很好地与 Python 的其余部分交互。 以下是一个小小的 decimal 浮点数飞行马戏团：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">[Decimal(&#39;0.03&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;1.34&#39;), Decimal(&#39;1.87&#39;),</span>
<span class="go"> Decimal(&#39;2.35&#39;), Decimal(&#39;3.45&#39;), Decimal(&#39;9.25&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;19.29&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;1.34&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.3&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">5</span>
<span class="go">Decimal(&#39;6.70&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">Decimal(&#39;2.5058&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">%</span> <span class="n">a</span>
<span class="go">Decimal(&#39;0.77&#39;)</span>
</pre></div>
</div>
<p>Decimal 也可以使用一些数学函数：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ln</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.302585092994045684017991455&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">log10</span><span class="p">()</span>
<span class="go">Decimal(&#39;1&#39;)</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code> 方法将数字舍入为固定指数。 此方法对于将结果舍入到固定的位置的货币应用程序非常有用：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;.01&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="go">Decimal(&#39;7.32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_UP</span><span class="p">)</span>
<span class="go">Decimal(&#39;8&#39;)</span>
</pre></div>
</div>
<p>如上所示，<a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 函数访问当前上下文并允许更改设置。 这种方法满足大多数应用程序的需求。</p>
<p>对于更高级的工作，使用 Context() 构造函数创建备用上下文可能很有用。 要使用备用活动，请使用 <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 函数。</p>
<p>根据标准，<a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 模块提供了两个现成的标准上下文 <a class="reference internal" href="#decimal.BasicContext" title="decimal.BasicContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">BasicContext</span></code></a> 和 <a class="reference internal" href="#decimal.ExtendedContext" title="decimal.ExtendedContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">ExtendedContext</span></code></a> 。 前者对调试特别有用，因为许多陷阱都已启用：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myothercontext</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_HALF_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">myothercontext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857142857142857142857142857142857142857142857142857142857&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtendedContext</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857143&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">BasicContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#143&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>上下文还具有用于监视计算期间遇到的异常情况的信号标志。 标志保持设置直到明确清除，因此最好通过使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear_flags()</span></code> 方法清除每组受监控计算之前的标志。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">clear_flags</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">355</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14159292&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])</span>
</pre></div>
</div>
<p><em>flags</em> 条目显示对 <code class="xref py py-const docutils literal notranslate"><span class="pre">Pi</span></code> 的有理逼近被舍入（超出上下文精度的数字被抛弃）并且结果是不精确的（一些丢弃的数字不为零）。</p>
<p>使用上下文的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">traps</span></code> 字段中的字典设置单个陷阱：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">DivisionByZero</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#112&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>大多数程序仅在程序开始时调整当前上下文一次。 并且，在许多应用程序中，数据在循环内单个强制转换为 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 。 通过创建上下文集和小数，程序的大部分操作数据与其他 Python 数字类型没有区别。</p>
</section>
<section id="decimal-objects">
<span id="decimal-decimal"></span><h2>Decimal 对象<a class="headerlink" href="#decimal-objects" title="永久链接至标题">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.Decimal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Decimal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>value</em> 构造一个新的 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 对象。</p>
<p><em>value</em> 可以是整数，字符串，元组，<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> ，或另一个 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 对象。 如果没有给出 <em>value</em>，则返回 <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code>。 如果 <em>value</em> 是一个字符串，它应该在前导和尾随空格字符以及下划线被删除之后符合十进制数字字符串语法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sign</span>           <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;+&#39;</span> <span class="o">|</span> <span class="s1">&#39;-&#39;</span>
<span class="n">digit</span>          <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;0&#39;</span> <span class="o">|</span> <span class="s1">&#39;1&#39;</span> <span class="o">|</span> <span class="s1">&#39;2&#39;</span> <span class="o">|</span> <span class="s1">&#39;3&#39;</span> <span class="o">|</span> <span class="s1">&#39;4&#39;</span> <span class="o">|</span> <span class="s1">&#39;5&#39;</span> <span class="o">|</span> <span class="s1">&#39;6&#39;</span> <span class="o">|</span> <span class="s1">&#39;7&#39;</span> <span class="o">|</span> <span class="s1">&#39;8&#39;</span> <span class="o">|</span> <span class="s1">&#39;9&#39;</span>
<span class="n">indicator</span>      <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;e&#39;</span> <span class="o">|</span> <span class="s1">&#39;E&#39;</span>
<span class="n">digits</span>         <span class="p">:</span><span class="o">:=</span>  <span class="n">digit</span> <span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">...</span>
<span class="n">decimal</span><span class="o">-</span><span class="n">part</span>   <span class="p">:</span><span class="o">:=</span>  <span class="n">digits</span> <span class="s1">&#39;.&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">exponent</span><span class="o">-</span><span class="n">part</span>  <span class="p">:</span><span class="o">:=</span>  <span class="n">indicator</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">infinity</span>       <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;Infinity&#39;</span> <span class="o">|</span> <span class="s1">&#39;Inf&#39;</span>
<span class="n">nan</span>            <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;NaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="s1">&#39;sNaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">value</span>  <span class="p">:</span><span class="o">:=</span>  <span class="n">decimal</span><span class="o">-</span><span class="n">part</span> <span class="p">[</span><span class="n">exponent</span><span class="o">-</span><span class="n">part</span><span class="p">]</span> <span class="o">|</span> <span class="n">infinity</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">string</span> <span class="p">:</span><span class="o">:=</span>  <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">numeric</span><span class="o">-</span><span class="n">value</span> <span class="o">|</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">nan</span>
</pre></div>
</div>
<p>当上面出现 <code class="docutils literal notranslate"><span class="pre">digit</span></code> 时也允许其他十进制数码。 其中包括来自各种其他语言系统的十进制数码（例如阿拉伯-印地语和天城文的数码）以及全宽数码 <code class="docutils literal notranslate"><span class="pre">'\uff10'</span></code> 到 <code class="docutils literal notranslate"><span class="pre">'\uff19'</span></code>。</p>
<p>如果 <em>value</em> 是一个 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> ，它应该有三个组件，一个符号（ <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> 表示正数或 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> 表示负数），一个数字的 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和整数指数。 例如， <code class="docutils literal notranslate"><span class="pre">Decimal((0,</span> <span class="pre">(1,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">4),</span> <span class="pre">-3))</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">Decimal('1.414')</span></code>。</p>
<p>如果 <em>value</em> 是 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> ，则二进制浮点值无损地转换为其精确的十进制等效值。 此转换通常需要53位或更多位数的精度。 例如， <code class="docutils literal notranslate"><span class="pre">Decimal(float('1.1'))</span></code> 转换为``Decimal('1.100000000000000088817841970012523233890533447265625')``。</p>
<p><em>context</em> 精度不会影响存储的位数。 这完全由 <em>value</em> 中的位数决定。 例如，<code class="docutils literal notranslate"><span class="pre">Decimal('3.00000')</span></code> 记录所有五个零，即使上下文精度只有三。</p>
<p><em>context</em> 参数的目的是确定 <em>value</em> 是格式错误的字符串时该怎么做。 如果上下文陷阱 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>，则引发异常；否则，构造函数返回一个新的 Decimal，其值为 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>。</p>
<p>构造完成后， <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 对象是不可变的。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>现在允许构造函数的参数为 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 实例。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 参数在设置 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 陷阱时引发异常。 默认情况下，陷阱已关闭。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>允许下划线进行分组，就像代码中的整数和浮点文字一样。</p>
</div>
<p>十进制浮点对象与其他内置数值类型共享许多属性，例如 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 和 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 。 所有常用的数学运算和特殊方法都适用。 同样，十进制对象可以复制、pickle、打印、用作字典键、用作集合元素、比较、排序和强制转换为另一种类型（例如 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 或 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> ）。</p>
<p>算术对十进制对象和算术对整数和浮点数有一些小的差别。 当余数运算符 <code class="docutils literal notranslate"><span class="pre">%</span></code> 应用于Decimal对象时，结果的符号是 <em>被除数</em> 的符号，而不是除数的符号:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-3&#39;)</span>
</pre></div>
</div>
<p>整数除法运算符 <code class="docutils literal notranslate"><span class="pre">//</span></code> 的行为类似，返回真商的整数部分（截断为零）而不是它的向下取整，以便保留通常的标识 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">7</span> <span class="o">//</span> <span class="mi">4</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">%</span></code> 和 <code class="docutils literal notranslate"><span class="pre">//</span></code> 运算符实现了 <code class="docutils literal notranslate"><span class="pre">remainder</span></code> 和 <code class="docutils literal notranslate"><span class="pre">divide-integer</span></code> 操作（分别），如规范中所述。</p>
<p>十进制对象通常不能与浮点数或 <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> 实例在算术运算中结合使用：例如,尝试将 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 加到 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> ，将引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 但是，可以使用 Python 的比较运算符来比较 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例 <code class="docutils literal notranslate"><span class="pre">x</span></code> 和另一个数字 <code class="docutils literal notranslate"><span class="pre">y</span></code> 。 这样可以避免在对不同类型的数字进行相等比较时混淆结果。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>现在完全支持 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例和其他数字类型之间的混合类型比较。</p>
</div>
<p>除了标准的数字属性，十进制浮点对象还有许多专门的方法：</p>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.adjusted">
<span class="sig-name descname"><span class="pre">adjusted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.adjusted" title="永久链接至目标">¶</a></dt>
<dd><p>在移出系数最右边的数字之后返回调整后的指数，直到只剩下前导数字：<code class="docutils literal notranslate"><span class="pre">Decimal('321e+5').adjusted()</span></code> 返回 7 。 用于确定最高有效位相对于小数点的位置。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.as_integer_ratio">
<span class="sig-name descname"><span class="pre">as_integer_ratio</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_integer_ratio" title="永久链接至目标">¶</a></dt>
<dd><p>返回一对 <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code> 整数，表示给定的 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例作为分数、最简形式项并带有正分母:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-3.14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-157, 50)</span>
</pre></div>
</div>
<p>转换是精确的。 在 Infinity 上引发 OverflowError ，在 NaN 上引起 ValueError 。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">3.6 新版功能.</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.as_tuple">
<span class="sig-name descname"><span class="pre">as_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_tuple" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> 表示的数字： <code class="docutils literal notranslate"><span class="pre">DecimalTuple(sign,</span> <span class="pre">digits,</span> <span class="pre">exponent)</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.canonical">
<span class="sig-name descname"><span class="pre">canonical</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.canonical" title="永久链接至目标">¶</a></dt>
<dd><p>返回参数的规范编码。 目前，一个 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例的编码始终是规范的，因此该操作返回其参数不变。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare">
<span class="sig-name descname"><span class="pre">compare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare" title="永久链接至目标">¶</a></dt>
<dd><p>比较两个 Decimal 实例的值。 <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> 返回一个 Decimal 实例，如果任一操作数是 NaN ，那么结果是 NaN</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">NaN</span>  <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">==</span> <span class="n">b</span>           <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare_signal">
<span class="sig-name descname"><span class="pre">compare_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_signal" title="永久链接至目标">¶</a></dt>
<dd><p>除了所有 NaN 信号之外，此操作与 <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> 方法相同。 也就是说，如果两个操作数都不是信令NaN，那么任何静默的 NaN 操作数都被视为信令NaN。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare_total">
<span class="sig-name descname"><span class="pre">compare_total</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total" title="永久链接至目标">¶</a></dt>
<dd><p>使用它们的抽象表示而不是它们的数值来比较两个操作数。 类似于 <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> 方法，但结果给出了一个总排序 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例。 两个 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例具有相同的数值但不同的表示形式在此排序中比较不相等：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12.0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">compare_total</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p>静默和发出信号的 NaN 也包括在总排序中。 这个函数的结果是 <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code> 如果两个操作数具有相同的表示，或是 <code class="docutils literal notranslate"><span class="pre">Decimal('-1')</span></code> 如果第一个操作数的总顺序低于第二个操作数，或是 <code class="docutils literal notranslate"><span class="pre">Decimal('1')</span></code> 如果第一个操作数在总顺序中高于第二个操作数。 有关总排序的详细信息，请参阅规范。</p>
<p>此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare_total_mag">
<span class="sig-name descname"><span class="pre">compare_total_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total_mag" title="永久链接至目标">¶</a></dt>
<dd><p>比较两个操作数使用它们的抽象表示而不是它们的值，如 <a class="reference internal" href="#decimal.Decimal.compare_total" title="decimal.Decimal.compare_total"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_total()</span></code></a>，但忽略每个操作数的符号。 <code class="docutils literal notranslate"><span class="pre">x.compare_total_mag(y)</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">x.copy_abs().compare_total(y.copy_abs())</span></code>。</p>
<p>此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.conjugate">
<span class="sig-name descname"><span class="pre">conjugate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.conjugate" title="永久链接至目标">¶</a></dt>
<dd><p>只返回self，这种方法只符合 Decimal 规范。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.copy_abs">
<span class="sig-name descname"><span class="pre">copy_abs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_abs" title="永久链接至目标">¶</a></dt>
<dd><p>返回参数的绝对值。 此操作不受上下文影响并且是静默的：没有更改标志且不执行舍入。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.copy_negate">
<span class="sig-name descname"><span class="pre">copy_negate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_negate" title="永久链接至目标">¶</a></dt>
<dd><p>回到参数的否定。 此操作不受上下文影响并且是静默的：没有标志更改且不执行舍入。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.copy_sign">
<span class="sig-name descname"><span class="pre">copy_sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_sign" title="永久链接至目标">¶</a></dt>
<dd><p>返回第一个操作数的副本，其符号设置为与第二个操作数的符号相同。 例如：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy_sign</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1.5&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2.3&#39;)</span>
</pre></div>
</div>
<p>此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.exp" title="永久链接至目标">¶</a></dt>
<dd><p>返回给定数字的（自然）指数函数``e**x``的值。结果使用 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 舍入模式正确舍入。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">321</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.561702493119680037517373933E+139&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.from_float">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.from_float" title="永久链接至目标">¶</a></dt>
<dd><p>另一个构造函数，只接受 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 或 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的实例。</p>
<p>Note <code class="docutils literal notranslate"><span class="pre">Decimal.from_float(0.1)</span></code> is not the same as <code class="docutils literal notranslate"><span class="pre">Decimal('0.1')</span></code>.
Since 0.1 is not exactly representable in binary floating point, the
value is stored as the nearest representable value which is
<code class="docutils literal notranslate"><span class="pre">0x1.999999999999ap-4</span></code>.  That equivalent value in decimal is
<code class="docutils literal notranslate"><span class="pre">0.1000000000000000055511151231257827021181583404541015625</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>从 Python 3.2 开始，<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例也可以直接从 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 构造。</p>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.fma">
<span class="sig-name descname"><span class="pre">fma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">third</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.fma" title="永久链接至目标">¶</a></dt>
<dd><p>混合乘法加法。 返回 self*other+third ，中间乘积 self*other 没有舍入。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Decimal(&#39;11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_canonical">
<span class="sig-name descname"><span class="pre">is_canonical</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_canonical" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数是规范的，则为返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，否则为 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> 。 目前，<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例总是规范的，所以这个操作总是返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_finite">
<span class="sig-name descname"><span class="pre">is_finite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_finite" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数是一个有限的数，则返回为 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> ；如果参数为无穷大或 NaN ，则返回为 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_infinite">
<span class="sig-name descname"><span class="pre">is_infinite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_infinite" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数为正负无穷大，则返回为 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> ，否则为 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_nan">
<span class="sig-name descname"><span class="pre">is_nan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_nan" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数为 NaN （无论是否静默），则返回为 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> ，否则为 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_normal">
<span class="sig-name descname"><span class="pre">is_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_normal" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数是一个 <em>标准的</em> 有限数则返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>。 如果参数为零、次标准数、无穷大或 NaN 则返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_qnan">
<span class="sig-name descname"><span class="pre">is_qnan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_qnan" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数为静默 NaN，返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，否则返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_signed">
<span class="sig-name descname"><span class="pre">is_signed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_signed" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数带有负号，则返回为 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，否则返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。注意，0 和 NaN 都可带有符号。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_snan">
<span class="sig-name descname"><span class="pre">is_snan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_snan" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数为显式 NaN，则返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，否则返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_subnormal">
<span class="sig-name descname"><span class="pre">is_subnormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_subnormal" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数为次标准数，则返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，否则返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_zero">
<span class="sig-name descname"><span class="pre">is_zero</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_zero" title="永久链接至目标">¶</a></dt>
<dd><p>如果参数是0（正负皆可），则返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，否则返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.ln">
<span class="sig-name descname"><span class="pre">ln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.ln" title="永久链接至目标">¶</a></dt>
<dd><p>返回操作数的自然对数（以 e 为底）。结果是使用 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 舍入模式正确舍入的。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.log10">
<span class="sig-name descname"><span class="pre">log10</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.log10" title="永久链接至目标">¶</a></dt>
<dd><p>返回操作数的以十为底的对数。结果是使用 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 舍入模式正确舍入的。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logb">
<span class="sig-name descname"><span class="pre">logb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logb" title="永久链接至目标">¶</a></dt>
<dd><p>对于一个非零数，返回其运算数的调整后指数作为一个 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例。 如果运算数为零将返回 <code class="docutils literal notranslate"><span class="pre">Decimal('-Infinity')</span></code> 并且产生 the <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 标志。如果运算数是无限大则返回 <code class="docutils literal notranslate"><span class="pre">Decimal('Infinity')</span></code> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_and">
<span class="sig-name descname"><span class="pre">logical_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_and" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_and" title="decimal.Decimal.logical_and"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_and()</span></code></a> 是需要两个 <em>逻辑运算数</em> 的逻辑运算（参考 <a class="reference internal" href="#logical-operands-label"><span class="std std-ref">逻辑操作数</span></a> ）。按位输出两运算数的 <code class="docutils literal notranslate"><span class="pre">and</span></code> 运算的结果。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_invert">
<span class="sig-name descname"><span class="pre">logical_invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_invert" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_invert" title="decimal.Decimal.logical_invert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_invert()</span></code></a> 是一个逻辑运算。结果是操作数的按位求反。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_or">
<span class="sig-name descname"><span class="pre">logical_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_or" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_or" title="decimal.Decimal.logical_or"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_or()</span></code></a> 是需要两个 <em>logical operands</em> 的逻辑运算（请参阅 <a class="reference internal" href="#logical-operands-label"><span class="std std-ref">逻辑操作数</span></a> ）。结果是两个运算数的按位的 <code class="docutils literal notranslate"><span class="pre">or</span></code> 运算。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_xor">
<span class="sig-name descname"><span class="pre">logical_xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_xor" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_xor" title="decimal.Decimal.logical_xor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_xor()</span></code></a> 是需要两个 <em>逻辑运算数</em> 的逻辑运算（参考 <a class="reference internal" href="#logical-operands-label"><span class="std std-ref">逻辑操作数</span></a> ）。结果是按位输出的两运算数的异或运算。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max" title="永久链接至目标">¶</a></dt>
<dd><p>像 <code class="docutils literal notranslate"><span class="pre">max(self,</span> <span class="pre">other)</span></code> 一样，除了在返回之前应用上下文舍入规则并且用信号通知或忽略 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 值（取决于上下文以及它们是发信号还是安静）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.max_mag">
<span class="sig-name descname"><span class="pre">max_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max_mag" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#decimal.Decimal.max" title="decimal.Decimal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a> 方法相似，但是操作数使用绝对值完成比较。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min" title="永久链接至目标">¶</a></dt>
<dd><p>像 <code class="docutils literal notranslate"><span class="pre">min(self,</span> <span class="pre">other)</span></code> 一样，除了在返回之前应用上下文舍入规则并且用信号通知或忽略 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 值（取决于上下文以及它们是发信号还是安静）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.min_mag">
<span class="sig-name descname"><span class="pre">min_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min_mag" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#decimal.Decimal.min" title="decimal.Decimal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a> 方法相似，但是操作数使用绝对值完成比较。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.next_minus">
<span class="sig-name descname"><span class="pre">next_minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_minus" title="永久链接至目标">¶</a></dt>
<dd><p>返回小于给定操作数的上下文中可表示的最大数字（或者当前线程的上下文中的可表示的最大数字如果没有给定上下文）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.next_plus">
<span class="sig-name descname"><span class="pre">next_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_plus" title="永久链接至目标">¶</a></dt>
<dd><p>返回大于给定操作数的上下文中可表示的最小数字（或者当前线程的上下文中的可表示的最小数字如果没有给定上下文）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.next_toward">
<span class="sig-name descname"><span class="pre">next_toward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_toward" title="永久链接至目标">¶</a></dt>
<dd><p>如果两运算数不相等，返回在第二个操作数的方向上最接近第一个操作数的数。如果两操作数数值上相等，返回将符号设置为与第二个运算数相同的第一个运算数的拷贝。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.normalize" title="永久链接至目标">¶</a></dt>
<dd><p>通过去除尾随的零并将所有结果等于 <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('0')</span></code> 的转化为 <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('0e0')</span></code> 来标准化数字。用于为等效类的属性生成规范值。比如， <code class="docutils literal notranslate"><span class="pre">Decimal('32.100')</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Decimal('0.321000e+2')</span></code> 都被标准化为相同的值 <code class="docutils literal notranslate"><span class="pre">Decimal('32.1')</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.number_class">
<span class="sig-name descname"><span class="pre">number_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.number_class" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个字符串描述运算数的 <em>class</em> 。返回值是以下十个字符串中的一个。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Infinity&quot;</span></code> ，指示运算数为负无穷大。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Normal&quot;</span></code> ，指示该运算数是负正常数字。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Subnormal&quot;</span></code> ，指示该运算数是负的次标准数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Zero&quot;</span></code> ，指示该运算数是负零。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Zero&quot;</span></code> ，指示该运算数是正零。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Subnormal&quot;</span></code> ，指示该运算数是正的次标准数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Normal&quot;</span></code> ，指示该运算数是正的标准数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Infinity&quot;</span></code> ，指示该运算数是正无穷。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;NaN&quot;</span></code> ，指示该运算数是肃静 NaN （非数字）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;sNaN&quot;</span></code> ，指示该运算数是信号 NaN 。</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.quantize">
<span class="sig-name descname"><span class="pre">quantize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.quantize" title="永久链接至目标">¶</a></dt>
<dd><p>返回的值等于舍入后的第一个运算数并且具有第二个操作数的指数。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.41421356&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.000&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.414&#39;)</span>
</pre></div>
</div>
<p>与其他运算不同，如果量化运算后的系数长度大于精度，那么会发出一个 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 信号。这保证了除非有一个错误情况，量化指数恒等于右手运算数的指数。</p>
<p>与其他运算不同，量化永不信号下溢，即使结果不正常且不精确。</p>
<p>如果第二个运算数的指数大于第一个运算数的指数那或许需要舍入。在这种情况下，舍入模式由给定 <code class="docutils literal notranslate"><span class="pre">rounding</span></code> 参数决定，其余的由给定 <code class="docutils literal notranslate"><span class="pre">context</span></code> 参数决定；如果参数都未给定，使用当前线程上下文的舍入模式。</p>
<p>每当结果的指数大于 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> 或小于 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Etiny</span></code> 就会返回错误。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.radix">
<span class="sig-name descname"><span class="pre">radix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.radix" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">Decimal(10)</span></code>，即 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 类进行所有算术运算所用的数制（基数）。 这是为保持与规范描述的兼容性而加入的。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.remainder_near">
<span class="sig-name descname"><span class="pre">remainder_near</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.remainder_near" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>self</em> 除以 <em>other</em> 的余数。 这与 <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">%</span> <span class="pre">other</span></code> 的区别在于所选择的余数要使其绝对值最小化。 更准确地说，返回值为 <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">other</span></code> 其中 <code class="docutils literal notranslate"><span class="pre">n</span></code> 是最接近 <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">/</span> <span class="pre">other</span></code> 的实际值的整数，并且如果两个整数与实际值的差相等则会选择其中的偶数。</p>
<p>如果结果为零则其符号将为 <em>self</em> 的符号。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;5&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-5&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.rotate" title="永久链接至目标">¶</a></dt>
<dd><p>返回对第一个操作数的数码按第二个操作数所指定的数量进行轮转的结果。 第二个操作数必须为 -precision 至 precision 精度范围内的整数。 第二个操作数的绝对值给出要轮转的位数。 如果第二个操作数为正值则向左轮转；否则向右轮转。 如有必要第一个操作数的系数会在左侧填充零以达到 precision 所指定的长度。 第一个操作数的符号和指数保持不变。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.same_quantum">
<span class="sig-name descname"><span class="pre">same_quantum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.same_quantum" title="永久链接至目标">¶</a></dt>
<dd><p>检测自身与 other 是否具有相同的指数或是否均为 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>。</p>
<p>此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.scaleb">
<span class="sig-name descname"><span class="pre">scaleb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.scaleb" title="永久链接至目标">¶</a></dt>
<dd><p>返回第一个操作数使用第二个操作数对指数进行调整的结果。 等价于返回第一个操作数乘以 <code class="docutils literal notranslate"><span class="pre">10**other</span></code> 的结果。 第二个操作数必须为整数。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.shift">
<span class="sig-name descname"><span class="pre">shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.shift" title="永久链接至目标">¶</a></dt>
<dd><p>返回第一个操作数的数码按第二个操作数所指定的数量进行移位的结果。 第二个操作数必须为 -precision 至 precision 范围内的整数。 第二个操作数的绝对值给出要移动的位数。 如果第二个操作数为正值则向左移位；否则向右移位。 移入系数的数码为零。 第一个操作数的符号和指数保持不变。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.sqrt">
<span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.sqrt" title="永久链接至目标">¶</a></dt>
<dd><p>返回参数的平方根精确到完整精度。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_eng_string">
<span class="sig-name descname"><span class="pre">to_eng_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_eng_string" title="永久链接至目标">¶</a></dt>
<dd><p>转换为字符串，如果需要指数则会使用工程标注法。</p>
<p>工程标注法的指数是 3 的倍数。 这会在十进制位的左边保留至多 3 个数码，并可能要求添加一至两个末尾零。</p>
<p>例如，此方法会将 <code class="docutils literal notranslate"><span class="pre">Decimal('123E+1')</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">Decimal('1.23E+3')</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_integral">
<span class="sig-name descname"><span class="pre">to_integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#decimal.Decimal.to_integral_value" title="decimal.Decimal.to_integral_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_integral_value()</span></code></a> 方法相同。 保留 <code class="docutils literal notranslate"><span class="pre">to_integral</span></code> 名称是为了与旧版本兼容。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_integral_exact">
<span class="sig-name descname"><span class="pre">to_integral_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_exact" title="永久链接至目标">¶</a></dt>
<dd><p>舍入到最接近的整数，发出信号 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> 或者如果发生舍入则相应地发出信号 <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a>。 如果给出 <code class="docutils literal notranslate"><span class="pre">rounding</span></code> 形参则由其确定舍入模式，否则由给定的 <code class="docutils literal notranslate"><span class="pre">context</span></code> 来确定。 如果没有给定任何形参则会使用当前上下文的舍入模式。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_integral_value">
<span class="sig-name descname"><span class="pre">to_integral_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_value" title="永久链接至目标">¶</a></dt>
<dd><p>舍入到最接近的整数而不发出 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> 或 <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a> 信号。 如果给出 <em>rounding</em> 则会应用其所指定的舍入模式；否则使用所提供的 <em>context</em> 或当前上下文的舍入方法。</p>
</dd></dl>

</dd></dl>

<section id="logical-operands">
<span id="logical-operands-label"></span><h3>逻辑操作数<a class="headerlink" href="#logical-operands" title="永久链接至标题">¶</a></h3>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_and()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_invert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_or()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_xor()</span></code> 方法期望其参数为 <em>逻辑操作数</em>。 <em>逻辑操作数</em> 是指数位与符号位均为零的 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例，并且其数字位均为 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> 或 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>。</p>
</section>
</section>
<section id="context-objects">
<span id="decimal-context"></span><h2>上下文对象<a class="headerlink" href="#context-objects" title="永久链接至标题">¶</a></h2>
<p>上下文是算术运算所在的环境。 它们管理精度、设置舍入规则、确定将哪些信号视为异常，并限制指数的范围。</p>
<p>每个线程都有自己的当前上下文，可使用 <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 和 <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 函数来读取或修改：</p>
<dl class="py function">
<dt class="sig sig-object py" id="decimal.getcontext">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">getcontext</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.getcontext" title="永久链接至目标">¶</a></dt>
<dd><p>返回活动线程的当前上下文。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decimal.setcontext">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">setcontext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.setcontext" title="永久链接至目标">¶</a></dt>
<dd><p>将活动线程的当前上下文设为 <em>c</em>。</p>
</dd></dl>

<p>你也可以使用 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句和 <a class="reference internal" href="#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">localcontext()</span></code></a> 函数来临时改变活动上下文。</p>
<dl class="py function">
<dt class="sig sig-object py" id="decimal.localcontext">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">localcontext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">\*\*kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.localcontext" title="永久链接至目标">¶</a></dt>
<dd><p>Return a context manager that will set the current context for the active thread
to a copy of <em>ctx</em> on entry to the with-statement and restore the previous context
when exiting the with-statement. If no context is specified, a copy of the
current context is used.  The <em>kwargs</em> argument is used to set the attributes
of the new context.</p>
<p>例如，以下代码会将当前 decimal 精度设为 42 位，执行一个运算，然后自动恢复之前的上下文:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">42</span>   <span class="c1"># Perform a high precision calculation</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>  <span class="c1"># Round the final result back to the default precision</span>
</pre></div>
</div>
<p>Using keyword arguments, the code would be the following:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>
</pre></div>
</div>
<p>Raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> if <em>kwargs</em> supplies an attribute that <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> doesn't
support.  Raises either <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> or <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> if <em>kwargs</em> supplies an
invalid value for an attribute.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版更改: </span><a class="reference internal" href="#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localcontext()</span></code></a> now supports setting context attributes through the use of keyword arguments.</p>
</div>
</dd></dl>

<p>新的上下文也可使用下述的 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 构造器来创建。 此外，模块还提供了三种预设的上下文:</p>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.BasicContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">BasicContext</span></span><a class="headerlink" href="#decimal.BasicContext" title="永久链接至目标">¶</a></dt>
<dd><p>这是由通用十进制算术规范描述所定义的标准上下文。 精度设为九。 舍入设为 <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_UP</span></code></a>。 清除所有旗标。 启用所有陷阱（视为异常），但 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a> 和 <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal notranslate"><span class="pre">Subnormal</span></code></a> 除外。</p>
<p>由于启用了许多陷阱，此上下文适用于进行调试。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.ExtendedContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ExtendedContext</span></span><a class="headerlink" href="#decimal.ExtendedContext" title="永久链接至目标">¶</a></dt>
<dd><p>这是由通用十进制算术规范描述所定义的标准上下文。 精度设为九。 舍入设为 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>。 清除所有旗标。 不启用任何陷阱（因此在计算期间不会引发异常）。</p>
<p>由于禁用了陷阱，此上下文适用于希望结果值为 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 或 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> 而不是引发异常的应用。 这允许应用在出现当其他情况下会中止程序的条件时仍能完成运行。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.DefaultContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">DefaultContext</span></span><a class="headerlink" href="#decimal.DefaultContext" title="永久链接至目标">¶</a></dt>
<dd><p>此上下文被 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 构造器用作新上下文的原型。 改变一个字段（例如精度）的效果将是改变 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 构造器所创建的新上下文的默认值。</p>
<p>此上下文最适用于多线程环境。 在线程开始前改变一个字段具有设置全系统默认值的效果。 不推荐在线程开始后改变字段，因为这会要求线程同步避免竞争条件。</p>
<p>在单线程环境中，最好完全不使用此上下文。 而是简单地电显式创建上下文，具体如下所述。</p>
<p>默认值为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code>=<code class="xref py py-const docutils literal notranslate"><span class="pre">28</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">rounding</span></code>=<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>，并为 <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 和 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 启用陷阱。</p>
</dd></dl>

<p>在已提供的三种上下文之外，还可以使用 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 构造器创建新的上下文。</p>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.Context">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capitals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context" title="永久链接至目标">¶</a></dt>
<dd><p>创建一个新上下文。 如果某个字段未指定或为 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>，则从 <a class="reference internal" href="#decimal.DefaultContext" title="decimal.DefaultContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">DefaultContext</span></code></a> 拷贝默认值。 如果 <em>flags</em> 字段未指定或为 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>，则清空所有旗标。</p>
<p><em>prec</em> 为一个 [<code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>, <a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_PREC</span></code></a>] 范围内的整数，用于设置该上下文中算术运算的精度。</p>
<p><em>rounding</em> 选项应为 <a class="reference internal" href="#rounding-modes">Rounding Modes</a> 小节中列出的常量之一。</p>
<p><em>traps</em> 和 <em>flags</em> 字段列出要设置的任何信号。 通常，新上下文应当只设置 traps 而让 flags 为空。</p>
<p><em>Emin</em> 和 <em>Emax</em> 字段给定指数所允许的外部上限。 <em>Emin</em> 必须在 [<a class="reference internal" href="#decimal.MIN_EMIN" title="decimal.MIN_EMIN"><code class="xref py py-const docutils literal notranslate"><span class="pre">MIN_EMIN</span></code></a>, <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>] 范围内，<em>Emax</em> 在 [<code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>, <a class="reference internal" href="#decimal.MAX_EMAX" title="decimal.MAX_EMAX"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_EMAX</span></code></a>] 范围内。</p>
<p><em>capitals</em> 字段为 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> 或 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> (默认值)。 如果设为 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>，指数将附带打印大写的 <code class="xref py py-const docutils literal notranslate"><span class="pre">E</span></code>；其他情况则将使用小写的 <code class="xref py py-const docutils literal notranslate"><span class="pre">e</span></code>: <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('6.02e+23')</span></code>。</p>
<p><em>clamp</em> 字段为 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> (默认值) 或 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>。 如果设为 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>，则 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例的指数 <code class="docutils literal notranslate"><span class="pre">e</span></code> 的表示范围在此上下文中将严格限制为 <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>。 如果 <em>clamp</em> 为 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> 则将适用较弱的条件: <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例调整后的指数最大值为 <code class="docutils literal notranslate"><span class="pre">Emax</span></code>。 当 <em>clamp</em> 为 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> 时，一个较大的普通数值将在可能的情况下减小其指数并为其系统添加相应数量的零，以便符合指数值限制；这可以保持数字值但会丢失有效末尾零的信息。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.23e999&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.23000E+999&#39;)</span>
</pre></div>
</div>
<p><em>clamp</em> 值为 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> 时即允许与在 IEEE 754 中描述的固定宽度十进制交换格式保持兼容性。</p>
<p><a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 类定义了几种通用方法以及大量直接在给定上下文中进行算术运算的方法。 此外，对于上述的每种 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 方法（不包括 <code class="xref py py-meth docutils literal notranslate"><span class="pre">adjusted()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_tuple()</span></code> 方法）都有一个相应的 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 方法。 例如，对于一个 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 的实例 <code class="docutils literal notranslate"><span class="pre">C</span></code> 和 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 的实例 <code class="docutils literal notranslate"><span class="pre">x</span></code>，<code class="docutils literal notranslate"><span class="pre">C.exp(x)</span></code> 就等价于 <code class="docutils literal notranslate"><span class="pre">x.exp(context=C)</span></code>。 每个 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 方法都接受一个 Python 整数（即 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的实例）在任何接受 Decimal 的实例的地方使用。</p>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.clear_flags">
<span class="sig-name descname"><span class="pre">clear_flags</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_flags" title="永久链接至目标">¶</a></dt>
<dd><p>将所有旗标重置为 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.clear_traps">
<span class="sig-name descname"><span class="pre">clear_traps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_traps" title="永久链接至目标">¶</a></dt>
<dd><p>将所有陷阱重置为零 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy" title="永久链接至目标">¶</a></dt>
<dd><p>返回上下文的一个副本。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_decimal">
<span class="sig-name descname"><span class="pre">copy_decimal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_decimal" title="永久链接至目标">¶</a></dt>
<dd><p>返回 Decimal 实例 num 的一个副本。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.create_decimal">
<span class="sig-name descname"><span class="pre">create_decimal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal" title="永久链接至目标">¶</a></dt>
<dd><p>基于 <em>num</em> 创建一个新 Decimal 实例但使用 <em>self</em> 作为上下文。 与 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 构造器不同，该上下文的精度、舍入方法、旗标和陷阱会被应用于转换过程。</p>
<p>此方法很有用处，因为常量往往被给予高于应用所需的精度。 另一个好处在于立即执行舍入可以消除超出当前精度的数位所导致的意外效果。 在下面的示例中，使用未舍入的输入意味着在总和中添加零会改变结果：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.45&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.44&#39;)</span>
</pre></div>
</div>
<p>此方法实现了 IBM 规格描述中的转换为数字操作。 如果参数为字符串，则不允许有开头或末尾的空格或下划线。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.create_decimal_from_float">
<span class="sig-name descname"><span class="pre">create_decimal_from_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal_from_float" title="永久链接至目标">¶</a></dt>
<dd><p>基于浮点数 <em>f</em> 创建一个新的 Decimal 实例，但会使用 <em>self</em> 作为上下文来执行舍入。 与 <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Decimal.from_float()</span></code></a> 类方法不同，上下文的精度、舍入方法、旗标和陷阱会应用到转换中。</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">decimal.Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.Etiny">
<span class="sig-name descname"><span class="pre">Etiny</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etiny" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个等于 <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> 的值即次标准化结果中的最小指数值。 当发生向下溢出时，指数会设为 <a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-const docutils literal notranslate"><span class="pre">Etiny</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.Etop">
<span class="sig-name descname"><span class="pre">Etop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etop" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个等于 <code class="docutils literal notranslate"><span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> 的值。</p>
</dd></dl>

<p>使用 decimal 的通常方式是创建 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例然后对其应用算术运算,这些运算发生在活动线程的当前上下文中。 一种替代方式则是使用上下文的方法在特定上下文中进行计算。 这些方法类似于 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 类的方法，在此仅简单地重新列出。</p>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.abs">
<span class="sig-name descname"><span class="pre">abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.abs" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 的绝对值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.add" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 与 <em>y</em> 的和。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.canonical">
<span class="sig-name descname"><span class="pre">canonical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.canonical" title="永久链接至目标">¶</a></dt>
<dd><p>返回相同的 Decimal 对象 <em>x</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare">
<span class="sig-name descname"><span class="pre">compare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare" title="永久链接至目标">¶</a></dt>
<dd><p>对 <em>x</em> 与 <em>y</em> 进行数值比较。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare_signal">
<span class="sig-name descname"><span class="pre">compare_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_signal" title="永久链接至目标">¶</a></dt>
<dd><p>对两个操作数进行数值比较。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare_total">
<span class="sig-name descname"><span class="pre">compare_total</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total" title="永久链接至目标">¶</a></dt>
<dd><p>对两个操作数使用其抽象表示进行比较。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare_total_mag">
<span class="sig-name descname"><span class="pre">compare_total_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total_mag" title="永久链接至目标">¶</a></dt>
<dd><p>对两个操作数使用其抽象表示进行比较，忽略符号。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_abs">
<span class="sig-name descname"><span class="pre">copy_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_abs" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 的副本，符号设为 0。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_negate">
<span class="sig-name descname"><span class="pre">copy_negate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_negate" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 的副本，符号取反。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_sign">
<span class="sig-name descname"><span class="pre">copy_sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_sign" title="永久链接至目标">¶</a></dt>
<dd><p>从 <em>y</em> 拷贝符号至 <em>x</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.divide">
<span class="sig-name descname"><span class="pre">divide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 除以 <em>y</em> 的结果。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.divide_int">
<span class="sig-name descname"><span class="pre">divide_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide_int" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 除以 <em>y</em> 的结果，截短为整数。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.divmod">
<span class="sig-name descname"><span class="pre">divmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divmod" title="永久链接至目标">¶</a></dt>
<dd><p>两个数字相除并返回结果的整数部分。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.exp" title="永久链接至目标">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">**</span> <span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.fma">
<span class="sig-name descname"><span class="pre">fma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.fma" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 乘以 <em>y</em> 再加 <em>z</em> 的结果。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_canonical">
<span class="sig-name descname"><span class="pre">is_canonical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_canonical" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>x</em> 是规范的则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_finite">
<span class="sig-name descname"><span class="pre">is_finite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_finite" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>x</em> 为有限的则返回``True``；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_infinite">
<span class="sig-name descname"><span class="pre">is_infinite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_infinite" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>x</em> 是无限的则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_nan">
<span class="sig-name descname"><span class="pre">is_nan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_nan" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>x</em> 是 qNaN 或 sNaN 则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_normal">
<span class="sig-name descname"><span class="pre">is_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_normal" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>x</em> 是标准数则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_qnan">
<span class="sig-name descname"><span class="pre">is_qnan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_qnan" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>x</em> 是静默 NaN 则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_signed">
<span class="sig-name descname"><span class="pre">is_signed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_signed" title="永久链接至目标">¶</a></dt>
<dd><p><em>x</em> 是负数则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_snan">
<span class="sig-name descname"><span class="pre">is_snan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_snan" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>x</em> 是显式 NaN 则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_subnormal">
<span class="sig-name descname"><span class="pre">is_subnormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_subnormal" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>x</em> 是次标准数则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_zero">
<span class="sig-name descname"><span class="pre">is_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_zero" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>x</em> 为零则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.ln">
<span class="sig-name descname"><span class="pre">ln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.ln" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 的自然对数（以 e 为底）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.log10">
<span class="sig-name descname"><span class="pre">log10</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.log10" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 的以 10 为底的对数。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logb">
<span class="sig-name descname"><span class="pre">logb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logb" title="永久链接至目标">¶</a></dt>
<dd><p>返回操作数的 MSD 等级的指数。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_and">
<span class="sig-name descname"><span class="pre">logical_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_and" title="永久链接至目标">¶</a></dt>
<dd><p>在操作数的每个数位间应用逻辑运算 <em>and</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_invert">
<span class="sig-name descname"><span class="pre">logical_invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_invert" title="永久链接至目标">¶</a></dt>
<dd><p>反转 <em>x</em> 中的所有数位。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_or">
<span class="sig-name descname"><span class="pre">logical_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_or" title="永久链接至目标">¶</a></dt>
<dd><p>在操作数的每个数位间应用逻辑运算 <em>or</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_xor">
<span class="sig-name descname"><span class="pre">logical_xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_xor" title="永久链接至目标">¶</a></dt>
<dd><p>在操作数的每个数位间应用逻辑运算 <em>xor</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max" title="永久链接至目标">¶</a></dt>
<dd><p>对两个值执行数字比较并返回其中的最大值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.max_mag">
<span class="sig-name descname"><span class="pre">max_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max_mag" title="永久链接至目标">¶</a></dt>
<dd><p>对两个值执行忽略正负号的数字比较。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min" title="永久链接至目标">¶</a></dt>
<dd><p>对两个值执行数字比较并返回其中的最小值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.min_mag">
<span class="sig-name descname"><span class="pre">min_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min_mag" title="永久链接至目标">¶</a></dt>
<dd><p>对两个值执行忽略正负号的数字比较。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.minus">
<span class="sig-name descname"><span class="pre">minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.minus" title="永久链接至目标">¶</a></dt>
<dd><p>对应于 Python 中的单目前缀取负运算符执行取负操作。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.multiply">
<span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.multiply" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 和 <em>y</em> 的积。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.next_minus">
<span class="sig-name descname"><span class="pre">next_minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_minus" title="永久链接至目标">¶</a></dt>
<dd><p>返回小于 <em>x</em> 的最大数字表示形式。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.next_plus">
<span class="sig-name descname"><span class="pre">next_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_plus" title="永久链接至目标">¶</a></dt>
<dd><p>返回大于 <em>x</em> 的最小数字表示形式。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.next_toward">
<span class="sig-name descname"><span class="pre">next_toward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_toward" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 趋向于 <em>y</em> 的最接近的数字。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.normalize" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>x</em> 改写为最简形式。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.number_class">
<span class="sig-name descname"><span class="pre">number_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.number_class" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 的类的表示。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.plus">
<span class="sig-name descname"><span class="pre">plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.plus" title="永久链接至目标">¶</a></dt>
<dd><p>对应于 Python 中的单目前缀取正运算符执行取正操作。 此操作将应用上下文精度和舍入，因此它 <em>不是</em> 标识运算。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.power">
<span class="sig-name descname"><span class="pre">power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.power" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的 <code class="docutils literal notranslate"><span class="pre">y</span></code> 次方，如果给出了模数 <code class="docutils literal notranslate"><span class="pre">modulo</span></code> 则取其余数。</p>
<p>With two arguments, compute <code class="docutils literal notranslate"><span class="pre">x**y</span></code>.  If <code class="docutils literal notranslate"><span class="pre">x</span></code> is negative then <code class="docutils literal notranslate"><span class="pre">y</span></code>
must be integral.  The result will be inexact unless <code class="docutils literal notranslate"><span class="pre">y</span></code> is integral and
the result is finite and can be expressed exactly in 'precision' digits.
The rounding mode of the context is used. Results are always correctly rounded
in the Python version.</p>
<p><code class="docutils literal notranslate"><span class="pre">Decimal(0)</span> <span class="pre">**</span> <span class="pre">Decimal(0)</span></code> 结果为 <code class="docutils literal notranslate"><span class="pre">InvalidOperation</span></code>，而如果 <code class="docutils literal notranslate"><span class="pre">InvalidOperation</span></code> 未被捕获，则结果为 <code class="docutils literal notranslate"><span class="pre">Decimal('NaN')</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>The C module computes <a class="reference internal" href="#decimal.Context.power" title="decimal.Context.power"><code class="xref py py-meth docutils literal notranslate"><span class="pre">power()</span></code></a> in terms of the correctly rounded
<a class="reference internal" href="#decimal.Context.exp" title="decimal.Context.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a> and <a class="reference internal" href="#decimal.Context.ln" title="decimal.Context.ln"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ln()</span></code></a> functions. The result is well-defined but
only &quot;almost always correctly rounded&quot;.</p>
</div>
<p>带有三个参数时，计算 <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code>。 对于三个参数的形式，参数将会应用以下限制：</p>
<blockquote>
<div><ul class="simple">
<li><p>三个参数必须都是整数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> 必须是非负数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> 或 <code class="docutils literal notranslate"><span class="pre">y</span></code> 至少有一个不为零</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">modulo</span></code> 必须不为零且至多有 'precision' 位</p></li>
</ul>
</div></blockquote>
<p>来自 <code class="docutils literal notranslate"><span class="pre">Context.power(x,</span> <span class="pre">y,</span> <span class="pre">modulo)</span></code> 的结果值等于使用无限精度计算 <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> 所得到的值，但其计算过程更高效。 结果的指数为零，无论 <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> 和 <code class="docutils literal notranslate"><span class="pre">modulo</span></code> 的指数是多少。 结果值总是完全精确的。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.quantize">
<span class="sig-name descname"><span class="pre">quantize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.quantize" title="永久链接至目标">¶</a></dt>
<dd><p>返回的值等于 <em>x</em> (舍入后)，并且指数为 <em>y</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.radix">
<span class="sig-name descname"><span class="pre">radix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.radix" title="永久链接至目标">¶</a></dt>
<dd><p>恰好返回 10，因为这是 Decimal 对象 :)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.remainder">
<span class="sig-name descname"><span class="pre">remainder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder" title="永久链接至目标">¶</a></dt>
<dd><p>返回整除所得到的余数。</p>
<p>结果的符号，如果不为零，则与原始除数的符号相同。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.remainder_near">
<span class="sig-name descname"><span class="pre">remainder_near</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder_near" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">n</span></code>，其中 <em>n</em> 为最接近 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> 实际值的整数（如结果为 0 则其符号将与 <em>x</em> 的符号相同）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.rotate" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 翻转 <em>y</em> 次的副本。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.same_quantum">
<span class="sig-name descname"><span class="pre">same_quantum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.same_quantum" title="永久链接至目标">¶</a></dt>
<dd><p>如果两个操作数具有相同的指数则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.scaleb">
<span class="sig-name descname"><span class="pre">scaleb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.scaleb" title="永久链接至目标">¶</a></dt>
<dd><p>返回第一个操作数添加第二个值的指数后的结果。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.shift">
<span class="sig-name descname"><span class="pre">shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.shift" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 变换 <em>y</em> 次的副本。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.sqrt">
<span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.sqrt" title="永久链接至目标">¶</a></dt>
<dd><p>非负数基于上下文精度的平方根。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.subtract">
<span class="sig-name descname"><span class="pre">subtract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.subtract" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 和 <em>y</em> 的差。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.to_eng_string">
<span class="sig-name descname"><span class="pre">to_eng_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_eng_string" title="永久链接至目标">¶</a></dt>
<dd><p>转换为字符串，如果需要指数则会使用工程标注法。</p>
<p>工程标注法的指数是 3 的倍数。 这会在十进制位的左边保留至多 3 个数码，并可能要求添加一至两个末尾零。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.to_integral_exact">
<span class="sig-name descname"><span class="pre">to_integral_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_integral_exact" title="永久链接至目标">¶</a></dt>
<dd><p>舍入到一个整数。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.to_sci_string">
<span class="sig-name descname"><span class="pre">to_sci_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_sci_string" title="永久链接至目标">¶</a></dt>
<dd><p>使用科学计数法将一个数字转换为字符串。</p>
</dd></dl>

</dd></dl>

</section>
<section id="constants">
<span id="decimal-rounding-modes"></span><h2>常量<a class="headerlink" href="#constants" title="永久链接至标题">¶</a></h2>
<p>本节中的常量仅与 C 模块相关。 它们也被包含在纯 Python 版本以保持兼容性。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 29%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>32位</p></th>
<th class="head"><p>64位</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MAX_PREC">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MAX_PREC</span></span><a class="headerlink" href="#decimal.MAX_PREC" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">425000000</span></code></p></td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">999999999999999999</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MAX_EMAX">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MAX_EMAX</span></span><a class="headerlink" href="#decimal.MAX_EMAX" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">425000000</span></code></p></td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">999999999999999999</span></code></p></td>
</tr>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MIN_EMIN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MIN_EMIN</span></span><a class="headerlink" href="#decimal.MIN_EMIN" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">-425000000</span></code></p></td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">-999999999999999999</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MIN_ETINY">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MIN_ETINY</span></span><a class="headerlink" href="#decimal.MIN_ETINY" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">-849999999</span></code></p></td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">-1999999999999999997</span></code></p></td>
</tr>
</tbody>
</table>
<dl class="py data">
<dt class="sig sig-object py" id="decimal.HAVE_THREADS">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">HAVE_THREADS</span></span><a class="headerlink" href="#decimal.HAVE_THREADS" title="永久链接至目标">¶</a></dt>
<dd><p>该值为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 已弃用，因为 Python 现在总是启用线程。</p>
</dd></dl>

<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除.</span></p>
</div>
<dl class="py data">
<dt class="sig sig-object py" id="decimal.HAVE_CONTEXTVAR">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">HAVE_CONTEXTVAR</span></span><a class="headerlink" href="#decimal.HAVE_CONTEXTVAR" title="永久链接至目标">¶</a></dt>
<dd><p>默认值为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 如果 Python 编译版本 <a class="reference internal" href="../using/configure.html#cmdoption-without-decimal-contextvar"><code class="xref std std-option docutils literal notranslate"><span class="pre">使用了</span> <span class="pre">--without-decimal-contextvar</span> <span class="pre">选项来配置</span></code></a>，则 C 版本会使用线程局部而非协程局部上下文并且该值为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 这在某些嵌套上下文场景中将会稍快一些。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">3.9 新版功能: </span>向下移植到 3.7 和 3.8。</p>
</div>
</section>
<section id="rounding-modes">
<h2>舍入模式<a class="headerlink" href="#rounding-modes" title="永久链接至标题">¶</a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_CEILING">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_CEILING</span></span><a class="headerlink" href="#decimal.ROUND_CEILING" title="永久链接至目标">¶</a></dt>
<dd><p>舍入方向为 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code>。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_DOWN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_DOWN</span></span><a class="headerlink" href="#decimal.ROUND_DOWN" title="永久链接至目标">¶</a></dt>
<dd><p>舍入方向为零。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_FLOOR">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_FLOOR</span></span><a class="headerlink" href="#decimal.ROUND_FLOOR" title="永久链接至目标">¶</a></dt>
<dd><p>舍入方向为 <code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code>。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_HALF_DOWN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_HALF_DOWN</span></span><a class="headerlink" href="#decimal.ROUND_HALF_DOWN" title="永久链接至目标">¶</a></dt>
<dd><p>舍入到最接近的数，同样接近则舍入方向为零。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_HALF_EVEN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_HALF_EVEN</span></span><a class="headerlink" href="#decimal.ROUND_HALF_EVEN" title="永久链接至目标">¶</a></dt>
<dd><p>舍入到最接近的数，同样接近则舍入到最接近的偶数。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_HALF_UP">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_HALF_UP</span></span><a class="headerlink" href="#decimal.ROUND_HALF_UP" title="永久链接至目标">¶</a></dt>
<dd><p>舍入到最接近的数，同样接近则舍入到零的反方向。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_UP">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_UP</span></span><a class="headerlink" href="#decimal.ROUND_UP" title="永久链接至目标">¶</a></dt>
<dd><p>舍入到零的反方向。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_05UP">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_05UP</span></span><a class="headerlink" href="#decimal.ROUND_05UP" title="永久链接至目标">¶</a></dt>
<dd><p>如果最后一位朝零的方向舍入后为 0 或 5 则舍入到零的反方向；否则舍入方向为零。</p>
</dd></dl>

</section>
<section id="signals">
<span id="decimal-signals"></span><h2>信号<a class="headerlink" href="#signals" title="永久链接至标题">¶</a></h2>
<p>信号代表在计算期间引发的条件。 每个信号对应于一个上下文旗标和一个上下文陷阱启用器。</p>
<p>上下文旗标将在遇到特定条件时被设定。 在完成计算之后，将为了获得信息而检测旗标（例如确定计算是否精确）。 在检测旗标后，请确保在开始下一次计算之前清除所有旗标。</p>
<p>如果为信号设定了上下文的陷阱启用器，则条件会导致特定的 Python 异常被引发。 举例来说，如果设定了 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 陷阱，则当遇到此条件时就将引发 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 异常。</p>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.Clamped">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Clamped</span></span><a class="headerlink" href="#decimal.Clamped" title="永久链接至目标">¶</a></dt>
<dd><p>修改一个指数以符合表示限制。</p>
<p>通常，限位将在一个指数超出上下文的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> 限制时发生。 在可能的情况下，会通过给系数添加零来将指数缩减至符合限制。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.DecimalException">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">DecimalException</span></span><a class="headerlink" href="#decimal.DecimalException" title="永久链接至目标">¶</a></dt>
<dd><p>其他信号的基类，并且也是 <a class="reference internal" href="exceptions.html#ArithmeticError" title="ArithmeticError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.DivisionByZero">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">DivisionByZero</span></span><a class="headerlink" href="#decimal.DivisionByZero" title="永久链接至目标">¶</a></dt>
<dd><p>非无限数被零除的信号。</p>
<p>可在除法、取余队法或对一个数求负数次幂时发生。 如果此信号未被陷阱捕获，则返回 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> 或 <code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code> 并且由对计算的输入来确定正负符号。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Inexact">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Inexact</span></span><a class="headerlink" href="#decimal.Inexact" title="永久链接至目标">¶</a></dt>
<dd><p>表明发生了舍入且结果是不精确的。</p>
<p>有非零数位在舍入期间被丢弃的信号。 舍入结果将被返回。 此信号旗标或陷阱被用于检测结果不精确的情况。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.InvalidOperation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">InvalidOperation</span></span><a class="headerlink" href="#decimal.InvalidOperation" title="永久链接至目标">¶</a></dt>
<dd><p>执行了一个无效的操作。</p>
<p>表明请求了一个无意义的操作。 如未被陷阱捕获则返回 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>。 可能的原因包括:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Infinity</span> <span class="o">-</span> <span class="n">Infinity</span>
<span class="mi">0</span> <span class="o">*</span> <span class="n">Infinity</span>
<span class="n">Infinity</span> <span class="o">/</span> <span class="n">Infinity</span>
<span class="n">x</span> <span class="o">%</span> <span class="mi">0</span>
<span class="n">Infinity</span> <span class="o">%</span> <span class="n">x</span>
<span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="o">**</span> <span class="mi">0</span>
<span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">integer</span><span class="p">)</span>
<span class="n">x</span> <span class="o">**</span> <span class="n">Infinity</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Overflow">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Overflow</span></span><a class="headerlink" href="#decimal.Overflow" title="永久链接至目标">¶</a></dt>
<dd><p>数值的溢出。</p>
<p>表明在发生舍入之后的指数大于 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code>。 如果未被陷阱捕获，则结果将取决于舍入模式，或者向下舍入为最大的可表示有限数，或者向上舍入为 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code>。 无论哪种情况，都将引发 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inexact</span></code></a> 和 <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rounded</span></code></a> 信号。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Rounded">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Rounded</span></span><a class="headerlink" href="#decimal.Rounded" title="永久链接至目标">¶</a></dt>
<dd><p>发生了舍入，但或许并没有信息丢失。</p>
<p>一旦舍入丢弃了数位就会发出此信号；即使被丢弃的数位是零 (例如将 <code class="xref py py-const docutils literal notranslate"><span class="pre">5.00</span></code> 舍入为 <code class="xref py py-const docutils literal notranslate"><span class="pre">5.0</span></code>)。 如果未被陷阱捕获，则不经修改地返回结果。 此信号用于检测有效位数的丢弃。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Subnormal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Subnormal</span></span><a class="headerlink" href="#decimal.Subnormal" title="永久链接至目标">¶</a></dt>
<dd><p>在舍入之前指数低于 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code>。</p>
<p>当操作结果是次标准数（即指数过小）时就会发出此信号。 如果未被陷阱捕获，则不经修改过返回结果。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Underflow">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Underflow</span></span><a class="headerlink" href="#decimal.Underflow" title="永久链接至目标">¶</a></dt>
<dd><p>数字向下溢出导致结果舍入到零。</p>
<p>当一个次标准数结果通过舍入转为零时就会发出此信号。 同时还将引发 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inexact</span></code></a> 和 <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subnormal</span></code></a> 信号。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.FloatOperation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">FloatOperation</span></span><a class="headerlink" href="#decimal.FloatOperation" title="永久链接至目标">¶</a></dt>
<dd><p>为 float 和 Decimal 的混合启用更严格的语义。</p>
<p>如果信号未被捕获（默认），则在 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 构造器、<a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal()</span></code></a> 和所有比较运算中允许 float 和 Decimal 的混合。 转换和比较都是完全精确的。 发生的任何混合运算都将通过在上下文旗标中设置 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 来静默地记录。 通过 <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_float()</span></code></a> 或 <a class="reference internal" href="#decimal.Context.create_decimal_from_float" title="decimal.Context.create_decimal_from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal_from_float()</span></code></a> 进行显式转换则不会设置旗标。</p>
<p>在其他情况下（即信号被捕获），则只静默执行相等性比较和显式转换。 所有其他混合运算都将引发 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a>。</p>
</dd></dl>

<p>以下表格总结了信号的层级结构:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exceptions</span><span class="o">.</span><span class="n">ArithmeticError</span><span class="p">(</span><span class="n">exceptions</span><span class="o">.</span><span class="n">Exception</span><span class="p">)</span>
    <span class="n">DecimalException</span>
        <span class="n">Clamped</span>
        <span class="n">DivisionByZero</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ZeroDivisionError</span><span class="p">)</span>
        <span class="n">Inexact</span>
            <span class="n">Overflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">)</span>
            <span class="n">Underflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">,</span> <span class="n">Subnormal</span><span class="p">)</span>
        <span class="n">InvalidOperation</span>
        <span class="n">Rounded</span>
        <span class="n">Subnormal</span>
        <span class="n">FloatOperation</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TypeError</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="floating-point-notes">
<span id="decimal-notes"></span><h2>浮点数说明<a class="headerlink" href="#floating-point-notes" title="永久链接至标题">¶</a></h2>
<section id="mitigating-round-off-error-with-increased-precision">
<h3>通过提升精度来解决舍入错误<a class="headerlink" href="#mitigating-round-off-error-with-increased-precision" title="永久链接至标题">¶</a></h3>
<p>使用十进制浮点数可以消除十进制表示错误（即能够完全精确地表示 <code class="xref py py-const docutils literal notranslate"><span class="pre">0.1</span></code> 这样的数）；然而，某些运算在非零数位超出给定的精度时仍然可能导致舍入错误。</p>
<p>舍入错误的影响可能因接近相互抵销的加减运算被放大从而导致丢失有效位。 Knuth 提供了两个指导性示例，其中出现了精度不足的浮点算术舍入，导致加法的交换律和分配律被打破：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="go"># Examples from Seminumerical Algorithms, Section 4.2.2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">8</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.5111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.01&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 模块则可以通过充分地扩展精度来避免有效位的丢失：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
</section>
<section id="special-values">
<h3>特殊的值<a class="headerlink" href="#special-values" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 模块的数字系统提供了一些特殊的值，包括 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">sNaN</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> 以及两种零值 <code class="xref py py-const docutils literal notranslate"><span class="pre">+0</span></code> 和 <code class="xref py py-const docutils literal notranslate"><span class="pre">-0</span></code>。</p>
<p>无穷大可以使用 <code class="docutils literal notranslate"><span class="pre">Decimal('Infinity')</span></code> 来构建。 它们也可以在不捕获 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 信号捕获时通过除以零来产生。 类似地，当不捕获 <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Overflow</span></code></a> 信号时，也可以通过舍入到超出最大可表示数字限制的方式产生无穷大的结果。</p>
<p>无穷大是有符号的（仿射）并可用于算术运算，它们会被当作极其巨大的不确定数字来处理。 例如，无穷大加一个常量结果也将为无穷大。</p>
<p>某些不存在有效结果的运算将会返回 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>，或者如果捕获了 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 信号则会引发一个异常。 例如，<code class="docutils literal notranslate"><span class="pre">0/0</span></code> 会返回 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 表示结果“不是一个数字”。 这样的 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 是静默产生的，并且在产生之后参与其它计算时总是会得到 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 的结果。 这种行为对于偶而缺少输入的各类计算都很有用处 --- 它允许在将特定结果标记为无效的同时让计算继续运行。</p>
<p>另一种变体形式是 <code class="xref py py-const docutils literal notranslate"><span class="pre">sNaN</span></code>，它在每次运算后会发出信号而不是保持静默。 当对于无效结果需要中断计算进行特别处理时，这是一个很有用的返回值。</p>
<p>Python 中比较运算符的行为在涉及 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 时可能会令人有点惊讶。 相等性检测在操作数中有静默型或信号型 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 时总是会返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> (即使是执行 <code class="docutils literal notranslate"><span class="pre">Decimal('NaN')==Decimal('NaN')</span></code>)，而不等性检测总是会返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>。 当尝试使用 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 运算符中的任何一个来比较两个 Decimal 值时，如果运算数中有 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 则将引发 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 信号，如果此信号未被捕获则将返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。 请注意通用十进制算术规范并未规定直接比较行为；这些涉及 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 的比较规则来自于 IEEE 854 标准 (见第 5.7 节表 3)。 要确保严格符合标准，请改用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">compare-signal()</span></code> 方法。</p>
<p>有符号零值可以由向下溢出的运算产生。 它们保留符号是为了让运算结果能以更高的精度传递。 由于它们的大小为零，正零和负零会被视为相等，且它们的符号具有信息。</p>
<p>在这两个不相同但却相等的有符号零之外，还存在几种零的不同表示形式，它们的精度不同但值也都相等。 这需要一些时间来逐渐适应。 对于习惯了标准浮点表示形式的眼睛来说，以下运算返回等于零的值并不是显而易见的：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;0E-1000026&#39;)</span>
</pre></div>
</div>
</section>
</section>
<section id="working-with-threads">
<span id="decimal-threads"></span><h2>使用线程<a class="headerlink" href="#working-with-threads" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 函数会为每个线程访问不同的 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 对象。 具有单独线程上下文意味着线程可以修改上下文 (例如 <code class="docutils literal notranslate"><span class="pre">getcontext().prec=10</span></code>) 而不影响其他线程。</p>
<p>类似的 <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 会为当前上下文的目标自动赋值。</p>
<p>如果在调用 <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 之前调用了 <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a>，则 <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 将自动创建一个新的上下文在当前线程中使用。</p>
<p>新的上下文拷贝自一个名为 <em>DefaultContext</em> 的原型上下文。 要控制默认值以便每个线程在应用运行期间都使用相同的值，可以直接修改 <em>DefaultContext</em> 对象。 这应当在任何线程启动 <em>之前</em> 完成以使得调用 <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 的线程之间不会产生竞争条件。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set applicationwide defaults for all threads about to be launched</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_DOWN</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span> <span class="o">=</span> <span class="n">ExtendedContext</span><span class="o">.</span><span class="n">traps</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">InvalidOperation</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">setcontext</span><span class="p">(</span><span class="n">DefaultContext</span><span class="p">)</span>

<span class="c1"># Afterwards, the threads can be started</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t3</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
 <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</div>
</section>
<section id="recipes">
<span id="decimal-recipes"></span><h2>例程<a class="headerlink" href="#recipes" title="永久链接至标题">¶</a></h2>
<p>以下是一些用作工具函数的例程，它们演示了使用 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 类的各种方式:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">moneyfmt</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">curr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
             <span class="n">pos</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">trailneg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Decimal to a money formatted string.</span>

<span class="sd">    places:  required number of places after the decimal point</span>
<span class="sd">    curr:    optional currency symbol before the sign (may be blank)</span>
<span class="sd">    sep:     optional grouping separator (comma, period, space, or blank)</span>
<span class="sd">    dp:      decimal point indicator (comma or period)</span>
<span class="sd">             only specify as blank when places is zero</span>
<span class="sd">    pos:     optional sign for positive numbers: &#39;+&#39;, space or blank</span>
<span class="sd">    neg:     optional sign for negative numbers: &#39;-&#39;, &#39;(&#39;, space or blank</span>
<span class="sd">    trailneg:optional trailing minus indicator:  &#39;-&#39;, &#39;)&#39;, space or blank</span>

<span class="sd">    &gt;&gt;&gt; d = Decimal(&#39;-1234567.8901&#39;)</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;)</span>
<span class="sd">    &#39;-$1,234,567.89&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, places=0, sep=&#39;.&#39;, dp=&#39;&#39;, neg=&#39;&#39;, trailneg=&#39;-&#39;)</span>
<span class="sd">    &#39;1.234.568-&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;, neg=&#39;(&#39;, trailneg=&#39;)&#39;)</span>
<span class="sd">    &#39;($1,234,567.89)&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(123456789), sep=&#39; &#39;)</span>
<span class="sd">    &#39;123 456 789.00&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(&#39;-0.02&#39;), neg=&#39;&lt;&#39;, trailneg=&#39;&gt;&#39;)</span>
<span class="sd">    &#39;&lt;0.02&gt;&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="n">places</span>      <span class="c1"># 2 places --&gt; &#39;0.01&#39;</span>
    <span class="n">sign</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">digits</span><span class="p">))</span>
    <span class="n">build</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">pop</span>
    <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">trailneg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">places</span><span class="p">):</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">()</span> <span class="k">if</span> <span class="n">digits</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">places</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">digits</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">build</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">neg</span> <span class="k">if</span> <span class="n">sign</span> <span class="k">else</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pi</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute Pi to the current precision.</span>

<span class="sd">    &gt;&gt;&gt; print(pi())</span>
<span class="sd">    3.141592653589793238462643383</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># extra digits for intermediate steps</span>
    <span class="n">three</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>      <span class="c1"># substitute &quot;three=3.0&quot; for regular floats</span>
    <span class="n">lasts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">24</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="o">+</span><span class="mi">8</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="n">da</span><span class="p">,</span> <span class="n">da</span><span class="o">+</span><span class="mi">32</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>               <span class="c1"># unary plus applies the new precision</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return e raised to the power of x.  Result type matches input type.</span>

<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(1)))</span>
<span class="sd">    2.718281828459045235360287471</span>
<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(2)))</span>
<span class="sd">    7.389056098930650227230427461</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2.0))</span>
<span class="sd">    7.38905609893</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2+0j))</span>
<span class="sd">    (7.38905609893+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the cosine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(cos(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.8775825618903727161162815826</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5))</span>
<span class="sd">    0.87758256189</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5+0j))</span>
<span class="sd">    (0.87758256189+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the sine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(sin(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.4794255386042030002732879352</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5))</span>
<span class="sd">    0.479425538604</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5+0j))</span>
<span class="sd">    (0.479425538604+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>
</pre></div>
</div>
</section>
<section id="decimal-faq">
<span id="id1"></span><h2>Decimal 常见问题<a class="headerlink" href="#decimal-faq" title="永久链接至标题">¶</a></h2>
<p>Q. 总是输入 <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('1234.5')</span></code> 是否过于笨拙。 在使用交互解释器时有没有最小化输入量的方式？</p>
<p>A. 有些用户会将构造器简写为一个字母：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">(</span><span class="s1">&#39;1.23&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">D</span><span class="p">(</span><span class="s1">&#39;3.45&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.68&#39;)</span>
</pre></div>
</div>
<p>Q. 在带有两个十进制位的定点数应用中，有些输入值具有许多位，需要被舍入。 另一些数则不应具有多余位，需要验证有效性。 这种情况应该用什么方法？</p>
<p>A. 用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code> 方法舍入到固定数量的十进制位。 如果设置了 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> 陷阱，它也适用于验证有效性：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TWOPLACES</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>       <span class="c1"># same as Decimal(&#39;0.01&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Round to two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Validate that a number does not exceed two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<p>Q. 当我使用两个有效位的输入时，我要如何在一个应用中保持有效位不变？</p>
<p>A. 某些运算例如与整数相加、相减和相乘将会自动保留固定的小数位数。 其他运算，例如相除和非整数相乘则将会改变小数位数，需要再加上 <code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code> 处理步骤：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;102.72&#39;</span><span class="p">)</span>           <span class="c1"># Initial fixed-point values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.17&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>                           <span class="c1"># Addition preserves fixed-point</span>
<span class="go">Decimal(&#39;105.89&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="go">Decimal(&#39;99.55&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">42</span>                          <span class="c1"># So does integer multiplication</span>
<span class="go">Decimal(&#39;4314.24&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># Must quantize non-integer multiplication</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># And quantize division</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>在开发定点数应用时，更方便的做法是定义处理 <code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code> 步骤的函数：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>                       <span class="c1"># Automatically preserve fixed-point</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">div</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>Q. 表示同一个值有许多方式。 数字 <code class="xref py py-const docutils literal notranslate"><span class="pre">200</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">200.000</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">2E2</span></code> 和 <code class="xref py py-const docutils literal notranslate"><span class="pre">02E+4</span></code> 的值都相同但有精度不同。 是否有办法将它们转换为一个可识别的规范值？</p>
<p>A. <code class="xref py py-meth docutils literal notranslate"><span class="pre">normalize()</span></code> 方法可将所有相同的值映射为统一表示形式：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;200 200.000 2E2 .02E+4&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
<span class="go">[Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;)]</span>
</pre></div>
</div>
<p>Q. 有些十进制值总是被打印为指数表示形式。 是否有办法得到一个非指数表示形式？</p>
<p>A. 对于某些值来说，指数表示形式是表示系数中有效位的唯一办法。 例如，将 <code class="xref py py-const docutils literal notranslate"><span class="pre">5.0E+3</span></code> 表示为 <code class="xref py py-const docutils literal notranslate"><span class="pre">5000</span></code> 可以让值保持恒定，但是无法显示原本的两位有效数字。</p>
<p>如果一个应用不必关心追踪有效位，则可以很容易地移除指数和末尾的零，丢弃有效位但让值保持不变：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">remove_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">to_integral</span><span class="p">()</span> <span class="k">else</span> <span class="n">d</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remove_exponent</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;5E+3&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;5000&#39;)</span>
</pre></div>
</div>
<p>Q. 是否有办法将一个普通浮点数转换为 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>？</p>
<p>A. 是的，任何二进制浮点数都可以精确地表示为 Decimal 值，但完全精确的转换可能需要比平常感觉更高的精度：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.141592653589793115997963468544185161590576171875&#39;)</span>
</pre></div>
</div>
<p>Q. 在一个复杂的计算中，我怎样才能保证不会得到由精度不足和舍入异常所导致的虚假结果。</p>
<p>A. 使用 decimal 模块可以很容易地检测结果。 最好的做法是使用更高的精度和不同的舍入模式重新进行计算。 明显不同的结果表明存在精度不足、舍入模式问题、不符合条件的输入或是结果不稳定的算法。</p>
<p>Q. 我发现上下文精度的应用只针对运算结果而不针对输入。在混合使用不同精度的值时有什么需要注意的吗？</p>
<p>A. 是的。 原则上所有值都会被视为精确值，在这些值上进行的算术运算也是如此。 只有结果会被舍入。 对于输入来说其好处是“所输入即所得”。 而其缺点则是如果你忘记了输入没有被舍入，结果看起来可能会很奇怪：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.21&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.000&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.20&#39;)</span>
</pre></div>
</div>
<p>解决办法是提高精度或使用单目加法运算对输入执行强制舍入：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.23456789&#39;</span><span class="p">)</span>      <span class="c1"># unary plus triggers rounding</span>
<span class="go">Decimal(&#39;1.23&#39;)</span>
</pre></div>
</div>
<p>此外，还可以使用 <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.create_decimal()</span></code></a> 方法在创建输入时执行舍入：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.2345678&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.2345&#39;)</span>
</pre></div>
</div>
<p>Q. CPython 实现对于巨大数字是否足够快速？</p>
<p>A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of
the decimal module integrate the high speed <a class="reference external" href="https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html">libmpdec</a> library for
arbitrary precision correctly rounded decimal floating point arithmetic <a class="footnote-reference brackets" href="#id4" id="id2">1</a>.
<code class="docutils literal notranslate"><span class="pre">libmpdec</span></code> uses <a class="reference external" href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba multiplication</a>
for medium-sized numbers and the <a class="reference external" href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-theoretic_transform">Number Theoretic Transform</a>
for very large numbers.</p>
<p>必须要对任意精度算术适配上下文。 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> 应当总是设为最大值，<code class="xref py py-attr docutils literal notranslate"><span class="pre">clamp</span></code> 应当总是设为 0 (默认值)。 设置 <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> 需要十分谨慎。</p>
<p>进行大数字算术的最便捷方式也是使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> 的最大值 <a class="footnote-reference brackets" href="#id5" id="id3">2</a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="n">MAX_PREC</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">MAX_EMAX</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">MIN_EMIN</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">256</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">/</span> <span class="mi">128</span>
<span class="go">Decimal(&#39;904625697166532776746648320380374280103671755200316906558262375061821325312&#39;)</span>
</pre></div>
</div>
<p>对于不精确的结果，在 64 位平台上 <a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-attr docutils literal notranslate"><span class="pre">MAX_PREC</span></code></a> 的值太大了，可用的内存将会不足:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">MemoryError</span>
</pre></div>
</div>
<p>在具有超量分配的系统上 (即 Linux)，一种更复杂的方式根据可用的 RAM 大小来调整 <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code>。 假设你有 8GB 的 RAM 并期望同时有 10 个操作数，每个最多使用 500MB:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Maximum number of digits for a single operand using 500MB in 8-byte words</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># with 19 digits per word (4-byte and 9 digits for the 32-bit build):</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxdigits</span> <span class="o">=</span> <span class="mi">19</span> <span class="o">*</span> <span class="p">((</span><span class="mi">500</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check that this works:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="n">maxdigits</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">MAX_EMAX</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">MIN_EMIN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fill the available precision with nines:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">logical_invert</span><span class="p">()</span> <span class="o">*</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">524288112</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">  decimal.Inexact</span>: <span class="n">[&lt;class &#39;decimal.Inexact&#39;&gt;]</span>
</pre></div>
</div>
<p>总体而言（特别是在没有超量分配的系统上），如果期望所有计算都是精确的则推荐预估更严格的边界并设置 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Inexact</span></code></a> 陷阱。</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd>
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版更改: </span>此方式现在适用于除了非整数乘方以外的所有精确结果。</p>
</div>
</dd>
</dl>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> --- 十进制定点和浮点运算</a><ul>
<li><a class="reference internal" href="#quick-start-tutorial">快速入门教程</a></li>
<li><a class="reference internal" href="#decimal-objects">Decimal 对象</a><ul>
<li><a class="reference internal" href="#logical-operands">逻辑操作数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-objects">上下文对象</a></li>
<li><a class="reference internal" href="#constants">常量</a></li>
<li><a class="reference internal" href="#rounding-modes">舍入模式</a></li>
<li><a class="reference internal" href="#signals">信号</a></li>
<li><a class="reference internal" href="#floating-point-notes">浮点数说明</a><ul>
<li><a class="reference internal" href="#mitigating-round-off-error-with-increased-precision">通过提升精度来解决舍入错误</a></li>
<li><a class="reference internal" href="#special-values">特殊的值</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-threads">使用线程</a></li>
<li><a class="reference internal" href="#recipes">例程</a></li>
<li><a class="reference internal" href="#decimal-faq">Decimal 常见问题</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="cmath.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code> --- 关于复数的数学函数</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="fractions.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code> --- 分数</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/decimal.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="fractions --- 分数"
             >下一页</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="cmath --- 关于复数的数学函数"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" >数字和数学模块</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> --- 十进制定点和浮点运算</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 11月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0创建。
    </div>

  </body>
</html>