
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>unittest --- 单元测试框架 &#8212; Python 3.11.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="unittest.mock --- 模拟对象库" href="unittest.mock.html" />
    <link rel="prev" title="doctest --- 测试交互性的Python示例" href="doctest.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/unittest.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> --- 单元测试框架</a><ul>
<li><a class="reference internal" href="#basic-example">基本实例</a></li>
<li><a class="reference internal" href="#command-line-interface">命令行接口</a><ul>
<li><a class="reference internal" href="#command-line-options">命令行选项</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">探索性测试</a></li>
<li><a class="reference internal" href="#organizing-test-code">组织你的测试代码</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">复用已有的测试代码</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">跳过测试与预计的失败</a></li>
<li><a class="reference internal" href="#distinguishing-test-iterations-using-subtests">使用子测试区分测试迭代</a></li>
<li><a class="reference internal" href="#classes-and-functions">类与函数</a><ul>
<li><a class="reference internal" href="#test-cases">测试用例</a><ul>
<li><a class="reference internal" href="#deprecated-aliases">已弃用的别名</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grouping-tests">分组测试</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">加载和运行测试</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">load_tests 协议</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">类与模块设定</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">setUpClass 和 tearDownClass</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">setUpModule 和 tearDownModule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">信号处理</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="doctest.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code> --- 测试交互性的Python示例</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="unittest.mock.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> --- 模拟对象库</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/unittest.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock --- 模拟对象库"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="doctest --- 测试交互性的Python示例"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">开发工具</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> --- 单元测试框架</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-unittest">
<span id="unittest-unit-testing-framework"></span><h1><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> --- 单元测试框架<a class="headerlink" href="#module-unittest" title="永久链接至标题">¶</a></h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/unittest/__init__.py">Lib/unittest/__init__.py</a></p>
<hr class="docutils" />
<p>（如果你已经对测试的概念比较熟悉了，你可能想直接跳转到这一部分 <a class="reference internal" href="#assert-methods"><span class="std std-ref">断言方法</span></a>。）</p>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 单元测试框架是受到 JUnit 的启发，与其他语言中的主流单元测试框架有着相似的风格。其支持测试自动化，配置共享和关机代码测试。支持将测试样例聚合到测试集中，并将测试与报告框架独立。</p>
<p>为了实现这些，<a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 通过面向对象的方式支持了一些重要的概念。</p>
<dl class="simple">
<dt>测试脚手架</dt><dd><p><em class="dfn">test fixture</em> 表示为了开展一项或多项测试所需要进行的准备工作，以及所有相关的清理操作。举个例子，这可能包含创建临时或代理的数据库、目录，再或者启动一个服务器进程。</p>
</dd>
<dt>测试用例</dt><dd><p>一个测试用例是一个独立的测试单元。它检查输入特定的数据时的响应。 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 提供一个基类： <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> ，用于新建测试用例。</p>
</dd>
<dt>测试套件</dt><dd><p><em class="dfn">test suite</em> 是一系列的测试用例，或测试套件，或两者皆有。它用于归档需要一起执行的测试。</p>
</dd>
<dt>测试运行器（test runner）</dt><dd><p><em class="dfn">test runner</em> 是一个用于执行和输出测试结果的组件。这个运行器可能使用图形接口、文本接口，或返回一个特定的值表示运行测试的结果。</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> --- 文档测试模块</dt><dd><p>另一个风格完全不同的测试模块。</p>
</dd>
<dt><a class="reference external" href="https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm">简单 Smalltalk 测试：便用模式</a></dt><dd><p>Kent Beck 有关使用 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 所共享的模式的测试框架的原创论文。</p>
</dd>
<dt><a class="reference external" href="https://docs.pytest.org/">pytest</a></dt><dd><p>第三方单元测试框架，提供轻量化的语法来编写测试，例如：<code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">func(10)</span> <span class="pre">==</span> <span class="pre">42</span></code>。</p>
</dd>
<dt><a class="reference external" href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">Python 测试工具分类</a></dt><dd><p>一个 Python 测试工具的详细列表，包含测试框架和模拟对象库。</p>
</dd>
<dt>Python 中的测试 邮件列表</dt><dd><p>一个讨论 Python 中的测试和测试工具的特别兴趣小组。</p>
</dd>
</dl>
<p>The script <code class="file docutils literal notranslate"><span class="pre">Tools/unittestgui/unittestgui.py</span></code> in the Python source distribution is
a GUI tool for test discovery and execution.  This is intended largely for ease of use
for those new to unit testing.  For production environments it is
recommended that tests be driven by a continuous integration system such as
<a class="reference external" href="https://buildbot.net/">Buildbot</a>, <a class="reference external" href="https://jenkins.io/">Jenkins</a>,
<a class="reference external" href="https://github.com/features/actions">GitHub Actions</a>, or
<a class="reference external" href="https://www.appveyor.com/">AppVeyor</a>.</p>
</div>
<section id="basic-example">
<span id="unittest-minimal-example"></span><h2>基本实例<a class="headerlink" href="#basic-example" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 模块提供了一系列创建和运行测试的工具。这一段落演示了这些工具的一小部分，但也足以满足大部分用户的需求。</p>
<p>这是一段简短的代码，来测试三种字符串方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">TestStringMethods</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s1">&#39;FOO&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_isupper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="s1">&#39;FOO&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="s1">&#39;Foo&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;hello world&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">])</span>
        <span class="c1"># check that s.split fails when the separator is not a string</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>继承 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a> 就创建了一个测试样例。上述三个独立的测试是三个类的方法，这些方法的命名都以 <code class="docutils literal notranslate"><span class="pre">test</span></code> 开头。 这个命名约定告诉测试运行者类的哪些方法表示测试。</p>
<p>每个测试的关键是：调用 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 来检查预期的输出； 调用 <a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a> 或 <a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a> 来验证一个条件；调用 <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> 来验证抛出了一个特定的异常。使用这些方法而不是 <a class="reference internal" href="../reference/simple_stmts.html#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> 语句是为了让测试运行者能聚合所有的测试结果并产生结果报告。</p>
<p>通过 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 和 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 方法，可以设置测试开始前与完成后需要执行的指令。 在  <a class="reference internal" href="#organizing-tests"><span class="std std-ref">组织你的测试代码</span></a> 中，对此有更为详细的描述。</p>
<p>最后的代码块中，演示了运行测试的一个简单的方法。 <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> 提供了一个测试脚本的命令行接口。当在命令行运行该测试脚本，上文的脚本生成如以下格式的输出:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.000</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>在调用测试脚本时添加 <code class="docutils literal notranslate"><span class="pre">-v</span></code> 参数使 <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> 显示更为详细的信息，生成如以下形式的输出:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_isupper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="o">.</span><span class="n">test_isupper</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_split</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="o">.</span><span class="n">test_split</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_upper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="o">.</span><span class="n">test_upper</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.001</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>以上例子演示了 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 中最常用的、足够满足许多日常测试需求的特性。文档的剩余部分详述该框架的完整特性。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版更改: </span>The behavior of returning a value from a test method (other than the default
<code class="docutils literal notranslate"><span class="pre">None</span></code> value), is now deprecated.</p>
</div>
</section>
<section id="command-line-interface">
<span id="unittest-command-line-interface"></span><h2>命令行接口<a class="headerlink" href="#command-line-interface" title="永久链接至标题">¶</a></h2>
<p>unittest 模块可以通过命令行运行模块、类和独立测试方法的测试:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module1</span> <span class="n">test_module2</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span><span class="o">.</span><span class="n">test_method</span>
</pre></div>
</div>
<p>你可以传入模块名、类或方法名或他们的任意组合。</p>
<p>同样的，测试模块可以通过文件路径指定:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">tests</span><span class="o">/</span><span class="n">test_something</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>这样就可以使用 shell 的文件名补全指定测试模块。所指定的文件仍需要可以被作为模块导入。路径通过去除 '.py' 、把分隔符转换为 '.' 转换为模块名。若你需要执行不能被作为模块导入的测试文件，你需要直接执行该测试文件。</p>
<p>在运行测试时，你可以通过添加 -v 参数获取更详细（更多的冗余）的信息。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">v</span> <span class="n">test_module</span>
</pre></div>
</div>
<p>当运行时不包含参数，开始 <a class="reference internal" href="#unittest-test-discovery"><span class="std std-ref">探索性测试</span></a></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span>
</pre></div>
</div>
<p>用于获取命令行选项列表：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">h</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>在早期版本中，只支持运行独立的测试方法，而不支持模块和类。</p>
</div>
<section id="command-line-options">
<h3>命令行选项<a class="headerlink" href="#command-line-options" title="永久链接至标题">¶</a></h3>
<p><strong class="program">unittest</strong> supports these command-line options:</p>
<dl class="std cmdoption">
<dt class="sig sig-object std" id="cmdoption-unittest-b">
<span id="cmdoption-unittest-buffer"></span><span class="sig-name descname"><span class="pre">-b</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--buffer</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-b" title="永久链接至目标">¶</a></dt>
<dd><p>在测试运行时，标准输出流与标准错误流会被放入缓冲区。成功的测试的运行时输出会被丢弃；测试不通过时，测试运行中的输出会正常显示，错误会被加入到测试失败信息。</p>
</dd></dl>

<dl class="std cmdoption">
<dt class="sig sig-object std" id="cmdoption-unittest-c">
<span id="cmdoption-unittest-catch"></span><span class="sig-name descname"><span class="pre">-c</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--catch</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-c" title="永久链接至目标">¶</a></dt>
<dd><p>当测试正在运行时， <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> 会等待当前测试完成，并在完成后报告已执行的测试的结果。当再次按下 <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> 时，引发平常的 <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 异常。</p>
<p>See <a class="reference internal" href="#signal-handling">Signal Handling</a> for the functions that provide this functionality.</p>
</dd></dl>

<dl class="std cmdoption">
<dt class="sig sig-object std" id="cmdoption-unittest-f">
<span id="cmdoption-unittest-failfast"></span><span class="sig-name descname"><span class="pre">-f</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--failfast</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-f" title="永久链接至目标">¶</a></dt>
<dd><p>当出现第一个错误或者失败时，停止运行测试。</p>
</dd></dl>

<dl class="std cmdoption">
<dt class="sig sig-object std" id="cmdoption-unittest-k">
<span class="sig-name descname"><span class="pre">-k</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-k" title="永久链接至目标">¶</a></dt>
<dd><p>只运行匹配模式或子字符串的测试方法和类。 此选项可以被多次使用，在此情况下将会包括匹配任何给定模式的所有测试用例。</p>
<p>包含通配符（*）的模式使用 <a class="reference internal" href="fnmatch.html#fnmatch.fnmatchcase" title="fnmatch.fnmatchcase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fnmatch.fnmatchcase()</span></code></a> 对测试名称进行匹配。另外，该匹配是大小写敏感的。</p>
<p>模式对测试加载器导入的测试方法全名进行匹配。</p>
<p>例如，<code class="docutils literal notranslate"><span class="pre">-k</span> <span class="pre">foo</span></code> 可以匹配到 <code class="docutils literal notranslate"><span class="pre">foo_tests.SomeTest.test_something</span></code>  和 <code class="docutils literal notranslate"><span class="pre">bar_tests.SomeTest.test_foo</span></code> ，但是不能匹配到 <code class="docutils literal notranslate"><span class="pre">bar_tests.FooTest.test_something</span></code> 。</p>
</dd></dl>

<dl class="std cmdoption">
<dt class="sig sig-object std" id="cmdoption-unittest-locals">
<span class="sig-name descname"><span class="pre">--locals</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-locals" title="永久链接至目标">¶</a></dt>
<dd><p>在回溯中显示局部变量。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能: </span>添加命令行选项 <code class="docutils literal notranslate"><span class="pre">-b</span></code>, <code class="docutils literal notranslate"><span class="pre">-c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-f</span></code> 。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能: </span>命令行选项 <code class="docutils literal notranslate"><span class="pre">--locals</span></code> 。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能: </span>命令行选项 <code class="docutils literal notranslate"><span class="pre">-k</span></code> 。</p>
</div>
<p>命令行亦可用于探索性测试，以运行一个项目的所有测试或其子集。</p>
</section>
</section>
<section id="test-discovery">
<span id="unittest-test-discovery"></span><h2>探索性测试<a class="headerlink" href="#test-discovery" title="永久链接至标题">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<p>Unittest supports simple test discovery. In order to be compatible with test
discovery, all of the test files must be <a class="reference internal" href="../tutorial/modules.html#tut-modules"><span class="std std-ref">modules</span></a> or
<a class="reference internal" href="../tutorial/modules.html#tut-packages"><span class="std std-ref">packages</span></a> importable from the top-level directory of
the project (this means that their filenames must be valid <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">identifiers</span></a>).</p>
<p>探索性测试在 <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.discover()</span></code></a> 中实现，但也可以通过命令行使用。它在命令行中的基本用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">project_directory</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>方便起见， <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span></code> 与 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span> <span class="pre">discover</span></code> 等价。如果你需要向探索性测试传入参数，必须显式地使用 <code class="docutils literal notranslate"><span class="pre">discover</span></code> 子命令。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">discover</span></code> 有以下选项：</p>
<dl class="std cmdoption">
<dt class="sig sig-object std" id="cmdoption-unittest-discover-v">
<span id="cmdoption-unittest-discover-verbose"></span><span class="sig-name descname"><span class="pre">-v</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--verbose</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-unittest-discover-v" title="永久链接至目标">¶</a></dt>
<dd><p>更详细地输出结果。</p>
</dd></dl>

<dl class="std cmdoption">
<dt class="sig sig-object std" id="cmdoption-unittest-discover-s">
<span id="cmdoption-unittest-discover-start-directory"></span><span class="sig-name descname"><span class="pre">-s</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--start-directory</span></span><span class="sig-prename descclassname"> <span class="pre">directory</span></span><a class="headerlink" href="#cmdoption-unittest-discover-s" title="永久链接至目标">¶</a></dt>
<dd><p>开始进行搜索的目录(默认值为当前目录 <code class="docutils literal notranslate"><span class="pre">.</span></code> )。</p>
</dd></dl>

<dl class="std cmdoption">
<dt class="sig sig-object std" id="cmdoption-unittest-discover-p">
<span id="cmdoption-unittest-discover-pattern"></span><span class="sig-name descname"><span class="pre">-p</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--pattern</span></span><span class="sig-prename descclassname"> <span class="pre">pattern</span></span><a class="headerlink" href="#cmdoption-unittest-discover-p" title="永久链接至目标">¶</a></dt>
<dd><p>用于匹配测试文件的模式（默认为 <code class="docutils literal notranslate"><span class="pre">test*.py</span></code> ）。</p>
</dd></dl>

<dl class="std cmdoption">
<dt class="sig sig-object std" id="cmdoption-unittest-discover-t">
<span id="cmdoption-unittest-discover-top-level-directory"></span><span class="sig-name descname"><span class="pre">-t</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--top-level-directory</span></span><span class="sig-prename descclassname"> <span class="pre">directory</span></span><a class="headerlink" href="#cmdoption-unittest-discover-t" title="永久链接至目标">¶</a></dt>
<dd><p>指定项目的最上层目录（通常为开始时所在目录）。</p>
</dd></dl>

<p><a class="reference internal" href="#cmdoption-unittest-discover-s"><code class="xref std std-option docutils literal notranslate"><span class="pre">-s</span></code></a> ，<a class="reference internal" href="#cmdoption-unittest-discover-p"><code class="xref std std-option docutils literal notranslate"><span class="pre">-p</span></code></a> 和 <a class="reference internal" href="#cmdoption-unittest-discover-t"><code class="xref std std-option docutils literal notranslate"><span class="pre">-t</span></code></a> 选项可以按顺序作为位置参数传入。以下两条命令是等价的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="o">-</span><span class="n">s</span> <span class="n">project_directory</span> <span class="o">-</span><span class="n">p</span> <span class="s2">&quot;*_test.py&quot;</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="n">project_directory</span> <span class="s2">&quot;*_test.py&quot;</span>
</pre></div>
</div>
<p>正如可以传入路径那样，传入一个包名作为起始目录也是可行的，如 <code class="docutils literal notranslate"><span class="pre">myproject.subpackage.test</span></code> 。你提供的包名会被导入，它在文件系统中的位置会被作为起始目录。</p>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p>探索性测试通过导入测试对测试进行加载。在找到所有你指定的开始目录下的所有测试文件后，它把路径转换为包名并进行导入。如 <code class="file docutils literal notranslate"><span class="pre">foo/bar/baz.py</span></code> 会被导入为 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 。</p>
<p>如果你有一个全局安装的包，并尝试对这个包的副本进行探索性测试，可能会从错误的地方开始导入。如果出现这种情况，测试会输出警告并退出。</p>
<p>如果你使用包名而不是路径作为开始目录，搜索时会假定它导入的是你想要的目录，所以你不会收到警告。</p>
</div>
<p>测试模块和包可以通过 <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a> 自定义测试的加载和搜索。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>测试发现支持初始目录下的 <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">命名空间包</span></a>。注意你也需要指定顶层目录（例如：<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span> <span class="pre">discover</span> <span class="pre">-s</span> <span class="pre">root/namespace</span> <span class="pre">-t</span> <span class="pre">root</span></code>）。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版更改: </span>Python 3.11 dropped the <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">namespace packages</span></a>
support. It has been broken since Python 3.7. Start directory and
subdirectories containing tests must be regular package that have
<code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file.</p>
<p>Directories containing start directory still can be a namespace package.
In this case, you need to specify start directory as dotted package name,
and target directory explicitly. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># proj/  &lt;-- current directory</span>
<span class="c1">#   namespace/</span>
<span class="c1">#     mypkg/</span>
<span class="c1">#       __init__.py</span>
<span class="c1">#       test_mypkg.py</span>

<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="o">-</span><span class="n">s</span> <span class="n">namespace</span><span class="o">.</span><span class="n">mypkg</span> <span class="o">-</span><span class="n">t</span> <span class="o">.</span>
</pre></div>
</div>
</div>
</section>
<section id="organizing-test-code">
<span id="organizing-tests"></span><h2>组织你的测试代码<a class="headerlink" href="#organizing-test-code" title="永久链接至标题">¶</a></h2>
<p>单元测试的构建单位是 <em class="dfn">test cases</em> ：独立的、包含执行条件与正确性检查的方案。在 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 中，测试用例表示为 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a> 的实例。通过编写 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的子类或使用 <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a> 编写你自己的测试用例。</p>
<p>一个 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例的测试代码必须是完全自含的，因此它可以独立运行，或与其它任意组合任意数量的测试用例一起运行。</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的最简单的子类需要实现一个测试方法（例如一个命名以 <code class="docutils literal notranslate"><span class="pre">test</span></code> 开头的方法）以执行特定的测试代码：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
</pre></div>
</div>
<p>可以看到，为了进行测试，我们使用了基类 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 提供的其中一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">assert*()</span></code> 方法。若测试不通过，将会引发一个带有说明信息的异常，并且 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 会将这个测试用例标记为测试不通过。任何其它类型的异常将会被当做错误处理。</p>
<p>可能同时存在多个前置操作相同的测试，我们可以把测试的前置操作从测试代码中拆解出来，并实现测试前置方法 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 。在运行测试时，测试框架会自动地为每个单独测试调用前置方法。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s1">&#39;incorrect default size&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_widget_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s1">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>多个测试运行的顺序由内置字符串排序方法对测试名进行排序的结果决定。</p>
</div>
<p>在测试运行时，若 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 方法引发异常，测试框架会认为测试发生了错误，因此测试方法不会被运行。</p>
<p>相似的，我们提供了一个 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 方法在测试方法运行后进行清理工作。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
</pre></div>
</div>
<p>若 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 成功运行，无论测试方法是否成功，都会运行 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 。</p>
<p>这样的一个测试代码运行的环境被称为 <em class="dfn">test fixture</em> 。一个新的 TestCase 实例作为一个测试脚手架，用于运行各个独立的测试方法。在运行每个测试时，<a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 、<a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 会被调用一次。</p>
<p>推荐你根据用例所测试的功能将测试用 TestCase 分组。<a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 为此提供了 <em class="dfn">test suite</em>：<a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 的 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 类是一个代表。通常情况下，调用 <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> 就能正确地找到并执行这个模块下所有用 TestCase 分组的测试。</p>
<p>然而，如果你需要自定义你的测试套件的话，你可以参考以下方法组织你的测试：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_default_widget_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_widget_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">runner</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">()</span>
    <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">())</span>
</pre></div>
</div>
<p>你可以把测试用例和测试套件放在与被测试代码相同的模块中（比如 <code class="file docutils literal notranslate"><span class="pre">widget.py</span></code>），但将测试代码放在单独的模块中（比如 <code class="file docutils literal notranslate"><span class="pre">test_widget.py</span></code>）有几个优势。</p>
<ul class="simple">
<li><p>测试模块可以从命令行被独立调用。</p></li>
<li><p>更容易在分发的代码中剥离测试代码。</p></li>
<li><p>降低没有好理由的情况下修改测试代码以通过测试的诱惑。</p></li>
<li><p>测试代码应比被测试代码更少地被修改。</p></li>
<li><p>被测试代码可以更容易地被重构。</p></li>
<li><p>对用 C 语言写成的模块无论如何都得单独写成一个模块，为什么不保持一致呢？</p></li>
<li><p>如果测试策略发生了改变，没有必要修改源代码。</p></li>
</ul>
</section>
<section id="re-using-old-test-code">
<span id="legacy-unit-tests"></span><h2>复用已有的测试代码<a class="headerlink" href="#re-using-old-test-code" title="永久链接至标题">¶</a></h2>
<p>一些用户希望直接使用 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 运行已有的测试代码，而不需要把已有的每个测试函数转化为一个 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的子类。</p>
<p>因此， <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 提供 <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a> 类。这个 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的子类可用于打包已有的测试函数，并支持设置前置与后置函数。</p>
<p>假定有一个测试函数：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">testSomething</span><span class="p">():</span>
    <span class="n">something</span> <span class="o">=</span> <span class="n">makeSomething</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">something</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>可以创建等价的测试用例如下，其中前置和后置方法是可选的。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">,</span>
                                     <span class="n">setUp</span><span class="o">=</span><span class="n">makeSomethingDB</span><span class="p">,</span>
                                     <span class="n">tearDown</span><span class="o">=</span><span class="n">deleteSomethingDB</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>用 <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a> 可以快速将现有的测试转换成基于 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 的测试，但不推荐你这样做。花点时间继承 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 会让以后重构测试无比轻松。</p>
</div>
<p>在某些情况下，现有的测试可能是用 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 模块编写的。 如果是这样， <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 提供了一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestSuite</span></code> 类，可以从现有基于 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 的测试中自动构建 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a> 用例。</p>
</section>
<section id="skipping-tests-and-expected-failures">
<span id="unittest-skipping"></span><h2>跳过测试与预计的失败<a class="headerlink" href="#skipping-tests-and-expected-failures" title="永久链接至标题">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
<p>Unittest 支持跳过单个或整组的测试用例。它还支持把测试标注成“预期失败”的测试。这些坏测试会失败，但不会算进 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 的失败里。</p>
<p>要跳过测试只需使用 <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal notranslate"><span class="pre">skip()</span></code></a> <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> 或其附带条件的版本，在 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 内部使用 <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.skipTest()</span></code></a>，或是直接引发 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>。</p>
<p>跳过测试的基本用法如下:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;demonstrating skipping&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_nothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s2">&quot;shouldn&#39;t happen&quot;</span><span class="p">)</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipIf</span><span class="p">(</span><span class="n">mylib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                     <span class="s2">&quot;not supported in this library version&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Tests that work for only a certain version of the library.</span>
        <span class="k">pass</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipUnless</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;win&quot;</span><span class="p">),</span> <span class="s2">&quot;requires Windows&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_windows_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># windows specific testing code</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">test_maybe_skipped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">external_resource_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s2">&quot;external resource not available&quot;</span><span class="p">)</span>
        <span class="c1"># test code that depends on the external resource</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>在啰嗦模式下运行以上测试例子时，程序输出如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_format</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="o">.</span><span class="n">test_format</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;not supported in this library version&#39;</span>
<span class="n">test_nothing</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="o">.</span><span class="n">test_nothing</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;demonstrating skipping&#39;</span>
<span class="n">test_maybe_skipped</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="o">.</span><span class="n">test_maybe_skipped</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;external resource not available&#39;</span>
<span class="n">test_windows_support</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="o">.</span><span class="n">test_windows_support</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;requires Windows&#39;</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">4</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.005</span><span class="n">s</span>

<span class="n">OK</span> <span class="p">(</span><span class="n">skipped</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>跳过测试类的写法跟跳过测试方法的写法相似:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;showing class skipping&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MySkippedTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_not_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.setUp()</span></code></a>  也可以跳过测试。可以用于所需资源不可用的情况下跳过接下来的测试。</p>
<p>使用 <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> 装饰器表明这个测试预计失败。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpectedFailureTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@unittest</span><span class="o">.</span><span class="n">expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;broken&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>你可以很容易地编写在测试时调用 <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal notranslate"><span class="pre">skip()</span></code></a> 的装饰器作为自定义的跳过测试装饰器。 下面这个装饰器会跳过测试，除非所传入的对象具有特定的属性:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">skipUnlessHasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> doesn&#39;t have </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</pre></div>
</div>
<p>以下的装饰器和异常实现了跳过测试和预期失败两种功能：</p>
<dl class="py function">
<dt class="sig sig-object py" id="unittest.skip">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">skip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skip" title="永久链接至目标">¶</a></dt>
<dd><p>跳过被此装饰器装饰的测试。 <em>reason</em>  为测试被跳过的原因。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.skipIf">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">skipIf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipIf" title="永久链接至目标">¶</a></dt>
<dd><p>当 <em>condition</em> 为真时，跳过被装饰的测试。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.skipUnless">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">skipUnless</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipUnless" title="永久链接至目标">¶</a></dt>
<dd><p>跳过被装饰的测试，除非 <em>condition</em> 为真。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.expectedFailure">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">expectedFailure</span></span><a class="headerlink" href="#unittest.expectedFailure" title="永久链接至目标">¶</a></dt>
<dd><p>将测试标记为预期的失败或错误。 如果测试失败或在测试函数自身（而非在某个 <em class="dfn">test fixture</em> 方法）中出现错误则将认为是测试成功。 如果测试通过，则将认为是测试失败。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="unittest.SkipTest">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">SkipTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.SkipTest" title="永久链接至目标">¶</a></dt>
<dd><p>引发此异常以跳过一个测试。</p>
<p>通常来说，你可以使用 <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.skipTest()</span></code></a> 或其中一个跳过测试的装饰器实现跳过测试的功能，而不是直接引发此异常。</p>
</dd></dl>

<p>被跳过的测试的 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>  和 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 不会被运行。被跳过的类的 <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> 和 <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> 不会被运行。被跳过的模组的 <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> 不会被运行。</p>
</section>
<section id="distinguishing-test-iterations-using-subtests">
<span id="subtests"></span><h2>使用子测试区分测试迭代<a class="headerlink" href="#distinguishing-test-iterations-using-subtests" title="永久链接至标题">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<p>当你的几个测试之间的差异非常小，例如只有某些形参不同时，unittest 允许你使用 <a class="reference internal" href="#unittest.TestCase.subTest" title="unittest.TestCase.subTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subTest()</span></code></a> 上下文管理器在一个测试方法体的内部区分它们。</p>
<p>例如，以下测试:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NumbersTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test that numbers between 0 and 5 are all even.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">subTest</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>可以得到以下输出:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="o">.</span><span class="n">test_even</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Test</span> <span class="n">that</span> <span class="n">numbers</span> <span class="n">between</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">5</span> <span class="n">are</span> <span class="nb">all</span> <span class="n">even</span><span class="o">.</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">11</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="o">.</span><span class="n">test_even</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Test</span> <span class="n">that</span> <span class="n">numbers</span> <span class="n">between</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">5</span> <span class="n">are</span> <span class="nb">all</span> <span class="n">even</span><span class="o">.</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">11</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="o">.</span><span class="n">test_even</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Test</span> <span class="n">that</span> <span class="n">numbers</span> <span class="n">between</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">5</span> <span class="n">are</span> <span class="nb">all</span> <span class="n">even</span><span class="o">.</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">11</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>如果不使用子测试，程序遇到第一次错误之后就会停止。而且因为``i``的值不显示，错误也更难找。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="o">.</span><span class="n">test_even</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
</section>
<section id="classes-and-functions">
<span id="unittest-contents"></span><h2>类与函数<a class="headerlink" href="#classes-and-functions" title="永久链接至标题">¶</a></h2>
<p>本节深入介绍了 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 的 API。</p>
<section id="test-cases">
<span id="testcase-objects"></span><h3>测试用例<a class="headerlink" href="#test-cases" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="unittest.TestCase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 类的实例代表了 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 宇宙中的逻辑测试单元。 该类旨在被当作基类使用，特定的测试将由其实体子类来实现。 该类实现了测试运行器所需的接口以允许它驱动测试，并实现了可被测试代码用来检测和报告各种类型的失败的方法。</p>
<p>每个 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例将运行一个单位的基础方法：即名为 <em>methodName</em> 的方法。 在使用 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的大多数场景中，你都不需要修改 <em>methodName</em> 或重新实现默认的 <code class="docutils literal notranslate"><span class="pre">runTest()</span></code> 方法。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 不需要提供 <em>methodName</em> 即可成功实例化。 这使得从交互式解释器试验 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 更为容易。</p>
</div>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的实例提供了三组方法：一组用来运行测试，另一组被测试实现用来检查条件和报告失败，还有一些查询方法用来收集有关测试本身的信息。</p>
<p>第一组（用于运行测试的）方法是：</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.setUp">
<span class="sig-name descname"><span class="pre">setUp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUp" title="永久链接至目标">¶</a></dt>
<dd><p>为测试预备而调用的方法。 此方法会在调用测试方法之前被调用；除了 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 或 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>，此方法所引发的任何异常都将被视为错误而非测试失败。 默认的实现将不做任何事情。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.tearDown">
<span class="sig-name descname"><span class="pre">tearDown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDown" title="永久链接至目标">¶</a></dt>
<dd><p>在测试方法被调用并记录结果之后立即被调用的方法。 此方法即使在测试方法引发异常时仍会被调用，因此子类中的实现将需要特别注意检查内部状态。 除 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 或 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> 外，此方法所引发的任何异常都将被视为额外的错误而非测试失败（因而会增加总计错误报告数）。 此方法将只在 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 成功执行时被调用，无论测试方法的结果如何。 默认的实现将不做任何事情。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.setUpClass">
<span class="sig-name descname"><span class="pre">setUpClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUpClass" title="永久链接至目标">¶</a></dt>
<dd><p>在一个单独类中的测试运行之前被调用的类方法。 <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> 会被作为唯一的参数在类上调用且必须使用 <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 装饰器:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>查看 <a class="reference internal" href="#class-and-module-fixtures">Class and Module Fixtures</a> 获取更详细的说明。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.tearDownClass">
<span class="sig-name descname"><span class="pre">tearDownClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDownClass" title="永久链接至目标">¶</a></dt>
<dd><p>在一个单独类的测试完成运行之后被调用的类方法。 <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> 会被作为唯一的参数在类上调用且必须使用 <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 装饰器:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>查看 <a class="reference internal" href="#class-and-module-fixtures">Class and Module Fixtures</a> 获取更详细的说明。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.run" title="永久链接至目标">¶</a></dt>
<dd><p>运行测试，将结果收集至作为 <em>result</em> 传入的 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>。 如果 <em>result</em> 被省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则会创建一个临时的结果对象（通过调用 <a class="reference internal" href="#unittest.TestCase.defaultTestResult" title="unittest.TestCase.defaultTestResult"><code class="xref py py-meth docutils literal notranslate"><span class="pre">defaultTestResult()</span></code></a> 方法）并使用它。 结果对象会被返回给 <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> 的调用方。</p>
<p>同样的效果也可通过简单地调用 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例来达成。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>之前版本的 <code class="docutils literal notranslate"><span class="pre">run</span></code> 不会返回结果。 也不会对实例执行调用。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.skipTest">
<span class="sig-name descname"><span class="pre">skipTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.skipTest" title="永久链接至目标">¶</a></dt>
<dd><p>在测试方法或 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 执行期间调用此方法将跳过当前测试。 详情参见 <a class="reference internal" href="#unittest-skipping"><span class="std std-ref">跳过测试与预计的失败</span></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.subTest">
<span class="sig-name descname"><span class="pre">subTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.subTest" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个上下文管理器以将其中的代码块作为子测试来执行。 可选的 <em>msg</em> 和 <em>params</em> 是将在子测试失败时显示的任意值，以便让你能清楚地标识它们。</p>
<p>一个测试用例可以包含任意数量的子测试声明，并且它们可以任意地嵌套。</p>
<p>查看 <a class="reference internal" href="#subtests"><span class="std std-ref">使用子测试区分测试迭代</span></a> 获取更详细的信息。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.debug">
<span class="sig-name descname"><span class="pre">debug</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.debug" title="永久链接至目标">¶</a></dt>
<dd><p>运行测试而不收集结果。 这允许测试所引发的异常被传递给调用方，并可被用于支持在调试器中运行测试。</p>
</dd></dl>

<p id="assert-methods"><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 类提供了一些断言方法用于检查并报告失败。 下表列出了最常用的方法（请查看下文的其他表来了解更多的断言方法）:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 34%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>方法</p></th>
<th class="head"><p>检查对象</p></th>
<th class="head"><p>引入版本</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">True</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">False</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIs(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNot" title="unittest.TestCase.assertIsNot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNot(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNotNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIn" title="unittest.TestCase.assertIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIn(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotIn" title="unittest.TestCase.assertNotIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIn(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsInstance" title="unittest.TestCase.assertIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsInstance(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotIsInstance" title="unittest.TestCase.assertNotIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIsInstance(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<p>这些断言方法都支持 <em>msg</em> 参数，如果指定了该参数，它将被用作测试失败时的错误消息 (另请参阅 <a class="reference internal" href="#unittest.TestCase.longMessage" title="unittest.TestCase.longMessage"><code class="xref py py-data docutils literal notranslate"><span class="pre">longMessage</span></code></a>)。 请注意将 <em>msg</em> 关键字参数传给 <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertWarnsRegex" title="unittest.TestCase.assertWarnsRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarnsRegex()</span></code></a> 的前提是它们必须被用作上下文管理器。</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertEqual">
<span class="sig-name descname"><span class="pre">assertEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertEqual" title="永久链接至目标">¶</a></dt>
<dd><p>测试 <em>first</em> 和 <em>second</em> 是否相等。 如果两个值的比较结果是不相等，则测试将失败。</p>
<p>此外，如果 <em>first</em> 和 <em>second</em> 的类型完全相同且属于 list, tuple, dict, set, frozenset 或 str 或者属于通过 <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a> 注册子类的类型则将会调用类型专属的相等判断函数以便生成更有用的默认错误消息 (另请参阅 <a class="reference internal" href="#type-specific-methods"><span class="std std-ref">类型专属方法列表</span></a>)。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版更改: </span>增加了对类型专属的相等判断函数的自动调用。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>增加了 <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a> 作为用于比较字符串的默认类型相等判断函数。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertNotEqual">
<span class="sig-name descname"><span class="pre">assertNotEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotEqual" title="永久链接至目标">¶</a></dt>
<dd><p>测试 <em>first</em> 和 <em>second</em> 是否不等。 如果两个值的比较结果是相等，则测试将失败。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertTrue">
<span class="sig-name descname"><span class="pre">assertTrue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTrue" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertFalse">
<span class="sig-name descname"><span class="pre">assertFalse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertFalse" title="永久链接至目标">¶</a></dt>
<dd><p>测试 <em>expr</em> 是否为真值（或假值）。</p>
<p>请注意这等价于 <code class="docutils literal notranslate"><span class="pre">bool(expr)</span> <span class="pre">is</span> <span class="pre">True</span></code> 而不等价于 <code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">is</span> <span class="pre">True</span></code> (后者要使用 <code class="docutils literal notranslate"><span class="pre">assertIs(expr,</span> <span class="pre">True)</span></code>)。 当存在更专门的方法时也应避免使用此方法 (例如应使用 <code class="docutils literal notranslate"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">assertTrue(a</span> <span class="pre">==</span> <span class="pre">b)</span></code>)，因为它们在测试失败时会提供更有用的错误消息。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertIs">
<span class="sig-name descname"><span class="pre">assertIs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIs" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertIsNot">
<span class="sig-name descname"><span class="pre">assertIsNot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNot" title="永久链接至目标">¶</a></dt>
<dd><p>测试 <em>first</em> 和 <em>second</em> 是 (或不是) 同一个对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertIsNone">
<span class="sig-name descname"><span class="pre">assertIsNone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNone" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertIsNotNone">
<span class="sig-name descname"><span class="pre">assertIsNotNone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNotNone" title="永久链接至目标">¶</a></dt>
<dd><p>测试 <em>expr</em> 是 (或不是) <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertIn">
<span class="sig-name descname"><span class="pre">assertIn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">member</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">container</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIn" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertNotIn">
<span class="sig-name descname"><span class="pre">assertNotIn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">member</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">container</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIn" title="永久链接至目标">¶</a></dt>
<dd><p>测试 <em>member</em> 是 (或不是) <em>container</em> 的成员。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertIsInstance">
<span class="sig-name descname"><span class="pre">assertIsInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsInstance" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertNotIsInstance">
<span class="sig-name descname"><span class="pre">assertNotIsInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIsInstance" title="永久链接至目标">¶</a></dt>
<dd><p>测试 <em>obj</em> 是 (或不是) <em>cls</em> (此参数可以为一个类或包含类的元组，即 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 所接受的参数) 的实例。 要检测是否为指定类型，请使用 <a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-func docutils literal notranslate"><span class="pre">assertIs(type(obj),</span> <span class="pre">cls)</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<p>还可以使用下列方法来检查异常、警告和日志消息的产生:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 53%" />
<col style="width: 36%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>方法</p></th>
<th class="head"><p>检查对象</p></th>
<th class="head"><p>引入版本</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises(exc,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> 引发了 <em>exc</em></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex(exc,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> 引发了 <em>exc</em> 并且消息可与正则表达式 <em>r</em> 相匹配</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns(warn,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> 引发了 <em>warn</em></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertWarnsRegex" title="unittest.TestCase.assertWarnsRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarnsRegex(warn,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> 引发了 <em>warn</em> 并且消息可与正则表达式 <em>r</em> 相匹配</p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs(logger,</span> <span class="pre">level)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">with</span></code> 代码块在 <em>logger</em> 上使用了最小的 <em>level</em> 级别写入日志</p></td>
<td><p>3.4</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNoLogs" title="unittest.TestCase.assertNoLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNoLogs(logger,</span> <span class="pre">level)</span></code></a></p></td>
<td><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">with</span></code> 代码块没有在</dt><dd><p><em>logger</em> 上使用最小的 <em>level</em> 级别写入日志</p>
</dd>
</dl>
</td>
<td><p>3.10</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertRaises">
<span class="sig-name descname"><span class="pre">assertRaises</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaises" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">assertRaises</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>测试当 <em>callable</em> 附带任何同时被传给 <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> 的位置或关键字参数被调用时是否引发了异常。 如果引发了 <em>exception</em> 则测试通过，如果引发了另一个异常则报错，或者如果未引发任何异常则测试失败。 要捕获一组异常中的任何一个，可以将包含多个异常类的元组作为 <em>exception</em> 传入。</p>
<p>如果只给出了 <em>exception</em> 和可能的 <em>msg</em> 参数，则返回一个上下文管理器以便被测试的代码可以被写成内联形式而不是被写成函数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>当被作为上下文管理器使用时，<a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> 接受额外的关键字参数 <em>msg</em>。</p>
<p>上下文管理器将把捕获的异常对象存入在其 <code class="xref py py-attr docutils literal notranslate"><span class="pre">exception</span></code> 属性中。 这适用于需要对所引发异常执行额外检查的场合:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="n">the_exception</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">exception</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">the_exception</span><span class="o">.</span><span class="n">error_code</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版更改: </span>添加了将 <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> 用作上下文管理器的功能。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>增加了 <code class="xref py py-attr docutils literal notranslate"><span class="pre">exception</span></code> 属性。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>msg</em> 关键字参数在作为上下文管理器时使用。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertRaisesRegex">
<span class="sig-name descname"><span class="pre">assertRaisesRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaisesRegex" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">assertRaisesRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>与 <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> 类似但还会测试 <em>regex</em> 是否匹配被引发异常的字符串表示形式。 <em>regex</em> 可以是一个正则表达式对象或包含正则表达式的字符串以提供给 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> 使用。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;invalid literal for.*XYZ&#39;$&quot;</span><span class="p">,</span>
                       <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>或者：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s1">&#39;literal&#39;</span><span class="p">):</span>
   <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能: </span>以方法名``assertRaisesRegexp``添加。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>重命名为 <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>msg</em> 关键字参数在作为上下文管理器时使用。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertWarns">
<span class="sig-name descname"><span class="pre">assertWarns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warning</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertWarns" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">assertWarns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warning</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>测试当 <em>callable</em> 附带任何同时被传给 <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a> 的位置或关键字参数被调用时是否触发了警告。 如果触发了 <em>warning</em> 则测试通过，否则测试失败。 引发任何异常则报错。 要捕获一组警告中的任何一个，可将包含多个警告类的元组作为 <em>warnings</em> 传入。</p>
<p>如果只给出了 <em>warning</em> 和可能的 <em>msg</em> 参数，则返回一个上下文管理器以便被测试的代码可以被写成内联形式而不是被写成函数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarns</span><span class="p">(</span><span class="n">SomeWarning</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>当被作为上下文管理器使用时，<a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a> 接受额外的关键字参数 <em>msg</em>。</p>
<p>上下文管理器将把捕获的警告对象保存在其 <code class="xref py py-attr docutils literal notranslate"><span class="pre">warning</span></code> 属性中，并把触发警告的源代码行保存在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code> 属性中。 这适用于需要对捕获的警告执行额外检查的场合:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarns</span><span class="p">(</span><span class="n">SomeWarning</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="bp">self</span><span class="o">.</span><span class="n">assertIn</span><span class="p">(</span><span class="s1">&#39;myfile.py&#39;</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">lineno</span><span class="p">)</span>
</pre></div>
</div>
<p>无论被调用时警告过滤器是否就位此方法均可工作。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>msg</em> 关键字参数在作为上下文管理器时使用。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertWarnsRegex">
<span class="sig-name descname"><span class="pre">assertWarnsRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warning</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertWarnsRegex" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">assertWarnsRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warning</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>与 <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a> 类似但还会测试 <em>regex</em> 是否匹配被触发警告的消息文本。 <em>regex</em> 可以是一个正则表达式对象或包含正则表达式的字符串以提供给 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> 使用。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertWarnsRegex</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                      <span class="sa">r</span><span class="s1">&#39;legacy_function\(\) is deprecated&#39;</span><span class="p">,</span>
                      <span class="n">legacy_function</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>或者：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarnsRegex</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="s1">&#39;unsafe frobnicating&#39;</span><span class="p">):</span>
    <span class="n">frobnicate</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>msg</em> 关键字参数在作为上下文管理器时使用。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertLogs">
<span class="sig-name descname"><span class="pre">assertLogs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLogs" title="永久链接至目标">¶</a></dt>
<dd><p>一个上下文管理器，它测试在 <em>logger</em> 或其子对象上是否至少记录了一条至少为指定 <em>level</em> 以上级别的消息。</p>
<p>如果给出了 <em>logger</em> 则它应为一个 <a class="reference internal" href="logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Logger</span></code></a> 对象或为一个指定日志记录器名称的 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>。 默认为根日志记录器，它将捕获未被非传播型后继日志记录器所拦阻的所有消息。</p>
<p>如果给出了 <em>level</em> 则它应为一个用数字表示的日志记录级别或其字符串形式 (例如 <code class="docutils literal notranslate"><span class="pre">&quot;ERROR&quot;</span></code> 或 <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.ERROR</span></code>)。 默认为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.INFO</span></code>。</p>
<p>如果在 <code class="docutils literal notranslate"><span class="pre">with</span></code> 代码块内部发出了至少一条与 <em>logger</em> 和 <em>level</em> 条件相匹配的消息则测试通过，否则测试失败。</p>
<p>上下文管理器返回的对象是一个记录辅助器，它会记录所匹配的日志消息。 它有两个属性:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestCase.records">
<span class="sig-name descname"><span class="pre">records</span></span><a class="headerlink" href="#unittest.TestCase.records" title="永久链接至目标">¶</a></dt>
<dd><p>所匹配的日志消息 <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.LogRecord</span></code></a> 对象组成的列表。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestCase.output">
<span class="sig-name descname"><span class="pre">output</span></span><a class="headerlink" href="#unittest.TestCase.output" title="永久链接至目标">¶</a></dt>
<dd><p>由 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象组成的列表，内容为所匹配消息经格式化后的输出。</p>
</dd></dl>

<p>示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertLogs</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;INFO&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;first message&#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo.bar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;second message&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;INFO:foo:first message&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;ERROR:foo.bar:second message&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertNoLogs">
<span class="sig-name descname"><span class="pre">assertNoLogs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNoLogs" title="永久链接至目标">¶</a></dt>
<dd><p>一个上下文管理器，它测试在 <em>logger</em> 或其子对象上是否未记录任何至少为指定 <em>level</em> 以上级别的消息。</p>
<p>如果给出了 <em>logger</em> 则它应为一个 <a class="reference internal" href="logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Logger</span></code></a> 对象或为一个指定日志记录器名称的 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>。 默认为根日志记录器，它将捕获所有消息。</p>
<p>如果给出了 <em>level</em> 则它应为一个用数字表示的日志记录级别或其字符串形式 (例如 <code class="docutils literal notranslate"><span class="pre">&quot;ERROR&quot;</span></code> 或 <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.ERROR</span></code>)。 默认为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.INFO</span></code>。</p>
<p>与 <a class="reference internal" href="#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs()</span></code></a> 不同，上下文管理器将不返回任何对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
</dd></dl>

<p>还有其他一些方法可用于执行更专门的检查，例如:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 38%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>方法</p></th>
<th class="head"><p>检查对象</p></th>
<th class="head"><p>引入版本</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">==</span> <span class="pre">0</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">!=</span> <span class="pre">0</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertGreater" title="unittest.TestCase.assertGreater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreater(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertGreaterEqual" title="unittest.TestCase.assertGreaterEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreaterEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertLess" title="unittest.TestCase.assertLess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLess(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertLessEqual" title="unittest.TestCase.assertLessEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLessEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex(s,</span> <span class="pre">r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r.search(s)</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex(s,</span> <span class="pre">r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">r.search(s)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertCountEqual" title="unittest.TestCase.assertCountEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertCountEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><em>a</em> 和 <em>b</em> 具有同样数量的相同元素，无论其顺序如何。</p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertAlmostEqual">
<span class="sig-name descname"><span class="pre">assertAlmostEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">places</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertAlmostEqual" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertNotAlmostEqual">
<span class="sig-name descname"><span class="pre">assertNotAlmostEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">places</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotAlmostEqual" title="永久链接至目标">¶</a></dt>
<dd><p>测试 <em>first</em> 与 <em>second</em> 是否几乎相等，比较的标准是计算差值并舍入到 <em>places</em> 所指定的十进制位数 (默认为 7 位)，再与零相比较。 请注意此方法是将结果值舍入到指定的 <em>十进制位数</em> (即相当于 <a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 函数) 而非 <em>有效位数</em>。</p>
<p>如果提供了 <em>delta</em> 而非 <em>places</em> 则 <em>first</em> 和 <em>second</em> 之间的差值必须小于等于 (或大于) <em>delta</em>。</p>
<p>同时提供 <em>delta</em> 和 <em>places</em> 将引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a> 会自动将几乎相等的对象视为相等。 而如果对象相等则 <a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a> 会自动测试失败。 增加了 <em>delta</em> 关键字参数。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertGreater">
<span class="sig-name descname"><span class="pre">assertGreater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreater" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertGreaterEqual">
<span class="sig-name descname"><span class="pre">assertGreaterEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreaterEqual" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertLess">
<span class="sig-name descname"><span class="pre">assertLess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLess" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertLessEqual">
<span class="sig-name descname"><span class="pre">assertLessEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLessEqual" title="永久链接至目标">¶</a></dt>
<dd><p>根据方法名分别测试 <em>first</em> 是否 &gt;, &gt;=, &lt; 或 &lt;= <em>second</em>。 如果不是，则测试失败:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">assertGreaterEqual</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">AssertionError: &quot;3&quot; unexpectedly not greater than or equal to &quot;4&quot;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertRegex">
<span class="sig-name descname"><span class="pre">assertRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRegex" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertNotRegex">
<span class="sig-name descname"><span class="pre">assertNotRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotRegex" title="永久链接至目标">¶</a></dt>
<dd><p>测试一个 <em>regex</em> 搜索匹配（或不匹配） <em>文本</em>。如果不匹配，错误信息中将包含匹配模式和 <em>文本*（或部分匹配失败的 *文本</em>）。<em>regex</em> 可以是正则表达式对象或能够用于 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> 的包含正则表达式的字符串。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能: </span>以方法名``assertRegexpMatches``添加。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>方法 <code class="docutils literal notranslate"><span class="pre">assertRegexpMatches()</span></code> 已被改名为 <a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能: </span><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能: </span><code class="docutils literal notranslate"><span class="pre">assertNotRegexpMatches</span></code> 这个名字是 <a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a> 的已被弃用的别名。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertCountEqual">
<span class="sig-name descname"><span class="pre">assertCountEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertCountEqual" title="永久链接至目标">¶</a></dt>
<dd><p>测试序列 <em>first</em> 与 <em>second</em> 是否包含同样的元素，无论其顺序如何。 当存在差异时，将生成一条错误消息来列出两个序列之间的差异。</p>
<p>重复的元素 <em>不会</em> 在 <em>first</em> 和 <em>second</em> 的比较中被忽略。 它会检查每个元素在两个序列中的出现次数是否相同。 等价于: <code class="docutils literal notranslate"><span class="pre">assertEqual(Counter(list(first)),</span> <span class="pre">Counter(list(second)))</span></code> 但还适用于包含不可哈希对象的序列。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<p id="type-specific-methods"><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 方法会将相同类型对象的相等性检查分派给不同的类型专属方法。 这些方法已被大多数内置类型所实现，但也可以使用 <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a> 来注册新的方法:</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.addTypeEqualityFunc">
<span class="sig-name descname"><span class="pre">addTypeEqualityFunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typeobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addTypeEqualityFunc" title="永久链接至目标">¶</a></dt>
<dd><p>注册一个由 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 调用的特定类型专属方法来检查恰好为相同 <em>typeobj</em> (而非子类) 的两个对象是否相等。 <em>function</em> 必须接受两个位置参数和第三个 msg=None 关键字参数，就像 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 那样。 当检测到前两个形参之间不相等时它必须引发 <a class="reference internal" href="#unittest.TestCase.failureException" title="unittest.TestCase.failureException"><code class="xref py py-data docutils literal notranslate"><span class="pre">self.failureException(msg)</span></code></a> -- 可能还会提供有用的信息并在错误消息中详细解释不相等的原因。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<p>以下是 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 自动选用的不同类型的比较方法。一般情况下不需要直接在测试中调用这些方法。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 49%" />
<col style="width: 35%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>方法</p></th>
<th class="head"><p>用作比较</p></th>
<th class="head"><p>引入版本</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>字符串</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>序列</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>列表</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>元组</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSetEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>集合</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>字典</p></td>
<td><p>3.1</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertMultiLineEqual">
<span class="sig-name descname"><span class="pre">assertMultiLineEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertMultiLineEqual" title="永久链接至目标">¶</a></dt>
<dd><p>测试多行字符串 <em>first</em> 是否与字符串 <em>second</em> 相等。 当不相等时将在错误消息中包括两个字符串之间差异的高亮显示。 此方法会在通过 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 进行字符串比较时默认被使用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertSequenceEqual">
<span class="sig-name descname"><span class="pre">assertSequenceEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSequenceEqual" title="永久链接至目标">¶</a></dt>
<dd><p>测试两个序列是否相等。 如果提供了 <em>seq_type</em>，则 <em>first</em> 和 <em>second</em> 都必须为 <em>seq_type</em> 的实例否则将引发失败。 如果两个序列不相等则会构造一个错误消息来显示两者之间的差异。</p>
<p>此方法不会被 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 直接调用，但它会被用于实现 <a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual()</span></code></a> 和 <a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual()</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertListEqual">
<span class="sig-name descname"><span class="pre">assertListEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertListEqual" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="unittest.TestCase.assertTupleEqual">
<span class="sig-name descname"><span class="pre">assertTupleEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTupleEqual" title="永久链接至目标">¶</a></dt>
<dd><p>测试两个列表或元组是否相等。 如果不相等，则会构造一个错误消息来显示两者之间的差异。 如果某个形参的类型不正确也会引发错误。 这些方法会在通过 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 进行列表或元组比较时默认被使用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertSetEqual">
<span class="sig-name descname"><span class="pre">assertSetEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSetEqual" title="永久链接至目标">¶</a></dt>
<dd><p>测试两个集合是否相等。 如果不相等，则会构造一个错误消息来列出两者之间的差异。 此方法会在通过 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 进行集合或冻结集合比较时默认被使用。</p>
<p>如果 <em>first</em> 或 <em>second</em> 没有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">set.difference()</span></code> 方法则测试失败。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.assertDictEqual">
<span class="sig-name descname"><span class="pre">assertDictEqual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertDictEqual" title="永久链接至目标">¶</a></dt>
<dd><p>测试两个字典是否相等。 如果不相等，则会构造一个错误消息来显示两个字典的差异。 此方法会在对 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 的调用中默认被用来进行字典的比较。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<p id="other-methods-and-attrs">最后 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 还提供了以下的方法和属性:</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.fail">
<span class="sig-name descname"><span class="pre">fail</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.fail" title="永久链接至目标">¶</a></dt>
<dd><p>无条件地发出测试失败消息，附带错误消息 <em>msg</em> 或 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestCase.failureException">
<span class="sig-name descname"><span class="pre">failureException</span></span><a class="headerlink" href="#unittest.TestCase.failureException" title="永久链接至目标">¶</a></dt>
<dd><p>这个类属性给出测试方法所引发的异常。 如果某个测试框架需要使用专门的异常，并可能附带额外的信息，则必须子类化该类以便与框架“正常互动”。 这个属性的初始值为 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestCase.longMessage">
<span class="sig-name descname"><span class="pre">longMessage</span></span><a class="headerlink" href="#unittest.TestCase.longMessage" title="永久链接至目标">¶</a></dt>
<dd><p>这个类属性决定当将一个自定义失败消息作为 msg 参数传给一个失败的 assertXYY 调用时会发生什么。默认值为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 在此情况下，自定义消息会被添加到标准失败消息的末尾。 当设为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 时，自定义消息会替换标准消息。</p>
<p>类设置可以通过在调用断言方法之前将一个实例属性 self.longMessage 赋值为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">False</span></code> 在单个测试方法中进行重载。</p>
<p>类设置会在每个测试调用之前被重置。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestCase.maxDiff">
<span class="sig-name descname"><span class="pre">maxDiff</span></span><a class="headerlink" href="#unittest.TestCase.maxDiff" title="永久链接至目标">¶</a></dt>
<dd><p>这个属性控制来自在测试失败时报告 diffs 的断言方法的 diffs 输出的最大长度。 它默认为 80*8 个字符。 这个属性所影响的断言方法有 <a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual()</span></code></a> (包括所有委托给它的序列比较方法), <a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual()</span></code></a> 以及 <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a>。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">maxDiff</span></code> 设为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 表示不限制 diffs 的最大长度。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<p>测试框架可使用下列方法来收集测试的有关信息:</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.countTestCases">
<span class="sig-name descname"><span class="pre">countTestCases</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.countTestCases" title="永久链接至目标">¶</a></dt>
<dd><p>返回此测试对象所提供的测试数量。 对于 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例，该数量将总是为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.defaultTestResult">
<span class="sig-name descname"><span class="pre">defaultTestResult</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.defaultTestResult" title="永久链接至目标">¶</a></dt>
<dd><p>返回此测试类所要使用的测试结果类的实例（如果未向 <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> 方法提供其他结果实例）。</p>
<p>对于 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例，该返回值将总是为 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 的实例；<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的子类应当在有必要时重载此方法。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.id">
<span class="sig-name descname"><span class="pre">id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.id" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个标识指定测试用例的字符串。 该返回值通常为测试方法的完整名称，包括模块名和类名。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.shortDescription">
<span class="sig-name descname"><span class="pre">shortDescription</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.shortDescription" title="永久链接至目标">¶</a></dt>
<dd><p>返回测试的描述，如果未提供描述则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 此方法的默认实现将在可用的情况下返回测试方法的文档字符串的第一行，或者返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版更改: </span>在 3.1 中已修改此方法将测试名称添加到简短描述中，即使存在文档字符串。 这导致了与单元测试扩展的兼容性问题因而在 Python 3.2 中将添加测试名称操作改到 <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestResult</span></code></a> 中。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.addCleanup">
<span class="sig-name descname"><span class="pre">addCleanup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addCleanup" title="永久链接至目标">¶</a></dt>
<dd><p>在 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 之后添加了一个要调用的函数来清理测试期间所使用的资源。 函数将按它们被添加的相反顺序被调用 (<abbr title="last-in, first-out">LIFO</abbr>)。 它们在调用时将附带它们被添加时传给 <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a> 的任何参数和关键字参数。</p>
<p>如果 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 失败，即意味着 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 未被调用，则已添加的任何清理函数仍将被调用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.enterContext">
<span class="sig-name descname"><span class="pre">enterContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.enterContext" title="永久链接至目标">¶</a></dt>
<dd><p>Enter the supplied <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a>.  If successful, also
add its <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> method as a cleanup function by
<a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a> and return the result of the
<a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.11 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.doCleanups">
<span class="sig-name descname"><span class="pre">doCleanups</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doCleanups" title="永久链接至目标">¶</a></dt>
<dd><p>此方法会在 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 之后，或者如果 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 引发了异常则会在 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 之后被调用。</p>
<p>它将负责调用由 <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a> 添加的所有清理函数。 如果你需要在 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> <em>之前</em> 调用清理函数则可以自行调用 <a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a>。</p>
<p><a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a> 每次会弹出清理函数栈中的一个方法，因此它可以在任何时候被调用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.addClassCleanup">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">addClassCleanup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addClassCleanup" title="永久链接至目标">¶</a></dt>
<dd><p>在Add a function to be called after <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> 之后添加了一个要调用的函数来清理测试类运行期间所使用的资源。 函数将按它们被添加的相反顺序被调用 (<abbr title="last-in, first-out">LIFO</abbr>)。 它们在调用时将附带它们被添加时传给 <a class="reference internal" href="#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a> 的任何参数和关键字参数。</p>
<p>如果 <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> 失败，即意味着 <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> 未被调用，则已添加的任何清理函数仍将被调用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.enterClassContext">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enterClassContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.enterClassContext" title="永久链接至目标">¶</a></dt>
<dd><p>Enter the supplied <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a>.  If successful, also
add its <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> method as a cleanup function by
<a class="reference internal" href="#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a> and return the result of the
<a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.11 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestCase.doClassCleanups">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">doClassCleanups</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doClassCleanups" title="永久链接至目标">¶</a></dt>
<dd><p>此方法会在 <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> 之后无条件地被调用，或者如果 <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> 引发了异常则会在 <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> 之后被调用。</p>
<p>它将负责访问由 <a class="reference internal" href="#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a> 添加的所有清理函数。 如果你需要在 <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> <em>之前</em> 调用清理函数则可以自行调用 <a class="reference internal" href="#unittest.TestCase.doClassCleanups" title="unittest.TestCase.doClassCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doClassCleanups()</span></code></a>。</p>
<p><a class="reference internal" href="#unittest.TestCase.doClassCleanups" title="unittest.TestCase.doClassCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doClassCleanups()</span></code></a> 每次会弹出清理函数栈中的一个方法，因此它在任何时候被调用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">IsolatedAsyncioTestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase" title="永久链接至目标">¶</a></dt>
<dd><p>这个类提供了与 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 类似的 API 并也接受协程作为测试函数。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase.asyncSetUp">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">asyncSetUp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.asyncSetUp" title="永久链接至目标">¶</a></dt>
<dd><p>为测试预备而调用的方法。 此方法会在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code> 之后被调用。 此方法将在调用测试方法之前立即被调用；除了 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 或 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>，此方法所引发的任何异常都将被视为错误而非测试失败。 默认的实现将不做任何事情。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase.asyncTearDown">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">asyncTearDown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.asyncTearDown" title="永久链接至目标">¶</a></dt>
<dd><p>在测试方法被调用并记录结果之后立即被调用的方法。 此方法会在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code> 之前被调用。 此方法即使在测试方法引发异常时仍会被调用，因此子类中的实现将需要特别注意检查内部状态。 除 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 或 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> 外，此方法所引发的任何异常都将被视为额外的错误而非测试失败（因而会增加总计错误报告数）。 此方法将只在 <a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.asyncSetUp" title="unittest.IsolatedAsyncioTestCase.asyncSetUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncSetUp()</span></code></a> 成功执行时被调用，无论测试方法的结果如何。 默认的实现将不做任何事情。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase.addAsyncCleanup">
<span class="sig-name descname"><span class="pre">addAsyncCleanup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.addAsyncCleanup" title="永久链接至目标">¶</a></dt>
<dd><p>此方法接受一个可被用作清理函数的协程。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase.enterAsyncContext">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">enterAsyncContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.enterAsyncContext" title="永久链接至目标">¶</a></dt>
<dd><p>Enter the supplied <a class="reference internal" href="../glossary.html#term-asynchronous-context-manager"><span class="xref std std-term">asynchronous context manager</span></a>.  If successful,
also add its <a class="reference internal" href="../reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> method as a cleanup function by
<a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.addAsyncCleanup" title="unittest.IsolatedAsyncioTestCase.addAsyncCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addAsyncCleanup()</span></code></a> and return the result of the
<a class="reference internal" href="../reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.11 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.IsolatedAsyncioTestCase.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.run" title="永久链接至目标">¶</a></dt>
<dd><p>设置一个新的事件循环来运行测试，将结果收集至作为 <em>result</em> 传入的 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>。 如果 <em>result</em> 被省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则会创建一个临时的结果对象（通过调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">defaultTestResult()</span></code> 方法）并使用它。 结果对象会被返回给 <a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.run" title="unittest.IsolatedAsyncioTestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> 的调用方。 在测试结束时事件循环中的所有任务都将被取消。</p>
</dd></dl>

<p>一个显示先后顺序的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">IsolatedAsyncioTestCase</span>

<span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">IsolatedAsyncioTestCase</span><span class="p">):</span>


    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;setUp&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncSetUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span> <span class="o">=</span> <span class="k">await</span> <span class="n">AsyncConnection</span><span class="p">()</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;asyncSetUp&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">test_response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;test_response&quot;</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;https://example.com&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addAsyncCleanup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_cleanup</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;tearDown&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncTearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;asyncTearDown&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;cleanup&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>在运行测试之后，<code class="docutils literal notranslate"><span class="pre">events</span></code> 将会包含 <code class="docutils literal notranslate"><span class="pre">[&quot;setUp&quot;,</span> <span class="pre">&quot;asyncSetUp&quot;,</span> <span class="pre">&quot;test_response&quot;,</span> <span class="pre">&quot;asyncTearDown&quot;,</span> <span class="pre">&quot;tearDown&quot;,</span> <span class="pre">&quot;cleanup&quot;]</span></code>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="unittest.FunctionTestCase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">FunctionTestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">testFunc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setUp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tearDown</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">description</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.FunctionTestCase" title="永久链接至目标">¶</a></dt>
<dd><p>这个类实现了 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的部分接口，允许测试运行方驱动测试，但不提供可被测试代码用来检查和报告错误的方法。 这个类被用于创建使用传统测试代码的测试用例，允许它被集成到基于 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 的测试框架中。</p>
</dd></dl>

<section id="deprecated-aliases">
<span id="id1"></span><h4>已弃用的别名<a class="headerlink" href="#deprecated-aliases" title="永久链接至标题">¶</a></h4>
<p>由于历史原因，某些 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 方法具有一个或几个已目前已弃用的别名。 下表列出了它们的正确名称和已弃用的别名:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 29%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>方法名</p></th>
<th class="head"><p>已弃用的别名</p></th>
<th class="head"><p>已弃用的别名</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a></p></td>
<td><p>failUnlessEqual</p></td>
<td><p>assertEquals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual()</span></code></a></p></td>
<td><p>failIfEqual</p></td>
<td><p>assertNotEquals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a></p></td>
<td><p>failUnless</p></td>
<td><p>assert_</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a></p></td>
<td><p>failIf</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a></p></td>
<td><p>failUnlessRaises</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a></p></td>
<td><p>failUnlessAlmostEqual</p></td>
<td><p>assertAlmostEquals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a></p></td>
<td><p>failIfAlmostEqual</p></td>
<td><p>assertNotAlmostEquals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a></p></td>
<td></td>
<td><p>assertRegexpMatches</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a></p></td>
<td></td>
<td><p>assertNotRegexpMatches</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a></p></td>
<td></td>
<td><p>assertRaisesRegexp</p></td>
</tr>
</tbody>
</table>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.1 版后已移除: </span>在第二列中列出的 fail* 别名已经被弃用。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.2 版后已移除: </span>在第三列中列出的 assert* 别名已经被弃用。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.2 版后已移除: </span><code class="docutils literal notranslate"><span class="pre">assertRegexpMatches</span></code> 和 <code class="docutils literal notranslate"><span class="pre">assertRaisesRegexp</span></code> 已经被重命名为 <a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a> 和 <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.5 版后已移除: </span><code class="docutils literal notranslate"><span class="pre">assertNotRegexpMatches</span></code> 这个名称已被弃用并应改用 <a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>。</p>
</div>
</div></blockquote>
</section>
</section>
<section id="grouping-tests">
<span id="testsuite-objects"></span><h3>分组测试<a class="headerlink" href="#grouping-tests" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="unittest.TestSuite">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TestSuite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite" title="永久链接至目标">¶</a></dt>
<dd><p>这个类代表对单独测试用例和测试套件的聚合。 这个类提供给测试运行方所需的接口以允许其像任何其他测试用例一样运行。 运行一个 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 实例与对套件执行迭代来逐一运行每个测试的效果相同。</p>
<p>如果给出了 <em>tests</em>，则它必须是一个包含单独测试用例的可迭代对象或是将被用于初始构建测试套件的其他测试套件。 还有一些附加的方法会被提供用来在随后向测试集添加测试用例和测试套件。</p>
<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 对象的行为与 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 对象很相似，区别在于它们并不会真正实现一个测试。 它们会被用来将测试聚合为多个要同时运行的测试分组。 还有一些附加的方法会被用来向 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 实例添加测试:</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.addTest">
<span class="sig-name descname"><span class="pre">addTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTest" title="永久链接至目标">¶</a></dt>
<dd><p>向测试套件添加 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 或 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.addTests">
<span class="sig-name descname"><span class="pre">addTests</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTests" title="永久链接至目标">¶</a></dt>
<dd><p>将来自包含 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 和 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 实例的可迭代对象的所有测试添加到这个测试套件。</p>
<p>这等价于对 <em>tests</em> 进行迭代，并为其中的每个元素调用 <a class="reference internal" href="#unittest.TestSuite.addTest" title="unittest.TestSuite.addTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTest()</span></code></a>。</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 与 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 共享下列方法:</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.run" title="永久链接至目标">¶</a></dt>
<dd><p>运行与这个套件相关联的测试，将结果收集到作为 <em>result</em> 传入的测试结果对象中。 请注意与 <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.run()</span></code></a> 的区别，<a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> 必须传入结果对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.debug">
<span class="sig-name descname"><span class="pre">debug</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.debug" title="永久链接至目标">¶</a></dt>
<dd><p>运行与这个套件相关联的测试而不收集结果。 这允许测试所引发的异常被传递给调用方并可被用于支持在调试器中运行测试。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.countTestCases">
<span class="sig-name descname"><span class="pre">countTestCases</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.countTestCases" title="永久链接至目标">¶</a></dt>
<dd><p>返回此测试对象所提供的测试数量，包括单独的测试和子套件。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestSuite.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.__iter__" title="永久链接至目标">¶</a></dt>
<dd><p>由 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 分组的测试总是可以通过迭代来访问。 其子类可以通过重载 <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 来惰性地提供测试。 请注意此方法可在单个套件上多次被调用（例如在计数测试或相等性比较时），为此在 <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> 之前重复迭代所返回的测试对于每次调用迭代都必须相同。 在 <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> 之后，调用方不应继续访问此方法所返回的测试，除非调用方使用重载了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite._removeTestAtIndex()</span></code> 的子类来保留对测试的引用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>在较早的版本中 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 会直接访问测试而不是通过迭代，因此只重载 <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 并不足以提供所有测试。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>在较早的版本中 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 会在 <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> 之后保留对每个 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的引用。 其子类可以通过重载 <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite._removeTestAtIndex()</span></code> 来恢复此行为。</p>
</div>
</dd></dl>

<p>在 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 对象的典型应用中，<a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> 方法是由 <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> 发起调用而不是由最终用户测试来控制。</p>
</dd></dl>

</section>
<section id="loading-and-running-tests">
<h3>加载和运行测试<a class="headerlink" href="#loading-and-running-tests" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="unittest.TestLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TestLoader</span></span><a class="headerlink" href="#unittest.TestLoader" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 类可被用来基于类和模块创建测试套件。 通常，没有必要创建该类的实例；<a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 模块提供了一个可作为 <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal notranslate"><span class="pre">unittest.defaultTestLoader</span></code></a> 共享的实例。 但是，使用子类或实例允许对某些配置属性进行定制。</p>
<p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 对象具有下列属性:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestLoader.errors">
<span class="sig-name descname"><span class="pre">errors</span></span><a class="headerlink" href="#unittest.TestLoader.errors" title="永久链接至目标">¶</a></dt>
<dd><p>A list of the non-fatal errors encountered while loading tests. Not reset
by the loader at any point. Fatal errors are signalled by the relevant
method raising an exception to the caller. Non-fatal errors are also
indicated by a synthetic test that will raise the original error when
run.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 对象具有下列方法:</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.loadTestsFromTestCase">
<span class="sig-name descname"><span class="pre">loadTestsFromTestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">testCaseClass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromTestCase" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个包含在 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 所派生的 <code class="xref py py-class docutils literal notranslate"><span class="pre">testCaseClass</span></code> 中的所有测试用例的测试套件。</p>
<p>会为每个由 <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> 指明的方法创建一个测试用例实例。 在默认情况下这些都是以 <code class="docutils literal notranslate"><span class="pre">test</span></code> 开头的方法名称。 如果 <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> 不返回任何方法，但 <code class="xref py py-meth docutils literal notranslate"><span class="pre">runTest()</span></code> 方法已被实现，则会为该方法创建一个单独的测试用例。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.loadTestsFromModule">
<span class="sig-name descname"><span class="pre">loadTestsFromModule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromModule" title="永久链接至目标">¶</a></dt>
<dd><p>返回包含在给定模块中的所有测试用例的测试套件。 此方法会在 <em>module</em> 中搜索从派生自 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的类并为该类定义的每个测试方法创建一个类实例。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>虽然使用 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 所派生的类的层级结构可以方便地共享配置和辅助函数，但在不打算直接实例化的基类上定义测试方法并不能很好地配合此方法使用。 不过，当配置有差异并且定义在子类当中时这样做还是有用处的。</p>
</div>
<p>如果一个模块提供了 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 函数则它将被调用以加载测试。 这允许模块自行定制测试加载过程。 这就称为 <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a>。 <em>pattern</em> 参数会被作为传给 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 的第三个参数。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>添加了对 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>未写入文档的非官方 <em>use_load_tests</em> 默认参数已被弃用并忽略，但是它仍然被接受以便向下兼容。 此方法现在还接受一个仅限关键字参数 <em>pattern</em>，它会被作为传给 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 的第三个参数。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.loadTestsFromName">
<span class="sig-name descname"><span class="pre">loadTestsFromName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromName" title="永久链接至目标">¶</a></dt>
<dd><p>返回由给出了字符串形式规格描述的所有测试用例组成的测试套件。</p>
<p>描述名称 <em>name</em> 是一个“带点号的名称”，它可以被解析为一个模块、一个测试用例类、一个测试用例类内部的测试方法、一个 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 实例，或者一个返回 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 或 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 实例的可调用对象。 这些检查将按在此列出的顺序执行；也就是说，一个可能的测试用例类上的方法将作为“一个测试用例内部的测试方法”而非作为“一个可调用对象”被选定。</p>
<p>举例来说，如果你有一个模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">SampleTests</span></code>，其中包含一个派生自 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的类 <code class="xref py py-class docutils literal notranslate"><span class="pre">SampleTestCase</span></code>，其中包含三个测试方法 (<code class="xref py py-meth docutils literal notranslate"><span class="pre">test_one()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_two()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_three()</span></code>)。 则描述名称 <code class="docutils literal notranslate"><span class="pre">'SampleTests.SampleTestCase'</span></code> 将使此方法返回一个测试套件，它将运行全部三个测试方法。 使用描述名称 <code class="docutils literal notranslate"><span class="pre">'SampleTests.SampleTestCase.test_two'</span></code> 将使它返回一个测试套件，它将仅运行 <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_two()</span></code> 测试方法。 描述名称可以指向尚未被导入的模块和包；它们将作为附带影响被导入。</p>
<p>本模块可以选择相对于给定的 <em>module</em> 来解析 <em>name</em>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>如果在遍历 <em>name</em> 时发生了 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 或 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 则在运行时引发该错误的合成测试将被返回。 这些错误被包括在由 self.errors 所积累的错误中。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.loadTestsFromNames">
<span class="sig-name descname"><span class="pre">loadTestsFromNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromNames" title="永久链接至目标">¶</a></dt>
<dd><p>类似于 <a class="reference internal" href="#unittest.TestLoader.loadTestsFromName" title="unittest.TestLoader.loadTestsFromName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFromName()</span></code></a>，但是接受一个名称序列而不是单个名称。 返回值是一个测试套件，它支持为每个名称所定义的所有测试。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.getTestCaseNames">
<span class="sig-name descname"><span class="pre">getTestCaseNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">testCaseClass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.getTestCaseNames" title="永久链接至目标">¶</a></dt>
<dd><p>返回由 <em>testCaseClass</em> 中找到的方法名称组成的已排序的序列；这应当是 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestLoader.discover">
<span class="sig-name descname"><span class="pre">discover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test*.py'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_level_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.discover" title="永久链接至目标">¶</a></dt>
<dd><p>通过从指定的开始目录向其子目录递归来找出所有测试模块，并返回一个包含该结果的 TestSuite 对象。 只有与 <em>pattern</em> 匹配的测试文件才会被加载。 （使用 shell 风格的模式匹配。） 只有可导入的模块名称（即有效的 Python 标识符）将会被加载。</p>
<p>所有测试模块都必须可以从项目的最高层级上导入。 如果起始目录不是最高层级目录则必须单独指明最高层级目录。</p>
<p>如果导入某个模块失败，比如因为存在语法错误，则会将其记录为单独的错误并将继续查找模块。 如果导入失败是因为引发了 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>，则会将其记录为跳过而不是错误。</p>
<p>如果找到了一个包（即包含名为 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 的文件的目录），则将在包中查找 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 函数。 如果存在此函数则将对其执行调用 <code class="docutils literal notranslate"><span class="pre">package.load_tests(loader,</span> <span class="pre">tests,</span> <span class="pre">pattern)</span></code>。 测试发现操作会确保在执行期间仅检查测试一次，即使 load_tests 函数本身调用了 <code class="docutils literal notranslate"><span class="pre">loader.discover</span></code> 也是如此。.</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 存在则发现操作 <em>不会</em> 对包执行递归处理，<code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 将负责加载包中的所有测试。is responsible for loading all tests in the package.</p>
<p>模式特意地不被当作 loader 属性来保存以使包能够自己继续执行发现操作。 <em>top_level_dir</em> 则会被保存以使 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 不需要将此参数传入到 <code class="docutils literal notranslate"><span class="pre">loader.discover()</span></code>。</p>
<p><em>start_dir</em> 可以是一个带点号的名称或是一个目录。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>在导入时引发 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> 的模块会被记录为跳过，而不是错误。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span><em>start_dir</em> 可以是一个 <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">命名空间包</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>路径在被导入之前会先被排序以使得执行顺序保持一致，即使下层文件系统的顺序不是取决于文件名的。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>现在 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 会检查已找到的包，无论它们的路径是否与 <em>pattern</em> 匹配，因为包名称是无法与默认的模式匹配的。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版更改: </span><em>start_dir</em> can not be a <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">namespace packages</span></a>.
It has been broken since Python 3.7 and Python 3.11 officially remove it.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 的下列属性可通过子类化或在实例上赋值来配置:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestLoader.testMethodPrefix">
<span class="sig-name descname"><span class="pre">testMethodPrefix</span></span><a class="headerlink" href="#unittest.TestLoader.testMethodPrefix" title="永久链接至目标">¶</a></dt>
<dd><p>给出将被解读为测试方法的方法名称的前缀的字符串。 默认值为 <code class="docutils literal notranslate"><span class="pre">'test'</span></code>。</p>
<p>这会影响 <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> 以及所有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> 方法。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestLoader.sortTestMethodsUsing">
<span class="sig-name descname"><span class="pre">sortTestMethodsUsing</span></span><a class="headerlink" href="#unittest.TestLoader.sortTestMethodsUsing" title="永久链接至目标">¶</a></dt>
<dd><p>将被用来在 <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> 以及所有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> 方法中比较方法名称以便对它们进行排序。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestLoader.suiteClass">
<span class="sig-name descname"><span class="pre">suiteClass</span></span><a class="headerlink" href="#unittest.TestLoader.suiteClass" title="永久链接至目标">¶</a></dt>
<dd><p>根据一个测试列表来构造测试套件的可调用对象。 不需要结果对象上的任何方法。 默认值为 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 类。</p>
<p>这会影响所有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> 方法。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestLoader.testNamePatterns">
<span class="sig-name descname"><span class="pre">testNamePatterns</span></span><a class="headerlink" href="#unittest.TestLoader.testNamePatterns" title="永久链接至目标">¶</a></dt>
<dd><p>由 Unix shell 风格通配符的测试名称模式组成的列表，供测试方法进行匹配以包括在测试套件中（参见 <code class="docutils literal notranslate"><span class="pre">-v</span></code> 选项）。</p>
<p>如果该属性不为 <code class="docutils literal notranslate"><span class="pre">None</span></code> (默认值)，则将要包括在测试套件中的所有测试方法都必须匹配该列表中的某个模式。 请注意匹配总是使用 <a class="reference internal" href="fnmatch.html#fnmatch.fnmatchcase" title="fnmatch.fnmatchcase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fnmatch.fnmatchcase()</span></code></a> 来执行，因此不同于传给 <code class="docutils literal notranslate"><span class="pre">-v</span></code> 选项的模式，简单的子字符串模式将必须使用 <code class="docutils literal notranslate"><span class="pre">*</span></code> 通配符来进行转换。</p>
<p>这会影响所有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> 方法。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="unittest.TestResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TestResult</span></span><a class="headerlink" href="#unittest.TestResult" title="永久链接至目标">¶</a></dt>
<dd><p>这个类被用于编译有关哪些测试执行成功而哪些失败的信息。</p>
<p>存放一组测试的结果的 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 对象。 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 和 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 类将确保结果被正确地记录；测试创建者无须担心如何记录测试的结果。</p>
<p>建立在 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 之上的测试框架可能会想要访问通过运行一组测试所产生的 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 对象用来报告信息；<code class="xref py py-meth docutils literal notranslate"><span class="pre">TestRunner.run()</span></code> 方法是出于这个目的而返回 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 实例的。</p>
<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 实例具有下列属性，在检查运行一组测试的结果的时候很有用处。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.errors">
<span class="sig-name descname"><span class="pre">errors</span></span><a class="headerlink" href="#unittest.TestResult.errors" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例和保存了格式化回溯信息的字符串 2 元组的列表。 每个元组代表一个引发了非预期的异常的测试。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.failures">
<span class="sig-name descname"><span class="pre">failures</span></span><a class="headerlink" href="#unittest.TestResult.failures" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例和保存了格式化回溯信息的字符串 2 元组的列表。 每个元组代表一个使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.assert*()</span></code> 方法显式地发出失败信号的测试。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.skipped">
<span class="sig-name descname"><span class="pre">skipped</span></span><a class="headerlink" href="#unittest.TestResult.skipped" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例和保存了跳过测试原因的字符串 2 元组的列表。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.expectedFailures">
<span class="sig-name descname"><span class="pre">expectedFailures</span></span><a class="headerlink" href="#unittest.TestResult.expectedFailures" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例和保存了格式化回溯信息的 2 元组的列表。 每个元组代表测试用例的一个已预期的失败或错误。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.unexpectedSuccesses">
<span class="sig-name descname"><span class="pre">unexpectedSuccesses</span></span><a class="headerlink" href="#unittest.TestResult.unexpectedSuccesses" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含被标记为已预期失败，但却测试成功的 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例的列表。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.shouldStop">
<span class="sig-name descname"><span class="pre">shouldStop</span></span><a class="headerlink" href="#unittest.TestResult.shouldStop" title="永久链接至目标">¶</a></dt>
<dd><p>当测试的执行应当被 <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> 停止时则设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.testsRun">
<span class="sig-name descname"><span class="pre">testsRun</span></span><a class="headerlink" href="#unittest.TestResult.testsRun" title="永久链接至目标">¶</a></dt>
<dd><p>目前已运行的测试的总数量。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.buffer">
<span class="sig-name descname"><span class="pre">buffer</span></span><a class="headerlink" href="#unittest.TestResult.buffer" title="永久链接至目标">¶</a></dt>
<dd><p>如果设为真值，<code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 将在 <a class="reference internal" href="#unittest.TestResult.startTest" title="unittest.TestResult.startTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTest()</span></code></a> 和 <a class="reference internal" href="#unittest.TestResult.stopTest" title="unittest.TestResult.stopTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stopTest()</span></code></a> 被调用之间被缓冲。 被收集的输出将仅在测试失败或发生错误时才会被回显到真正的 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>。 任何输出还会被附加到失败/错误消息中。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.failfast">
<span class="sig-name descname"><span class="pre">failfast</span></span><a class="headerlink" href="#unittest.TestResult.failfast" title="永久链接至目标">¶</a></dt>
<dd><p>如果设为真值则 <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> 将在首次失败或错误时被调用，停止测试运行。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="unittest.TestResult.tb_locals">
<span class="sig-name descname"><span class="pre">tb_locals</span></span><a class="headerlink" href="#unittest.TestResult.tb_locals" title="永久链接至目标">¶</a></dt>
<dd><p>如果设为真值则局部变量将被显示在回溯信息中。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.wasSuccessful">
<span class="sig-name descname"><span class="pre">wasSuccessful</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.wasSuccessful" title="永久链接至目标">¶</a></dt>
<dd><p>如果当前所有测试都已通过则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>如果有任何来自测试的 <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unexpectedSuccesses</span></code></a> 被 <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> 装饰器所标记则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.stop">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stop" title="永久链接至目标">¶</a></dt>
<dd><p>此方法可被调用以提示正在运行的测试集要将 <a class="reference internal" href="#unittest.TestResult.shouldStop" title="unittest.TestResult.shouldStop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shouldStop</span></code></a> 属性设为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 来表示其应当被中止。 <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> 对象应当认同此旗标并返回而不再运行任何额外的测试。</p>
<p>例如，该特性会被 <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestRunner</span></code></a> 类用来在当用户从键盘发出一个中断信号时停止测试框架。 提供了 <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> 实现的交互式工具也可通过类似方式来使用该特性。</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 类的下列方法被用于维护内部数据结构，并可在子类中被扩展以支持额外的报告需求。 这特别适用于构建支持在运行测试时提供交互式报告的工具。</p>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.startTest">
<span class="sig-name descname"><span class="pre">startTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTest" title="永久链接至目标">¶</a></dt>
<dd><p>当测试用例 <em>test</em> 即将运行时被调用。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.stopTest">
<span class="sig-name descname"><span class="pre">stopTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTest" title="永久链接至目标">¶</a></dt>
<dd><p>在测试用例 <em>test</em> 已经执行后被调用，无论其结果如何。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.startTestRun">
<span class="sig-name descname"><span class="pre">startTestRun</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTestRun" title="永久链接至目标">¶</a></dt>
<dd><p>在任何测试被执行之前被调用一次。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.stopTestRun">
<span class="sig-name descname"><span class="pre">stopTestRun</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTestRun" title="永久链接至目标">¶</a></dt>
<dd><p>在所有测试被执行之后被调用一次。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addError">
<span class="sig-name descname"><span class="pre">addError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addError" title="永久链接至目标">¶</a></dt>
<dd><p>当测试用例 <em>test</em> 引发了非预期的异常时将被调用。 <em>err</em> 是一个元组，其形式与 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 的返回值相同: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>。</p>
<p>默认实现会将一个元组 <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> 添加到实例的 <a class="reference internal" href="#unittest.TestResult.errors" title="unittest.TestResult.errors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errors</span></code></a> 属性，其中 <em>formatted_err</em> 是派生自 <em>err</em> 的已格式化回溯信息。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addFailure">
<span class="sig-name descname"><span class="pre">addFailure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addFailure" title="永久链接至目标">¶</a></dt>
<dd><p>当测试用例 <em>test</em> 发出了失败信号时将被调用。 <em>err</em> 是一个元组，其形式与 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 的返回值相同: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>。</p>
<p>默认实现会将一个元组 <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> 添加到实例的 <a class="reference internal" href="#unittest.TestResult.failures" title="unittest.TestResult.failures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">failures</span></code></a> 属性，其中 <em>formatted_err</em> 是派生自 <em>err</em> 的已格式化回溯信息。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addSuccess">
<span class="sig-name descname"><span class="pre">addSuccess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSuccess" title="永久链接至目标">¶</a></dt>
<dd><p>当测试用例 <em>test</em> 成功时被调用。</p>
<p>默认实现将不做任何操作。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addSkip">
<span class="sig-name descname"><span class="pre">addSkip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reason</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSkip" title="永久链接至目标">¶</a></dt>
<dd><p>当测试用例 <em>test</em> 被跳过时将被调用。 <em>reason</em> 是给出的跳过测试的理由。</p>
<p>默认实现会将一个元组 <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">reason)</span></code> 添加到实例的 <a class="reference internal" href="#unittest.TestResult.skipped" title="unittest.TestResult.skipped"><code class="xref py py-attr docutils literal notranslate"><span class="pre">skipped</span></code></a> 属性。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addExpectedFailure">
<span class="sig-name descname"><span class="pre">addExpectedFailure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addExpectedFailure" title="永久链接至目标">¶</a></dt>
<dd><p>当测试用例 <em>test</em> 失败或发生错误，但是使用了 <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> 装饰器来标记时将被调用。</p>
<p>默认实现会将一个元组 <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> 添加到实例的 <a class="reference internal" href="#unittest.TestResult.expectedFailures" title="unittest.TestResult.expectedFailures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">expectedFailures</span></code></a> 属性，其中 <em>formatted_err</em> 是派生自 <em>err</em> 的已格式化回溯信息。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addUnexpectedSuccess">
<span class="sig-name descname"><span class="pre">addUnexpectedSuccess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addUnexpectedSuccess" title="永久链接至目标">¶</a></dt>
<dd><p>当测试用例 <em>test</em> 使用了was marked with the <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> 装饰器来标记，但是却执行成功时将被调用。</p>
<p>默认实现会将该测试添加到实例的 <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unexpectedSuccesses</span></code></a> 属性。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TestResult.addSubTest">
<span class="sig-name descname"><span class="pre">addSubTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subtest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSubTest" title="永久链接至目标">¶</a></dt>
<dd><p>当一个子测试结束时将被调用。 <em>test</em> 是对应于该测试方法的测试用例。 <em>subtest</em> 是一个描述该子测试的 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例。</p>
<p>如果 <em>outcome</em> 为 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>，则该子测试执行成功。 否则，它将失败并引发一个异常，<em>outcome</em> 是一个元组，其形式与 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 的返回值相同: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>。</p>
<p>默认实现在测试结果为成功时将不做任何事，并会将子测试的失败记录为普通的失败。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="unittest.TextTestResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TextTestResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descriptions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestResult" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 的一个具体实现，由 <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestRunner</span></code></a> 使用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能: </span>这个类在之前被命名为 <code class="docutils literal notranslate"><span class="pre">_TextTestResult</span></code>。 这个旧名字仍然作为别名存在，但已被弃用。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="unittest.defaultTestLoader">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">defaultTestLoader</span></span><a class="headerlink" href="#unittest.defaultTestLoader" title="永久链接至目标">¶</a></dt>
<dd><p>用于分享的 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 类实例。 如果不需要自制 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a>，则可以使用该实例而不必重复创建新的实例。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="unittest.TextTestRunner">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">TextTestRunner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descriptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">failfast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resultclass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warnings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tb_locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner" title="永久链接至目标">¶</a></dt>
<dd><p>一个将结果输出到流的基本测试运行器。 如果 <em>stream</em> 为默认的 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则会使用 <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> 作为输出流。 这个类具有一些配置形参，但实际上都非常简单。 运行测试套件的图形化应用程序应当提供替代实现。 这样的实现应当在添加新特性到 unittest 时接受 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 作为修改构造运行器的接口。</p>
<p>在默认情况下这个运行器会显示 <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>, <a class="reference internal" href="exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>, <a class="reference internal" href="exceptions.html#ResourceWarning" title="ResourceWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceWarning</span></code></a> 和 <a class="reference internal" href="exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>，即使它们 <a class="reference internal" href="warnings.html#warning-ignored"><span class="std std-ref">被默认忽略</span></a>。 由 <a class="reference internal" href="#deprecated-aliases"><span class="std std-ref">deprecated unittest methods</span></a> 所导致的弃用警告也会被作为特例，并且当警告过滤器为 <code class="docutils literal notranslate"><span class="pre">'default'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'always'</span></code> 时，对于每个模块它们将仅显示一次，以避免过多的警告消息。 此种行为可使用 Python 的 <code class="xref std std-option docutils literal notranslate"><span class="pre">-Wd</span></code> 或 <code class="xref std std-option docutils literal notranslate"><span class="pre">-Wa</span></code> 选项 (参见 <a class="reference internal" href="../using/cmdline.html#using-on-warnings"><span class="std std-ref">警告控制</span></a>) 并让 <em>warnings</em> 保持为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 来覆盖。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>增加了 <code class="docutils literal notranslate"><span class="pre">warnings</span></code> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>默认流会在实例化而不是在导入时被设为 <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>增加了 tb_locals 形参。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="unittest.TextTestRunner._makeResult">
<span class="sig-name descname"><span class="pre">_makeResult</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner._makeResult" title="永久链接至目标">¶</a></dt>
<dd><p>此方法将返回由 <a class="reference internal" href="#unittest.TextTestRunner.run" title="unittest.TextTestRunner.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> 使用的 <code class="docutils literal notranslate"><span class="pre">TestResult</span></code> 实例。 它不应当被直接调用，但可在子类中被重载以提供自定义的 <code class="docutils literal notranslate"><span class="pre">TestResult</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">_makeResult()</span></code> 会实例化传给 <code class="docutils literal notranslate"><span class="pre">TextTestRunner</span></code> 构造器的 <code class="docutils literal notranslate"><span class="pre">resultclass</span></code> 参数所指定的类或可迭代对象。 如果没有提供 <code class="docutils literal notranslate"><span class="pre">resultclass</span></code> 则默认为 <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestResult</span></code></a>。 结果类会使用以下参数来实例化:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">stream</span><span class="p">,</span> <span class="n">descriptions</span><span class="p">,</span> <span class="n">verbosity</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.TextTestRunner.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner.run" title="永久链接至目标">¶</a></dt>
<dd><p>此方法是 <code class="docutils literal notranslate"><span class="pre">TextTestRunner</span></code> 的主要公共接口。 此方法接受一个 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 或 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 实例。 通过调用 <a class="reference internal" href="#unittest.TextTestRunner._makeResult" title="unittest.TextTestRunner._makeResult"><code class="xref py py-func docutils literal notranslate"><span class="pre">_makeResult()</span></code></a> 创建 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 来运行测试并将结果打印到标准输出。</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.main">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">main</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'__main__'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">defaultTest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">argv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testRunner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testLoader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">unittest.defaultTestLoader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">failfast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">catchbreak</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warnings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.main" title="永久链接至目标">¶</a></dt>
<dd><p>从 <em>module</em> 加载一组测试并运行它们的命令行程序；这主要是为了让测试模块能方便地执行。 此函数的最简单用法是在测试脚本末尾包括下列行:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>你可以通过传入冗余参数运行测试以获得更详细的信息:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p><em>defaultTest</em> 参数是要运行的单个测试名称，或者如果未通过 <em>argv</em> 指定任何测试名称则是包含多个测试名称的可迭代对象。 如果未指定或为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 且未通过 <em>argv</em> 指定任何测试名称，则会运行在 <em>module</em> 中找到的所有测试。</p>
<p><em>argv</em> 参数可以是传给程序的选项列表，其中第一个元素是程序名。 如未指定或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则会使用 <a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a> 的值。</p>
<p><em>testRunner</em> 参数可以是测试运行器类或是其已创建的实例。 在默认情况下 <code class="docutils literal notranslate"><span class="pre">main</span></code> 会调用 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 并附带一个退出码来指明测试运行是成功还是失败。</p>
<p><em>testLoader</em> 参数必须是一个 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 实例，其默认值为 <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal notranslate"><span class="pre">defaultTestLoader</span></code></a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">main</span></code> 支持通过传入 <code class="docutils literal notranslate"><span class="pre">exit=False</span></code> 参数以便在交互式解释器中使用。 这将在标准输出中显示结果而不调用 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">main</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s1">&#39;test_module&#39;</span><span class="p">,</span> <span class="n">exit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><em>failfast</em>, <em>catchbreak</em> 和 <em>buffer</em> 形参的效果与同名的 <a class="reference internal" href="#command-line-options">command-line options</a> 一致。</p>
<p><em>warnings</em> 参数指定在运行测试时所应使用的 <a class="reference internal" href="warnings.html#warning-filter"><span class="std std-ref">警告过滤器</span></a>。 如果未指定，则默认的 <code class="docutils literal notranslate"><span class="pre">None</span></code> 会在将 <code class="xref std std-option docutils literal notranslate"><span class="pre">-W</span></code> 选项传给 <strong class="program">python</strong> 命令时被保留 (参见 <a class="reference internal" href="../using/cmdline.html#using-on-warnings"><span class="std std-ref">警告控制</span></a>)，而在其他情况下将被设为 <code class="docutils literal notranslate"><span class="pre">'default'</span></code>。</p>
<p>调用 <code class="docutils literal notranslate"><span class="pre">main</span></code> 实际上将返回一个 <code class="docutils literal notranslate"><span class="pre">TestProgram</span></code> 类的实例。 这会把测试运行结果保存为 <code class="docutils literal notranslate"><span class="pre">result</span></code> 属性。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版更改: </span>增加了 <em>exit</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>增加了 <em>verbosity</em>, <em>failfast</em>, <em>catchbreak</em>, <em>buffer</em> 和 <em>warnings</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span><em>defaultTest</em> 形参被修改为也接受一个由测试名称组成的迭代器。</p>
</div>
</dd></dl>

<section id="load-tests-protocol">
<h4>load_tests 协议<a class="headerlink" href="#load-tests-protocol" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<p>模块或包可以通过实现一个名为 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 的函数来定制在正常测试运行或测试发现期间要如何从中加载测试。</p>
<p>如果一个测试模块定义了 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 则它将被 <a class="reference internal" href="#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.loadTestsFromModule()</span></code></a> 调用并传入下列参数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>其中 <em>pattern</em> 会通过 <code class="docutils literal notranslate"><span class="pre">loadTestsFromModule</span></code> 传入。 它的默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>它应当返回一个 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>。</p>
<p><em>loader</em> 是执行载入操作的 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 实例。 <em>standard_tests</em> 是默认要从该模块载入的测试。 测试模块通常只需从标准测试集中添加或移除测试。 第三个参数是在作为测试发现的一部分载入包时使用的。</p>
<p>一个从指定 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 类集合中载入测试的 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 函数看起来可能是这样的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_cases</span> <span class="o">=</span> <span class="p">(</span><span class="n">TestCase1</span><span class="p">,</span> <span class="n">TestCase2</span><span class="p">,</span> <span class="n">TestCase3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">TestSuite</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">test_class</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">test_class</span><span class="p">)</span>
        <span class="n">suite</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>如果发现操作是在一个包含包的目录中开始的，不论是通过命令行还是通过调用 <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.discover()</span></code></a>，则将在包 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 中检查 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>。 如果不存在此函数，则发现将在包内部执行递归，就像它是另一个目录一样。 在其他情况下，包中测试的发现操作将留给 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 执行，它将附带下列参数被调用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>这应当返回代表包中所有测试的 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>。 (<code class="docutils literal notranslate"><span class="pre">standard_tests</span></code> 将只包含从 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 获取的测试。)</p>
<p>因为模式已被传入 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 所以包可以自由地继续（还可能修改）测试发现操作。 针对一个测试包的 '无操作' <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 函数看起来是这样的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="c1"># top level directory cached on loader instance</span>
    <span class="n">this_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="n">package_tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">discover</span><span class="p">(</span><span class="n">start_dir</span><span class="o">=</span><span class="n">this_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">standard_tests</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">package_tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">standard_tests</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>发现操作不会再检查包名称是否匹配 <em>pattern</em>，因为包名称不可能匹配默认的模式。</p>
</div>
</section>
</section>
</section>
<section id="class-and-module-fixtures">
<h2>类与模块设定<a class="headerlink" href="#class-and-module-fixtures" title="永久链接至标题">¶</a></h2>
<p>类与模块设定是在 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 中实现的。 当测试套件遇到来自新类的测试时则来自之前的类（如果存在）的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code> 会被调用，然后再调用来自新类的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code>。</p>
<p>类似地如果测试是来自之前的测试的另一个模块则来自之前模块的 <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code> 将被运行，然后再运行来自新模块的 <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code>。</p>
<p>在所有测试运行完毕后最终的 <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code> 将被运行。</p>
<p>请注意共享设定不适用于一些 [潜在的] 特性例如测试并行化并且它们会破坏测试隔离。 它们应当被谨慎地使用。</p>
<p>由 unittest 测试加载器创建的测试的默认顺序是将所有来自相同模块和类的测试归入相同分组。 这将导致 <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> / <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code> (等) 对于每个类和模块都恰好被调用一次。 如果你将顺序随机化，以便使得来自不同模块和类的测试彼此相邻，那么这些共享的设定函数就可能会在一次测试运行中被多次调用。</p>
<p>共享的设定不适用与非标准顺序的套件。 对于不想支持共享设定的框架来说 <code class="docutils literal notranslate"><span class="pre">BaseTestSuite</span></code> 仍然可用。</p>
<p>如果在共享的设定函数中引发了任何异常则测试将被报告错误。 因为没有对应的测试实例，所以会创建一个 <code class="docutils literal notranslate"><span class="pre">_ErrorHolder</span></code> 对象（它具有与 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 相同的接口）来代表该错误。 如果你只是使用标准 unittest 测试运行器那么这个细节并不重要，但是如果你是一个框架开发者那么这可能会有关系。</p>
<section id="setupclass-and-teardownclass">
<h3>setUpClass 和 tearDownClass<a class="headerlink" href="#setupclass-and-teardownclass" title="永久链接至标题">¶</a></h3>
<p>这些必须被实现为类方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">createExpensiveConnectionObject</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你希望在基类上的 <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> 被调用则你必须自己云调用它们。 在 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 中的实现是空的。</p>
<p>如果在 <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> 中引发了异常则类中的测试将不会被运行并且 <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> 也不会被运行。 跳过的类中的 <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> 或 <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> 将不会被运行。 如果引发的异常是 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> 异常则类将被报告为已跳过而非发生错误。</p>
</section>
<section id="setupmodule-and-teardownmodule">
<h3>setUpModule 和 tearDownModule<a class="headerlink" href="#setupmodule-and-teardownmodule" title="永久链接至标题">¶</a></h3>
<p>这些应当被实现为函数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setUpModule</span><span class="p">():</span>
    <span class="n">createConnection</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">tearDownModule</span><span class="p">():</span>
    <span class="n">closeConnection</span><span class="p">()</span>
</pre></div>
</div>
<p>如果在 <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code> 中引发了异常则模块中的任何测试都将不会被运行并且 <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code> 也不会被运行。 如果引发的异常是 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> 异常则模块将被报告为已跳过而非发生错误。</p>
<p>要添加即使在发生异常时也必须运行的清理代码，请使用 <code class="docutils literal notranslate"><span class="pre">addModuleCleanup</span></code>:</p>
<dl class="py function">
<dt class="sig sig-object py" id="unittest.addModuleCleanup">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">addModuleCleanup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.addModuleCleanup" title="永久链接至目标">¶</a></dt>
<dd><p>在 <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> 之后添加一个要调用的函数来清理测试类运行期间所使用的资源。 函数将按它们被添加的相反顺序被调用 (<abbr title="last-in, first-out">LIFO</abbr>)。 它们在调用时将附带它们被添加时传给 <a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a> 的任何参数和关键字参数。</p>
<p>如果 <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpModule()</span></code> 失败，即意味着 <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> 未被调用，则已添加的任何清理函数仍将被调用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unittest.enterModuleContext">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">enterModuleContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.enterModuleContext" title="永久链接至目标">¶</a></dt>
<dd><p>Enter the supplied <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a>.  If successful, also
add its <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> method as a cleanup function by
<a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-func docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a> and return the result of the
<a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.11 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.doModuleCleanups">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">doModuleCleanups</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.doModuleCleanups" title="永久链接至目标">¶</a></dt>
<dd><p>此函数会在 <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> 之后无条件地被调用，或者如果 <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code> 引发了异常则会在 <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code> 之后被调用。</p>
<p>它将负责调用由It is responsible for calling all the cleanup functions added by <a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-func docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a> 添加的所有清理函数。 如果你需要在 <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> <em>之前</em> 调用清理函数则可以自行调用 <a class="reference internal" href="#unittest.doModuleCleanups" title="unittest.doModuleCleanups"><code class="xref py py-func docutils literal notranslate"><span class="pre">doModuleCleanups()</span></code></a>。</p>
<p><a class="reference internal" href="#unittest.doModuleCleanups" title="unittest.doModuleCleanups"><code class="xref py py-func docutils literal notranslate"><span class="pre">doModuleCleanups()</span></code></a> 每次会弹出清理函数栈中的一个方法，因此它可以在任何时候被调用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="signal-handling">
<h2>信号处理<a class="headerlink" href="#signal-handling" title="永久链接至标题">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<p>unittest 的 <a class="reference internal" href="#cmdoption-unittest-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c/--catch</span></code></a> 命令行选项，加上 <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">catchbreak</span></code> 形参，提供了在测试运行期间处理 control-C 的更友好方式。 在捕获中断行为被启用时 control-C 将允许当前运行的测试能够完成，而测试运行将随后结束并报告已有的全部结果。 第二个 control-C 将会正常地引发 <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>。</p>
<p>处理 control-C 信号的句柄会尝试与安装了自定义 <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> 处理句柄的测试代码保持兼容。 如果是 <code class="docutils literal notranslate"><span class="pre">unittest</span></code> 处理句柄而 <em>不是</em> 已安装的 <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> 处理句柄被调用，即它被系统在测试的下层替换并委托处理，则它会调用默认的处理句柄。 这通常会是替换了已安装处理句柄并委托处理的代码所预期的行为。 对于需要禁用 <code class="docutils literal notranslate"><span class="pre">unittest</span></code> control-C 处理的单个测试则可以使用 <a class="reference internal" href="#unittest.removeHandler" title="unittest.removeHandler"><code class="xref py py-func docutils literal notranslate"><span class="pre">removeHandler()</span></code></a> 装饰器。</p>
<p>还有一些工具函数让框架开发者可以在测试框架内部启用 control-C 处理功能。</p>
<dl class="py function">
<dt class="sig sig-object py" id="unittest.installHandler">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">installHandler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.installHandler" title="永久链接至目标">¶</a></dt>
<dd><p>安装 control-C 处理句柄。 当接收到 <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> 时（通常是响应用户按下 control-C）所有已注册的结果都会执行 <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> 调用。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.registerResult">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">registerResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.registerResult" title="永久链接至目标">¶</a></dt>
<dd><p>注册一个 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 对象用于 control-C 的处理。 注册一个结果将保存指向它的弱引用，因此这并不能防止结果被作为垃圾回收。</p>
<p>如果 control-C 未被启用则注册 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 对象将没有任何附带影响，因此不论是否启用了该项处理测试框架都可以无条件地注册他们独立创建的所有结果。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.removeResult">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">removeResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeResult" title="永久链接至目标">¶</a></dt>
<dd><p>移除一个已注册的结果。 一旦结果被移除则 <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> 将不再会作为针对 control-C 的响应在结果对象上被调用。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unittest.removeHandler">
<span class="sig-prename descclassname"><span class="pre">unittest.</span></span><span class="sig-name descname"><span class="pre">removeHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeHandler" title="永久链接至目标">¶</a></dt>
<dd><p>当不附带任何参数被调用时此函数将移除已被安装的 control-C 处理句柄。 此函数还可被用作测试装饰器以在测试被执行时临时性地移除处理句柄:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">removeHandler</span>
<span class="k">def</span> <span class="nf">test_signal_handling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> --- 单元测试框架</a><ul>
<li><a class="reference internal" href="#basic-example">基本实例</a></li>
<li><a class="reference internal" href="#command-line-interface">命令行接口</a><ul>
<li><a class="reference internal" href="#command-line-options">命令行选项</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">探索性测试</a></li>
<li><a class="reference internal" href="#organizing-test-code">组织你的测试代码</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">复用已有的测试代码</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">跳过测试与预计的失败</a></li>
<li><a class="reference internal" href="#distinguishing-test-iterations-using-subtests">使用子测试区分测试迭代</a></li>
<li><a class="reference internal" href="#classes-and-functions">类与函数</a><ul>
<li><a class="reference internal" href="#test-cases">测试用例</a><ul>
<li><a class="reference internal" href="#deprecated-aliases">已弃用的别名</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grouping-tests">分组测试</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">加载和运行测试</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">load_tests 协议</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">类与模块设定</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">setUpClass 和 tearDownClass</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">setUpModule 和 tearDownModule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">信号处理</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="doctest.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code> --- 测试交互性的Python示例</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="unittest.mock.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> --- 模拟对象库</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/unittest.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock --- 模拟对象库"
             >下一页</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="doctest --- 测试交互性的Python示例"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >开发工具</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> --- 单元测试框架</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 11月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0创建。
    </div>

  </body>
</html>