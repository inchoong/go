
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>ctypes --- Python 的外部函数库 &#8212; Python 3.11.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="并发执行" href="concurrency.html" />
    <link rel="prev" title="errno --- 标准 errno 系统符号" href="errno.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/ctypes.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> --- Python 的外部函数库</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">ctypes 教程</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">载入动态连接库</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">操作导入的动态链接库中的函数</a></li>
<li><a class="reference internal" href="#calling-functions">调用函数</a></li>
<li><a class="reference internal" href="#fundamental-data-types">基础数据类型</a></li>
<li><a class="reference internal" href="#calling-functions-continued">调用函数，继续</a></li>
<li><a class="reference internal" href="#calling-varadic-functions">Calling varadic functions</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">使用自定义的数据类型调用函数</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">指定必选参数的类型(函数原型)</a></li>
<li><a class="reference internal" href="#return-types">返回类型</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">传递指针（或以引用方式传递形参）</a></li>
<li><a class="reference internal" href="#structures-and-unions">结构体和联合</a></li>
<li><a class="reference internal" href="#structure-union-alignment-and-byte-order">结构体/联合字段对齐及字节顺序</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">结构体和联合中的位域</a></li>
<li><a class="reference internal" href="#arrays">数组</a></li>
<li><a class="reference internal" href="#pointers">指针</a></li>
<li><a class="reference internal" href="#type-conversions">类型转换</a></li>
<li><a class="reference internal" href="#incomplete-types">不完整类型</a></li>
<li><a class="reference internal" href="#callback-functions">回调函数</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">访问 dll 的导出变量</a></li>
<li><a class="reference internal" href="#surprises">意外</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">变长数据类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">ctypes 参考手册</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">寻找动态链接库</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">加载动态链接库</a></li>
<li><a class="reference internal" href="#foreign-functions">外部函数</a></li>
<li><a class="reference internal" href="#function-prototypes">函数原型</a></li>
<li><a class="reference internal" href="#utility-functions">工具函数</a></li>
<li><a class="reference internal" href="#data-types">数据类型</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">基础数据类型</a></li>
<li><a class="reference internal" href="#structured-data-types">结构化数据类型</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">数组与指针</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="errno.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">errno</span></code> --- 标准 errno 系统符号</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="concurrency.html"
                          title="下一章">并发执行</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/ctypes.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="并发执行"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno --- 标准 errno 系统符号"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">通用操作系统服务</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> --- Python 的外部函数库</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-ctypes">
<span id="ctypes-a-foreign-function-library-for-python"></span><h1><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> --- Python 的外部函数库<a class="headerlink" href="#module-ctypes" title="永久链接至标题">¶</a></h1>
<hr class="docutils" />
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。</p>
<section id="ctypes-tutorial">
<span id="ctypes-ctypes-tutorial"></span><h2>ctypes 教程<a class="headerlink" href="#ctypes-tutorial" title="永久链接至标题">¶</a></h2>
<p>注：本教程中的示例代码使用 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 来保证它们能正确运行。 由于有些代码示例在 Linux, Windows 或 macOS 上的行为有所不同，它们在注释中包含了一些 doctest 指令。</p>
<p>注意：部分示例代码引用了 ctypes <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 类型。在 <code class="docutils literal notranslate"><span class="pre">sizeof(long)</span> <span class="pre">==</span> <span class="pre">sizeof(int)</span></code> 的平台上此类型是 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a> 的一个别名。所以，在程序输出 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a> 而不是你期望的 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 时不必感到迷惑 --- 它们实际上是同一种类型。</p>
<section id="loading-dynamic-link-libraries">
<span id="ctypes-loading-dynamic-link-libraries"></span><h3>载入动态连接库<a class="headerlink" href="#loading-dynamic-link-libraries" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 导出了 <em>cdll</em> 对象，在 Windows 系统中还导出了 <em>windll</em> 和 <em>oledll</em> 对象用于载入动态连接库。</p>
<p>通过操作这些对象的属性，你可以载入外部的动态链接库。<em>cdll</em> 载入按标准的 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 调用协议导出的函数，而 <em>windll</em> 导入的库按 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用协议调用其中的函数。 <em>oledll</em> 也按 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用协议调用其中的函数，并假定该函数返回的是 Windows <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> 错误代码，并当函数调用失败时，自动根据该代码甩出一个 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>原来在 Windows 下抛出的异常类型 <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> 现在是 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的一个别名。</p>
</div>
<p>这是一些 Windows 下的例子。注意：<code class="docutils literal notranslate"><span class="pre">msvcrt</span></code> 是微软 C 标准库，包含了大部分 C 标准函数，这些函数都是以 cdecl 调用协议进行调用的。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">)</span>  
<span class="go">&lt;WinDLL &#39;kernel32&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">)</span>      
<span class="go">&lt;CDLL &#39;msvcrt&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span>      
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows 会自动添加通常的 <code class="docutils literal notranslate"><span class="pre">.dll</span></code> 文件扩展名。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>通过 <code class="docutils literal notranslate"><span class="pre">cdll.msvcrt</span></code> 调用的标准 C 函数，可能会导致调用一个过时的，与当前 Python 所不兼容的函数。因此，请尽量使用标准的 Python 函数，而不要使用 <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code> 模块。</p>
</div>
<p>在 Linux 下，必须使用 <em>包含</em> 文件扩展名的文件名来导入共享库。因此不能简单使用对象属性的方式来导入库。因此，你可以使用方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code>，或构造 CDLL 对象来导入库。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>       
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span>                           
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="accessing-functions-from-loaded-dlls">
<span id="ctypes-accessing-functions-from-loaded-dlls"></span><h3>操作导入的动态链接库中的函数<a class="headerlink" href="#accessing-functions-from-loaded-dlls" title="永久链接至标题">¶</a></h3>
<p>通过操作dll对象的属性来操作这些函数。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">MyOwnFunction</span><span class="p">)</span>     
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">239</span>, in <span class="n">__getattr__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function &#39;MyOwnFunction&#39; not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意：Win32 系统的动态库，比如 <code class="docutils literal notranslate"><span class="pre">kernel32</span></code> 和 <code class="docutils literal notranslate"><span class="pre">user32</span></code>，通常会同时导出同一个函数的 ANSI 版本和 UNICODE 版本。UNICODE 版本通常会在名字最后以 <code class="docutils literal notranslate"><span class="pre">W</span></code> 结尾，而 ANSI 版本的则以 <code class="docutils literal notranslate"><span class="pre">A</span></code> 结尾。 win32的 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> 函数会根据一个模块名返回一个 <em>模块句柄</em>，该函数暨同时包含这样的两个版本的原型函数，并通过宏 UNICODE 是否定义，来决定宏 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> 导出的是哪个具体函数。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">ANSI</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
<span class="o">/*</span> <span class="n">UNICODE</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
</pre></div>
</div>
<p><em>windll</em> 不会通过这样的魔法手段来帮你决定选择哪一种函数，你必须显式的调用 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA</span></code> 或 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleW</span></code>，并分别使用字节对象或字符串对象作参数。</p>
<p>有时候，dlls的导出的函数名不符合 Python 的标识符规范，比如 <code class="docutils literal notranslate"><span class="pre">&quot;??2&#64;YAPAXI&#64;Z&quot;</span></code>。此时，你必须使用 <a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 方法来获得该函数。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">,</span> <span class="s2">&quot;??2@YAPAXI@Z&quot;</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows 下，有些 dll 导出的函数没有函数名，而是通过其顺序号调用。对此类函数，你也可以通过 dll 对象的数值索引来操作这些函数。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">310</span>, in <span class="n">__getitem__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function ordinal 0 not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="calling-functions">
<span id="ctypes-calling-functions"></span><h3>调用函数<a class="headerlink" href="#calling-functions" title="永久链接至标题">¶</a></h3>
<p>你可以貌似是调用其它 Python 函数那样直接调用这些函数。在这个例子中，我们调用了 <code class="docutils literal notranslate"><span class="pre">time()</span></code> 函数，该函数返回一个系统时间戳（从 Unix 时间起点到现在的秒数），而``GetModuleHandleA()`` 函数返回一个 win32 模块句柄。</p>
<p>此函数中调用的两个函数都使用了空指针（用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为空指针）:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>  
<span class="go">1150640792</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>  
<span class="go">0x1d000000</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你用 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 调用方式调用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 约定的函数，则会甩出一个异常 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。反之亦然。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with not enough arguments (4 bytes missing)</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">msvcrt</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;spam&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with too many arguments (4 bytes in excess)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你必须阅读这些库的头文件或说明文档来确定它们的正确的调用协议。</p>
<p>在 Windows 中，<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 使用 win32 结构化异常处理来防止由于在调用函数时使用非法参数导致的程序崩溃。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">OSError</span>: <span class="n">exception: access violation reading 0x00000020</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>然而，总有许多办法，通过调用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 使得 Python 程序崩溃。因此，你必须小心使用。 <a class="reference internal" href="faulthandler.html#module-faulthandler" title="faulthandler: Dump the Python traceback."><code class="xref py py-mod docutils literal notranslate"><span class="pre">faulthandler</span></code></a> 模块可以用于帮助诊断程序崩溃的原因。（比如由于错误的C库函数调用导致的段错误）。</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code>, integers, bytes objects and (unicode) strings are the only native
Python objects that can directly be used as parameters in these function calls.
<code class="docutils literal notranslate"><span class="pre">None</span></code> is passed as a C <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer, bytes objects and strings are passed
as pointer to the memory block that contains their data (<span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span></span> or
<span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span>).  Python integers are passed as the platforms default C
<span class="c-expr sig sig-inline c"><span class="kt">int</span></span> type, their value is masked to fit into the C type.</p>
<p>在我们开始调用函数前，我们必须先了解作为函数参数的 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 数据类型。</p>
</section>
<section id="fundamental-data-types">
<span id="ctypes-fundamental-data-types"></span><h3>基础数据类型<a class="headerlink" href="#fundamental-data-types" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 定义了一些和C兼容的基本数据类型：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 46%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ctypes 类型</p></th>
<th class="head"><p>C 类型</p></th>
<th class="head"><p>Python 类型</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_bool" title="ctypes.c_bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_bool</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span></p></td>
<td><p>bool (1)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span></span></p></td>
<td><p>单字符字节串对象</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="n">wchar_t</span></span></p></td>
<td><p>单字符字符串</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">short</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">int</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">long</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="n">__int64</span></span> or <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">__int64</span></span> or
<span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_size_t" title="ctypes.c_size_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_size_t</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="n">size_t</span></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ssize_t" title="ctypes.c_ssize_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ssize_t</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="n">ssize_t</span></span> or
<span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n">Py_ssize_t</span></a></span></p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_float" title="ctypes.c_float"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_float</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">float</span></span></p></td>
<td><p>float</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">double</span></span></p></td>
<td><p>float</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_longdouble" title="ctypes.c_longdouble"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longdouble</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">double</span></span></p></td>
<td><p>float</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span></span> (NUL terminated)</p></td>
<td><p>字节串对象或 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> (NUL terminated)</p></td>
<td><p>字符串或 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span></p></td>
<td><p>int 或 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li><p>构造函数接受任何具有真值的对象。</p></li>
</ol>
<p>所有这些类型都可以通过使用正确类型和值的可选初始值调用它们来创建:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c_int</span><span class="p">()</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_wchar_p</span><span class="p">(</span><span class="s2">&quot;Hello, World&quot;</span><span class="p">)</span>
<span class="go">c_wchar_p(140018365411392)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_ushort</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">c_ushort(65533)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>由于这些类型是可变的，它们的值也可以在以后更改:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">-99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当给指针类型的对象 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, <a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a> 和 <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a> 等赋值时，将改变它们所指向的 <em>内存地址</em>，而 <em>不是</em> 它们所指向的内存区域的 <em>内容</em> (这是理所当然的，因为 Python 的 bytes 对象是不可变的):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, World&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span> <span class="o">=</span> <span class="n">c_wchar_p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>
<span class="go">c_wchar_p(139966785747344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hello World</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;Hi, there&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>              <span class="c1"># the memory location has changed</span>
<span class="go">c_wchar_p(139966783348904)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hi, there</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                <span class="c1"># first object is unchanged</span>
<span class="go">Hello, World</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>但你要注意不能将它们传递给会改变指针所指内存的函数。如果你需要可改变的内存块，ctypes 提供了 <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> 函数，它提供多种方式创建这种内存块。当前的内存块内容可以通过 <code class="docutils literal notranslate"><span class="pre">raw</span></code> 属性存取，如果你希望将它作为NUL结束的字符串，请使用 <code class="docutils literal notranslate"><span class="pre">value</span></code> 属性:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>            <span class="c1"># create a 3 byte buffer, initialized to NUL bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">3 b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>     <span class="c1"># create a buffer containing a NUL terminated string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">6 b&#39;Hello\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># create a 10 byte buffer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hello\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hi\x00lo\x00\x00\x00\x00\x00&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> function replaces the old <code class="xref py py-func docutils literal notranslate"><span class="pre">c_buffer()</span></code>
function (which is still available as an alias).  To create a mutable memory
block containing unicode characters of the C type <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span></span>, use the
<a class="reference internal" href="#ctypes.create_unicode_buffer" title="ctypes.create_unicode_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_unicode_buffer()</span></code></a> function.</p>
</section>
<section id="calling-functions-continued">
<span id="ctypes-calling-functions-continued"></span><h3>调用函数，继续<a class="headerlink" href="#calling-functions-continued" title="永久链接至标题">¶</a></h3>
<p>注意 printf 将打印到真正标准输出设备，而*不是* <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>，因此这些实例只能在控制台提示符下工作，而不能在 <em>IDLE</em> 或 <em>PythonWin</em> 中运行。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, %S</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">42.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: TypeError: Don&#39;t know how to convert parameter 2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>正如前面所提到过的，除了整数、字符串以及字节串之外，所有的 Python 类型都必须使用它们对应的 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型包装，才能够被正确地转换为所需的C语言类型。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;An int </span><span class="si">%d</span><span class="s2">, a double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">3.14</span><span class="p">))</span>
<span class="go">An int 1234, a double 3.140000</span>
<span class="go">31</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="calling-varadic-functions">
<span id="ctypes-calling-variadic-functions"></span><h3>Calling varadic functions<a class="headerlink" href="#calling-varadic-functions" title="永久链接至标题">¶</a></h3>
<p>On a lot of platforms calling variadic functions through ctypes is exactly the same
as calling functions with a fixed number of parameters. On some platforms, and in
particular ARM64 for Apple Platforms, the calling convention for variadic functions
is different than that for regular functions.</p>
<p>On those platforms it is required to specify the <em>argtypes</em> attribute for the
regular, non-variadic, function arguments:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">]</span>
</pre></div>
</div>
<p>Because specifying the attribute does inhibit portability it is adviced to always
specify <code class="docutils literal notranslate"><span class="pre">argtypes</span></code> for all variadic functions.</p>
</section>
<section id="calling-functions-with-your-own-custom-data-types">
<span id="ctypes-calling-functions-with-own-custom-data-types"></span><h3>使用自定义的数据类型调用函数<a class="headerlink" href="#calling-functions-with-your-own-custom-data-types" title="永久链接至标题">¶</a></h3>
<p>你也可以通过自定义  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 参数转换方式来允许自定义类型作为参数。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 会寻找 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性并使用它作为函数参数。当然，它必须是数字、字符串或者二进制字符串:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bottles</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">number</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bottles</span> <span class="o">=</span> <span class="n">Bottles</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bottles</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你不想把实例的数据存储到 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性。可以通过定义 <a class="reference internal" href="functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a> 函数计算出这个属性。</p>
</section>
<section id="specifying-the-required-argument-types-function-prototypes">
<span id="ctypes-specifying-required-argument-types"></span><h3>指定必选参数的类型(函数原型)<a class="headerlink" href="#specifying-the-required-argument-types-function-prototypes" title="永久链接至标题">¶</a></h3>
<p>可以通过设置 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 属性的方法指定从 DLL 中导出函数的必选参数类型。</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 必须是一个 C 数据类型的序列 (这里的 <code class="docutils literal notranslate"><span class="pre">printf</span></code> 可能不是个好例子，因为它是变长参数，而且每个参数的类型依赖于格式化字符串，不过尝试这个功能也很方便):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">c_double</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;String &#39;</span><span class="si">%s</span><span class="s2">&#39;, Int </span><span class="si">%d</span><span class="s2">, Double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
<span class="go">String &#39;Hi&#39;, Int 10, Double 2.200000</span>
<span class="go">37</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>指定数据类型可以防止不合理的参数传递（就像 C 函数的原型），并且会自动尝试将参数转换为需要的类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: TypeError: wrong type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">X 2 3.000000</span>
<span class="go">13</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想通过自定义类型传递参数给函数，必须实现 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 类方法，才能够将此自定义类型用于 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 序列。<code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 类方法接受一个 Python 对象作为函数输入，它应该进行类型检查或者其他必要的操作以保证接收到的对象是合法的，然后返回这个对象，或者它的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性，或者其他你想要传递给 C 函数的参数。这里也一样，返回的结果必须是整型、字符串、二进制字符串、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型，或者一个具有 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性的对象。</p>
</section>
<section id="return-types">
<span id="ctypes-return-types"></span><h3>返回类型<a class="headerlink" href="#return-types" title="永久链接至标题">¶</a></h3>
<p>By default functions are assumed to return the C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> type.  Other
return types can be specified by setting the <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> attribute of the
function object.</p>
<p>这是个更高级的例子，它调用了 <code class="docutils literal notranslate"><span class="pre">strchr</span></code> 函数，这个函数接收一个字符串指针以及一个字符作为参数，返回另一个字符串指针。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">strchr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>  
<span class="go">8059983</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>    <span class="c1"># c_char_p is a pointer to a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)))</span>
<span class="go">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果希望避免上述的 <code class="docutils literal notranslate"><span class="pre">ord(&quot;x&quot;)</span></code> 调用，可以设置  <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 属性，第二个参数就会将单字符的 Python 二进制字符对象转换为 C 字符:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;def&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: TypeError: one character string expected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果外部函数返回了一个整数，你也可以使用要给可调用的 Python 对象（比如函数或者类）作为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 属性的值。将会以 C 函数返回的 <em>整数</em> 对象作为参数调用这个可调用对象，执行后的结果作为最终函数返回值。这在错误返回值校验和自动抛出异常等方面比较有用。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">ValidHandle</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ValidHandle</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">486539264</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s2">&quot;something silly&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">ValidHandle</span>
<span class="gr">OSError</span>: <span class="n">[Errno 126] The specified module could not be found.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">WinError</span></code> 函数可以调用 Windows 的  <code class="docutils literal notranslate"><span class="pre">FormatMessage()</span></code> API 获取错误码的字符串说明，然后 <em>返回</em> 一个异常。 <code class="docutils literal notranslate"><span class="pre">WinError</span></code> 接收一个可选的错误码作为参数，如果没有的话，它将调用  <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> 获取错误码。</p>
<p>请注意，使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code>  属性可以实现更强大的错误检查手段；详情请见参考手册。</p>
</section>
<section id="passing-pointers-or-passing-parameters-by-reference">
<span id="ctypes-passing-pointers"></span><h3>传递指针（或以引用方式传递形参）<a class="headerlink" href="#passing-pointers-or-passing-parameters-by-reference" title="永久链接至标题">¶</a></h3>
<p>有时候 C 函数接口可能由于要往某个地址写入值，或者数据太大不适合作为值传递，从而希望接收一个 <em>指针</em> 作为数据参数类型。这和 <em>传递参数引用</em> 类似。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 暴露了 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 函数用于通过引用传递参数，使用 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 函数也能达到同样的效果，只不过 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 需要更多步骤，因为它要先构造一个真实指针对象。所以在 Python 代码本身不需要使用这个指针对象的情况下，使用 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 效率更高。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">c_float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\000</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">0 0.0 b&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">sscanf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;1 3.14 Hello&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">byref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">byref</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">1 3.1400001049 b&#39;Hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="structures-and-unions">
<span id="ctypes-structures-unions"></span><h3>结构体和联合<a class="headerlink" href="#structures-and-unions" title="永久链接至标题">¶</a></h3>
<p>结构体和联合必须继承自 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 模块中的 <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a> 和 <a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a> 。子类必须定义 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 属性。 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 是一个二元组列表，二元组中包含 <em>field name</em> 和 <em>field type</em> 。</p>
<p>type 字段必须是一个 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型，比如  <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>，或者其他 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型: 结构体、联合、数组、指针。</p>
<p>这是一个简单的 POINT 结构体，它包含名称为 <em>x</em> 和 <em>y</em> 的两个变量，还展示了如何通过构造函数初始化结构体。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">10 20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">too many initializers</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当然，你可以构造更复杂的结构体。一个结构体可以通过设置 type 字段包含其他结构体或者自身。</p>
<p>这是以一个 RECT 结构体，他包含了两个 POINT ，分别叫 <em>upperleft</em> 和 <em>lowerright</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;upperleft&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;lowerright&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>嵌套结构体可以通过几种方式构造初始化:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>可以通过 <em>类</em> 获取字段 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> ，它能提供很多有用的调试信息。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=4, size=4&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 不支持带位域的结构体、联合以值的方式传给函数。这可能在 32 位 x86 平台上可以正常工作，但是对于一般情况，这种行为是未定义的。带位域的结构体、联合应该总是通过指针传递给函数。</p>
</div>
</section>
<section id="structure-union-alignment-and-byte-order">
<h3>结构体/联合字段对齐及字节顺序<a class="headerlink" href="#structure-union-alignment-and-byte-order" title="永久链接至标题">¶</a></h3>
<p>默认情况下，结构体和联合的字段与 C 的字节对齐是一样的。也可以在定义子类的时候指定类的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> 属性来覆盖这种行为。 它必须设置为一个正整数，表示字段的最大对齐字节。这和 MSVC 中的 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">pack(n)</span></code> 功能一样。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 中的结构体和联合使用的是本地字节序。要使用非本地字节序，可以使用 <a class="reference internal" href="#ctypes.BigEndianStructure" title="ctypes.BigEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.LittleEndianStructure" title="ctypes.LittleEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.BigEndianUnion" title="ctypes.BigEndianUnion"><code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianUnion</span></code></a>, and <a class="reference internal" href="#ctypes.LittleEndianUnion" title="ctypes.LittleEndianUnion"><code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianUnion</span></code></a> 作为基类。这些类不能包含指针字段。</p>
</section>
<section id="bit-fields-in-structures-and-unions">
<span id="ctypes-bit-fields-in-structures-unions"></span><h3>结构体和联合中的位域<a class="headerlink" href="#bit-fields-in-structures-and-unions" title="永久链接至标题">¶</a></h3>
<p>结构体和联合中是可以包含位域字段的。位域只能用于整型字段，位长度通过 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 中的第三个参数指定:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Int</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;first_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;second_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">first_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:0, bits=16&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">second_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:16, bits=16&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="arrays">
<span id="ctypes-arrays"></span><h3>数组<a class="headerlink" href="#arrays" title="永久链接至标题">¶</a></h3>
<p>数组是一个序列，包含指定个数元素，且必须类型相同。</p>
<p>创建数组类型的推荐方式是使用一个类型乘以一个正数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">TenPointsArrayType</span> <span class="o">=</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">10</span>
</pre></div>
</div>
<p>下面是一个构造的数据案例，结构体中包含了4个 POINT 和一些其他东西。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyStruct</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">c_float</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;point_array&quot;</span><span class="p">,</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">()</span><span class="o">.</span><span class="n">point_array</span><span class="p">))</span>
<span class="go">4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>和平常一样，通过调用它创建实例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">TenPointsArrayType</span><span class="p">()</span>
<span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>以上代码会打印几行 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">0</span></code> ，因为数组内容被初始化为 0.</p>
<p>也能通过指定正确类型的数据来初始化:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TenIntegers</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">TenIntegers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
<span class="go">&lt;c_long_Array_10 object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 2 3 4 5 6 7 8 9 10</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="pointers">
<span id="ctypes-pointers"></span><h3>指针<a class="headerlink" href="#pointers" title="永久链接至标题">¶</a></h3>
<p>可以将 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型数据传入 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 函数创建指针:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>指针实例拥有 <a class="reference internal" href="#ctypes._Pointer.contents" title="ctypes._Pointer.contents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">contents</span></code></a> 属性，它返回指针指向的真实对象，如上面的 <code class="docutils literal notranslate"><span class="pre">i</span></code> 对象:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(42)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 并没有 OOR （返回原始对象）, 每次访问这个属性时都会构造返回一个新的相同对象:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>将这个指针的 contents 属性赋值为另一个 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 实例将会导致该指针指向该实例的内存地址:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(99)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>指针对象也可以通过整数下标进行访问:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>通过整数下标赋值可以改变指针所指向的真实内容:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(22)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用 0 以外的索引也是合法的，但是你必须确保知道自己为什么这么做，就像 C 语言中: 你可以访问或者修改任意内存内容。 通常只会在函数接收指针是才会使用这种特性，而且你 <em>知道</em> 这个指针指向的是一个数组而不是单个值。</p>
<p>内部细节,  <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 函数不只是创建了一个指针实例，它首先创建了一个指针 <em>类型</em> 。这是通过调用 <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> 函数实现的，它接收  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型为参数，返回一个新的类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span>
<span class="go">&lt;class &#39;ctypes.LP_c_long&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">expected c_long instead of int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>无参调用指针类型可以创建一个 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针。 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针的布尔值是 <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">))</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>解引用指针的时候， <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 会帮你检测是否指针为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (但是解引用无效的 非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针仍会导致 Python 崩溃):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="type-conversions">
<span id="ctypes-type-conversions"></span><h3>类型转换<a class="headerlink" href="#type-conversions" title="永久链接至标题">¶</a></h3>
<p>通常情况下, ctypes 具有严格的类型检查。这代表着, 如果在函数 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 中或者结构体定义成员中有 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> 类型，只有相同类型的实例才会被接受。 也有一些例外。比如，你可以传递兼容的数组实例给指针类型。所以，对于  <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> ，ctypes 也可以接受 c_int 类型的数组:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_int</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>另外，如果一个函数 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 列表中的参数显式的定义为指针类型(如 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> )，指针所指向的 类型 (这个例子中是 <code class="docutils literal notranslate"><span class="pre">c_int</span></code> )也可以传递给函数。ctypes 会自动调用对应的 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 转换。</p>
<p>可以给指针内容赋值为 None 将其设置为 <code class="docutils literal notranslate"><span class="pre">Null</span></code></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>有时候你拥有一个不兼容的类型。 在 C 中，你可以将一个类型强制转换为另一个。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 中的 a <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数提供了相同的功能。 上面的结构体  <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 的 <code class="docutils literal notranslate"><span class="pre">value</span></code> 字段接收  <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> 指针或者 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 数组，但是不能接受其他类型的实例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">incompatible types, c_byte_Array_4 instance instead of LP_c_long instance</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种情况下, 需要手动使用 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数。</p>
<p><a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数可以将一个指针实例强制转换为另一种 ctypes 类型。 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 接收两个参数，一个 ctypes 指针对象或者可以被转换为指针的其他类型对象，和一个 ctypes 指针类型。 返回第二个类型的一个实例，该返回实例和第一个参数指向同一片内存空间:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>所以  <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 可以用来给结构体 <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 的 <code class="docutils literal notranslate"><span class="pre">values</span></code> 字段赋值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">((</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)(),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="incomplete-types">
<span id="ctypes-incomplete-types"></span><h3>不完整类型<a class="headerlink" href="#incomplete-types" title="永久链接至标题">¶</a></h3>
<p><em>不完整类型</em> 即还没有定义成员的结构体、联合或者数组。在 C 中，它们通常用于前置声明，然后在后面定义:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">cell</span><span class="p">;</span> <span class="o">/*</span> <span class="n">forward</span> <span class="n">declaration</span> <span class="o">*/</span>

<span class="n">struct</span> <span class="n">cell</span> <span class="p">{</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">cell</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>直接翻译成 ctypes 的代码如下，但是这行不通:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">cell</span>
<span class="gr">NameError</span>: <span class="n">name &#39;cell&#39; is not defined</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>因为新的 <code class="docutils literal notranslate"><span class="pre">cell</span> <span class="pre">类</span></code> 在 class 语句结束之前还没有完成定义。在  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 中，我们可以先定义 <code class="docutils literal notranslate"><span class="pre">cell</span></code> 类，在 class 语句结束之后再设置 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 属性:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>让我们试试。我们定义两个 <code class="docutils literal notranslate"><span class="pre">cell</span></code> 实例，让它们互相指向对方，然后通过指针链式访问几次:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;foo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">c1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">foo bar foo bar foo bar foo bar</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="callback-functions">
<span id="ctypes-callback-functions"></span><h3>回调函数<a class="headerlink" href="#callback-functions" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 允许创建一个指向 Python 可调用对象的 C 函数。它们有时候被称为 <em>回调函数</em> 。</p>
<p>首先，你必须为回调函数创建一个类，这个类知道调用约定，包括返回值类型以及函数接收的参数类型及个数。</p>
<p><a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> 工厂函数使用 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 调用约定创建回调函数类型。在 Windows 上， <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">WINFUNCTYPE()</span></code></a> 工厂函数使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定为回调函数创建类型。</p>
<p>这些工厂函数的第一个参数是返回值类型，回调函数的参数类型作为剩余参数。</p>
<p>这里展示一个使用 C 标准库函数  <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> 的例子，它使用一个回调函数对数据进行排序。 <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> 将用来给整数数组排序:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IntArray5</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ia</span> <span class="o">=</span> <span class="n">IntArray5</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">qsort</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">qsort()</span></code> 必须接收的参数，一个指向待排序数据的指针，元素个数，每个元素的大小，以及一个指向排序函数的指针，即回调函数。然后回调函数接收两个元素的指针，如果第一个元素小于第二个，则返回一个负整数，如果相等则返回0，否则返回一个正整数。</p>
<p>所以，我们的回调函数要接收两个整数指针，返回一个整数。首先我们创建回调函数的 <code class="docutils literal notranslate"><span class="pre">类型</span></code></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CMPFUNC</span> <span class="o">=</span> <span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>首先，这是一个简单的回调，它会显示传入的值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmp_func</span> <span class="o">=</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>结果:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span>  
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>现在我们可以比较两个元素并返回有用的结果了:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">))</span> 
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>我们可以轻易地验证，现在数组是有序的了:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ia</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 5 7 33 99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这些工厂函数可以当作装饰器工厂，所以可以这样写:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>请确保你维持的 <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> 对象的引用周期与它们在 C 代码中的使用期一样长。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 不会确保这一点，如果不这样做，它们可能会被垃圾回收，导致程序在执行回调函数时发生崩溃。</p>
<p>注意，如果回调函数在Python之外的另外一个线程使用(比如，外部代码调用这个回调函数)， ctypes 会在每一次调用上创建一个虚拟 Python 线程。这个行为在大多数情况下是合理的，但也意味着如果有数据使用 <a class="reference internal" href="threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a> 方式存储，将无法访问，就算它们是在同一个 C 线程中调用的 。</p>
</div>
</section>
<section id="accessing-values-exported-from-dlls">
<span id="ctypes-accessing-values-exported-from-dlls"></span><h3>访问 dll 的导出变量<a class="headerlink" href="#accessing-values-exported-from-dlls" title="永久链接至标题">¶</a></h3>
<p>一些动态链接库不仅仅导出函数，也会导出变量。一个例子就是 Python 库本身的 <a class="reference internal" href="../c-api/init.html#c.Py_OptimizeFlag" title="Py_OptimizeFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_OptimizeFlag</span></code></a> ，根据启动选项 <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 、 <a class="reference internal" href="../using/cmdline.html#cmdoption-OO"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a> 的不同，它是值可能为 0、1、2 的整型。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 可以通过  <code class="xref py py-meth docutils literal notranslate"><span class="pre">in_dll()</span></code> 类方法访问这类变量 。 <em>pythonapi</em> 是用于访问 Python C 接口的预定义符号:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opt_flag</span> <span class="o">=</span> <span class="n">c_int</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;Py_OptimizeFlag&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">opt_flag</span><span class="p">)</span>
<span class="go">c_long(0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果解释器使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 选项启动，这个例子会打印 <code class="docutils literal notranslate"><span class="pre">c_long(1)</span></code> ， 如果使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-OO"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a> 启动，则会打印 <code class="docutils literal notranslate"><span class="pre">c_long(2)</span></code> 。</p>
<p>一个扩展例子,  同时也展示了使用指针访问 Python 导出的 <a class="reference internal" href="../c-api/import.html#c.PyImport_FrozenModules" title="PyImport_FrozenModules"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyImport_FrozenModules</span></code></a> 指针对象。</p>
<p>对文档中这个值的解释说明</p>
<blockquote>
<div><p>This pointer is initialized to point to an array of <a class="reference internal" href="../c-api/import.html#c._frozen" title="_frozen"><code class="xref c c-struct docutils literal notranslate"><span class="pre">_frozen</span></code></a>
records, terminated by one whose members are all <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or zero.  When a frozen
module is imported, it is searched in this table.  Third-party code could play
tricks with this to provide a dynamically created collection of frozen modules.</p>
</div></blockquote>
<p>这足以证明修改这个指针是很有用的。为了让实例大小不至于太长，这里只展示如何使用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 读取这个表:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">struct_frozen</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;get_code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>  <span class="c1"># Function pointer</span>
<span class="gp">... </span>               <span class="p">]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>We have defined the <a class="reference internal" href="../c-api/import.html#c._frozen" title="_frozen"><code class="xref c c-struct docutils literal notranslate"><span class="pre">_frozen</span></code></a> data type, so we can get the pointer
to the table:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">FrozenTable</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">struct_frozen</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">FrozenTable</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;_PyImport_FrozenBootstrap&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>由于 <code class="docutils literal notranslate"><span class="pre">table</span></code> 是指向 <code class="docutils literal notranslate"><span class="pre">struct_frozen</span></code> 数组的 <code class="docutils literal notranslate"><span class="pre">指针</span></code> ，我们可以遍历它，只不过需要自己判断循环是否结束，因为指针本身并不包含长度。它早晚会因为访问到野指针或者什么的把自己搞崩溃，所以我们最好在遇到  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 后就让它退出循环:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">),</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">_frozen_importlib 31764</span>
<span class="go">_frozen_importlib_external 41499</span>
<span class="go">zipimport 12345</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Python 的冻结模块和冻结包(由负 <code class="docutils literal notranslate"><span class="pre">size</span></code> 成员表示)并不是广为人知的事情，它们仅仅用于实验。例如，可以使用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">__hello__</span></code> 尝试一下这个功能。</p>
</section>
<section id="surprises">
<span id="ctypes-surprises"></span><h3>意外<a class="headerlink" href="#surprises" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 也有自己的边界，有时候会发生一些意想不到的事情。</p>
<p>比如下面的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># now swap the two points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">3 4 3 4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>嗯。我们预想应该打印 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">1</span> <span class="pre">2</span></code> 。但是为什么呢? 这是 <code class="docutils literal notranslate"><span class="pre">rc.a,</span> <span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">rc.b,</span> <span class="pre">rc.a</span></code> 这行代码展开后的步骤:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temp0</span><span class="p">,</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">temp0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意 <code class="docutils literal notranslate"><span class="pre">temp0</span></code> 和 <code class="docutils literal notranslate"><span class="pre">temp1</span></code> 对象始终引用了对象 <code class="docutils literal notranslate"><span class="pre">rc</span></code> 的内容。然后执行 <code class="docutils literal notranslate"><span class="pre">rc.a</span> <span class="pre">=</span> <span class="pre">temp0</span></code> 会把 <code class="docutils literal notranslate"><span class="pre">temp0</span></code> 的内容拷贝到 <code class="docutils literal notranslate"><span class="pre">rc</span></code> 的空间。这也改变了  <code class="docutils literal notranslate"><span class="pre">temp1</span></code> 的内容。最终导致赋值语句 <code class="docutils literal notranslate"><span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">temp1</span></code> 没有产生预想的效果。</p>
<p>记住，访问被包含在结构体、联合、数组中的对象并不会将其 <em>复制</em> 出来，而是得到了一个代理对象，它是对根对象的内部内容的一层包装。</p>
<p>下面是另一个可能和预期有偏差的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">c_char_p</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;abc def ghi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">b&#39;abc def ghi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>使用  <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>  实例化的对象只能将其值设置为 bytes 或者整数。</p>
</div>
<p>为什么这里打印了 <code class="docutils literal notranslate"><span class="pre">False</span></code> ？ ctypes 实例是一些内存块加上一些用于访问这些内存块的 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> 组成。将 Python 对象存储在内存块并不会存储对象本身，而是存储了对象的 <code class="docutils literal notranslate"><span class="pre">内容</span></code> 。每次访问对象的内容都会构造一个新的 Python 对象。</p>
</section>
<section id="variable-sized-data-types">
<span id="ctypes-variable-sized-data-types"></span><h3>变长数据类型<a class="headerlink" href="#variable-sized-data-types" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 对变长数组和结构体提供了一些支持 。</p>
<p>The <a class="reference internal" href="#ctypes.resize" title="ctypes.resize"><code class="xref py py-func docutils literal notranslate"><span class="pre">resize()</span></code></a> function can be used to resize the memory buffer of an
existing ctypes object.  The function takes the object as first argument, and
the requested size in bytes as the second argument.  The memory block cannot be
made smaller than the natural memory block specified by the objects type, a
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised if this is tried:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_short</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">minimum size is 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这非常好，但是要怎么访问数组中额外的元素呢？因为数组类型已经定义包含4个元素，导致我们访问新增元素时会产生以下错误:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[:]</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">IndexError</span>: <span class="n">invalid index</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 访问变长数据类型的一个可行方法是利用 Python 的动态特性，根据具体情况，在知道这个数据的大小后，(重新)指定这个数据的类型。</p>
</section>
</section>
<section id="ctypes-reference">
<span id="ctypes-ctypes-reference"></span><h2>ctypes 参考手册<a class="headerlink" href="#ctypes-reference" title="永久链接至标题">¶</a></h2>
<section id="finding-shared-libraries">
<span id="ctypes-finding-shared-libraries"></span><h3>寻找动态链接库<a class="headerlink" href="#finding-shared-libraries" title="永久链接至标题">¶</a></h3>
<p>在编译型语言中，动态链接库会在编译、链接或者程序运行时访问。</p>
<p>The purpose of the <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> function is to locate a library in a way
similar to what the compiler or runtime loader does (on platforms with several
versions of a shared library the most recent should be loaded), while the ctypes
library loaders act like when a program is run, and call the runtime loader
directly.</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.util</span></code> 模块提供了一个函数，可以帮助确定需要加载的库。</p>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">find_library</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>尝试寻找一个库然后返回其路径名， <em>name</em> 是库名称, 且去除了 <em>lib</em> 等前缀和 <code class="docutils literal notranslate"><span class="pre">.so</span></code> 、 <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> 、版本号等后缀(这是 posix 连接器 <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code> 选项使用的格式)。如果没有找到对应的库，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
</dd></dl>

<p>确切的功能取决于系统。</p>
<p>在 Linux 上， <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> 会尝试运行外部程序(<code class="docutils literal notranslate"><span class="pre">/sbin/ldconfig</span></code>, <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, <code class="docutils literal notranslate"><span class="pre">objdump</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">ld</span></code>) 来寻找库文件。返回库文件的文件名。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>在Linux 上，如果其他方式找不到的话，会使用环境变量 <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> 搜索动态链接库。</p>
</div>
<p>这是一些例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;libm.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;libc.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;libbz2.so.1.0&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在 macOS 上，<code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> 会尝试几种预定义的命名方案和路径来定位库，如果成功则将返回完整的路径名称:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libc.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libm.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libbz2.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;AGL&quot;</span><span class="p">)</span>
<span class="go">&#39;/System/Library/Frameworks/AGL.framework/AGL&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在 Windows 上，  <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> 在系统路径中搜索，然后返回全路径，但是如果没有预定义的命名方案， <code class="docutils literal notranslate"><span class="pre">find_library(&quot;c&quot;)</span></code> 调用会返回 <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<p>使用  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 包装动态链接库，更好的方式 <em>可能</em> 是在开发的时候就确定名称，然后硬编码到包装模块中去，而不是在运行时使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> 寻找库。</p>
</section>
<section id="loading-shared-libraries">
<span id="ctypes-loading-shared-libraries"></span><h3>加载动态链接库<a class="headerlink" href="#loading-shared-libraries" title="永久链接至标题">¶</a></h3>
<p>有很多方式可以将动态链接库加载到 Python 进程。其中之一是实例化以下类的其中一个:</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.CDLL">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">CDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CDLL" title="永久链接至目标">¶</a></dt>
<dd><p>Instances of this class represent loaded shared libraries. Functions in these
libraries use the standard C calling convention, and are assumed to return
<span class="c-expr sig sig-inline c"><span class="kt">int</span></span>.</p>
<p>在 Windows 上创建 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 实例可能会失败，即使 DLL 名称确实存在。 当某个被加载 DLL 所依赖的 DLL 未找到时，将引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 错误并附带消息 <em>&quot;[WinError 126] The specified module could not be found&quot;.</em> 此错误消息不包含缺失 DLL 的名称，因为 Windows API 并不会返回此类信息，这使得此错误难以诊断。 要解决此错误并确定是哪一个 DLL 未找到，你需要找出所依赖的 DLL 列表并使用 Windows 调试与跟踪工具确定是哪一个未找到。</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference external" href="https://docs.microsoft.com/cpp/build/reference/dependents">Microsoft DUMPBIN 工具</a> -- 一个用于查找 DLL 依赖的工具。</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.OleDLL">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">OleDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.OleDLL" title="永久链接至目标">¶</a></dt>
<dd><p>仅 Windows : 此类的实例即加载好的动态链接库，其中的函数使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定，并且假定返回 windows 指定的 <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a> 返回码。 <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a> 的值包含的信息说明函数调用成功还是失败，以及额外错误码。 如果返回值表示失败，会自动抛出 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>以前是引发 <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.WinDLL">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">WinDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinDLL" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: Instances of this class represent loaded shared libraries,
functions in these libraries use the <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention, and are
assumed to return <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> by default.</p>
</dd></dl>

<p>调用动态库导出的函数之前，Python会释放 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> ，并在调用后重新获取。</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.PyDLL">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">PyDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PyDLL" title="永久链接至目标">¶</a></dt>
<dd><p>这个类实例的行为与 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 类似，只不过 <em>不会</em> 在调用函数的时候释放 GIL 锁，且调用结束后会检查 Python 错误码。 如果错误码被设置，会抛出一个 Python 异常。</p>
<p>所以，它只在直接调用 Python C 接口函数的时候有用。</p>
</dd></dl>

<p>通过使用至少一个参数（共享库的路径名）调用它们，可以实例化所有这些类。也可以传入一个已加载的动态链接库作为 <code class="docutils literal notranslate"><span class="pre">handler</span></code> 参数，其他情况会调用系统底层的  <code class="docutils literal notranslate"><span class="pre">dlopen</span></code> 或 <code class="docutils literal notranslate"><span class="pre">LoadLibrary</span></code> 函数将库加载到进程，并获取其句柄。</p>
<p><em>mode</em> 可以指定库加载方式。详情请参见  <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/dlopen(3)">dlopen(3)</a></em> 手册页。 在 Windows 上， 会忽略 <em>mode</em> ，在 posix 系统上， 总是会加上 RTLD_NOW ，且无法配置。</p>
<p><em>use_errno</em> 参数如果设置为 true，可以启用ctypes的机制，通过一种安全的方法获取系统的  <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 错误码。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 维护了一个线程局部变量，它是系统 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 的一份拷贝；如果调用了使用 <code class="docutils literal notranslate"><span class="pre">use_errno=True</span></code> 创建的外部函数， <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 的值会与 ctypes 自己拷贝的那一份进行交换，函数执行完后立即再交换一次。</p>
<p>The function <a class="reference internal" href="#ctypes.get_errno" title="ctypes.get_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_errno()</span></code></a> returns the value of the ctypes private
copy, and the function <a class="reference internal" href="#ctypes.set_errno" title="ctypes.set_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_errno()</span></code></a> changes the ctypes private copy
to a new value and returns the former value.</p>
<p><em>use_last_error</em>  参数如果设置为 true，可以在 Windows 上启用相同的策略，它是通过 Windows API 函数 <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a>  和 <code class="xref py py-func docutils literal notranslate"><span class="pre">SetLastError()</span></code> 管理的。 <a class="reference internal" href="#ctypes.get_last_error" title="ctypes.get_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_last_error()</span></code></a> 和 <a class="reference internal" href="#ctypes.set_last_error" title="ctypes.set_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_last_error()</span></code></a> 可用于获取和设置 ctypes 自己维护的 windows 错误码拷贝。</p>
<p><em>winmode</em> 参数用于在 Windows 平台上指定库的加载方式( 因为 <em>mode</em> 会被忽略)。他接受任何与 Win32 API 的 <code class="docutils literal notranslate"><span class="pre">LoadLibraryEx</span></code> 的标志兼容的值作为参数。省略时，默认设置使用最安全的DLL加载的标志，以避免DLL劫持等问题。传入 DLL 的全路径是保证正确加载库及其依赖最安全的方法。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>增加了  <em>winmode</em> 参数。</p>
</div>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">RTLD_GLOBAL</span></span></dt>
<dd><p>用于 <em>mode</em> 参数的标识值。在此标识不可用的系统上，它被定义为整数0。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">RTLD_LOCAL</span></span></dt>
<dd><p>Flag to use as <em>mode</em> parameter.  On platforms where this is not available, it
is the same as <em>RTLD_GLOBAL</em>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">DEFAULT_MODE</span></span></dt>
<dd><p>加载动态链接库的默认模式。在 OSX 10.3 上，它是 <em>RTLD_GLOBAL</em> ，其余系统上是 <em>RTLD_LOCAL</em> 。</p>
</dd></dl>

<p>这些类的实例没有共用方法。动态链接库的导出函数可以通过属性或者索引的方式访问。注意，通过属性的方式访问会缓存这个函数，因而每次访问它时返回的都是同一个对象。另一方面，通过索引访问，每次都会返回一个新的对象:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">CDLL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  <span class="c1"># On Linux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">libc</span><span class="o">.</span><span class="n">time</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>还有下面这些属性可用，他们的名称以下划线开头，以避免和导出函数重名:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.PyDLL._handle">
<span class="sig-prename descclassname"><span class="pre">PyDLL.</span></span><span class="sig-name descname"><span class="pre">_handle</span></span><a class="headerlink" href="#ctypes.PyDLL._handle" title="永久链接至目标">¶</a></dt>
<dd><p>用于访问库的系统句柄。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.PyDLL._name">
<span class="sig-prename descclassname"><span class="pre">PyDLL.</span></span><span class="sig-name descname"><span class="pre">_name</span></span><a class="headerlink" href="#ctypes.PyDLL._name" title="永久链接至目标">¶</a></dt>
<dd><p>传入构造函数的库名称。</p>
</dd></dl>

<p>共享库也可以通用使用一个预制对象来加载，这种对象是 <a class="reference internal" href="#ctypes.LibraryLoader" title="ctypes.LibraryLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">LibraryLoader</span></code></a> 类的实例，具体做法或是通过调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code> 方法，或是通过将库作为加载器实例的属性来提取。</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.LibraryLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">LibraryLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dlltype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader" title="永久链接至目标">¶</a></dt>
<dd><p>加载共享库的类。 <em>dlltype</em> 应当为 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a>, <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a>, <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> 或 <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> 类型之一。</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> 具有特殊的行为：它允许通过将一个共享库作为库加载器实例的属性进行访问来加载它。 加载结果将被缓存，因此重复的属性访问每次都会返回相同的库。</p>
<dl class="py method">
<dt class="sig sig-object py" id="ctypes.LibraryLoader.LoadLibrary">
<span class="sig-name descname"><span class="pre">LoadLibrary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader.LoadLibrary" title="永久链接至目标">¶</a></dt>
<dd><p>加载一个共享库到进程中并将其返回。 此方法总是返回一个新的库实例。</p>
</dd></dl>

</dd></dl>

<p>可用的预制库加载器有如下这些:</p>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">cdll</span></span></dt>
<dd><p>创建 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 实例。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">windll</span></span></dt>
<dd><p>仅限 Windows：创建 <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> 实例.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">oledll</span></span></dt>
<dd><p>仅限 Windows：创建 <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> 实例。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">pydll</span></span></dt>
<dd><p>创建 <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> 实例。</p>
</dd></dl>

<p>要直接访问 C Python api，可以使用一个现成的 Python 共享库对象:</p>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">pythonapi</span></span></dt>
<dd><p>An instance of <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> that exposes Python C API functions as
attributes.  Note that all these functions are assumed to return C
<span class="c-expr sig sig-inline c"><span class="kt">int</span></span>, which is of course not always the truth, so you have to assign
the correct <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> attribute to use these functions.</p>
</dd></dl>

<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.dlopen</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">name</span></code>。</p>
<p class="audit-hook">引发一个审计事件 <code class="docutils literal notranslate"><span class="pre">ctypes.dlsym</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">library</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>。</p>
<p class="audit-hook">引发一个审计事件 <code class="docutils literal notranslate"><span class="pre">ctypes.dlsym/handle</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">handle</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>。</p>
</section>
<section id="foreign-functions">
<span id="ctypes-foreign-functions"></span><h3>外部函数<a class="headerlink" href="#foreign-functions" title="永久链接至标题">¶</a></h3>
<p>正如之前小节的说明，外部函数可作为被加载共享库的属性来访问。 用此方式创建的函数对象默认接受任意数量的参数，接受任意 ctypes 数据实例作为参数，并且返回库加载器所指定的默认结果类型。 它们是一个私有类的实例:</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes._FuncPtr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_FuncPtr</span></span><a class="headerlink" href="#ctypes._FuncPtr" title="永久链接至目标">¶</a></dt>
<dd><p>C 可调用外部函数的基类。</p>
<p>外部函数的实例也是兼容 C 的数据类型；它们代表 C 函数指针。</p>
<p>此行为可通过对外部函数对象的特殊属性赋值来自定义。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._FuncPtr.restype">
<span class="sig-name descname"><span class="pre">restype</span></span><a class="headerlink" href="#ctypes._FuncPtr.restype" title="永久链接至目标">¶</a></dt>
<dd><p>Assign a ctypes type to specify the result type of the foreign function.
Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for <span class="c-expr sig sig-inline c"><span class="kt">void</span></span>, a function not returning anything.</p>
<p>It is possible to assign a callable Python object that is not a ctypes
type, in this case the function is assumed to return a C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>, and
the callable will be called with this integer, allowing further
processing or error checking.  Using this is deprecated, for more flexible
post processing or error checking use a ctypes data type as
<a class="reference internal" href="#ctypes._FuncPtr.restype" title="ctypes._FuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a> and assign a callable to the <a class="reference internal" href="#ctypes._FuncPtr.errcheck" title="ctypes._FuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> attribute.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._FuncPtr.argtypes">
<span class="sig-name descname"><span class="pre">argtypes</span></span><a class="headerlink" href="#ctypes._FuncPtr.argtypes" title="永久链接至目标">¶</a></dt>
<dd><p>赋值为一个 ctypes 类型的元组来指定函数所接受的参数类型。 使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用规范的函数只能附带与此元组长度相同数量的参数进行调用；使用 C 调用规范的函数还可接受额外的未指明参数。</p>
<p>当外部函数被调用时，每个实际参数都会被传给 <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 元组中条目的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 类方法，此方法允许将实际参数适配为此外部函数所接受的对象。 例如，<a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 元组中的 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> 条目将使用 ctypes 约定规则把作为参数传入的字符串转换为字节串对象。</p>
<p>新增：现在可以将不是 ctypes 类型的条目放入 argtypes，但每个条目都必须具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 方法用于返回可作为参数的值（整数、字符串、ctypes 实例）。 这样就允许定义可将自定义对象适配为函数形参的适配器。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._FuncPtr.errcheck">
<span class="sig-name descname"><span class="pre">errcheck</span></span><a class="headerlink" href="#ctypes._FuncPtr.errcheck" title="永久链接至目标">¶</a></dt>
<dd><p>将一个 Python 函数或其他可调用对象赋值给此属性。 该可调用对象将附带三个及以上的参数被调用。</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">callable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arguments</span></span></em><span class="sig-paren">)</span></dt>
<dd><p><em>result</em> 是外部函数返回的结果，由 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 属性指明。</p>
<p><em>func</em> 是外部函数对象本身，这样就允许重新使用相同的可调用对象来对多个函数进行检查或后续处理。</p>
<p><em>arguments</em> 是一个包含最初传递给函数调用的形参的元组，这样就允许对所用参数的行为进行特别处理。</p>
</dd></dl>

<p>此函数所返回的对象将会由外部函数调用返回，但它还可以在外部函数调用失败时检查结果并引发异常。</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ctypes.ArgumentError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">ArgumentError</span></span><a class="headerlink" href="#ctypes.ArgumentError" title="永久链接至目标">¶</a></dt>
<dd><p>此异常会在外部函数无法对某个传入参数执行转换时被引发。</p>
</dd></dl>

<p class="audit-hook">引发一个审计事件 <code class="docutils literal notranslate"><span class="pre">ctypes.seh_exception</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">code</span></code>。</p>
<p class="audit-hook">引发一个审计事件 <code class="docutils literal notranslate"><span class="pre">ctypes.call_function</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">func_pointer</span></code>, <code class="docutils literal notranslate"><span class="pre">arguments</span></code>。</p>
</section>
<section id="function-prototypes">
<span id="ctypes-function-prototypes"></span><h3>函数原型<a class="headerlink" href="#function-prototypes" title="永久链接至标题">¶</a></h3>
<p>外部函数也可通过实例化函数原型来创建。 函数原型类似于 C 中的函数原型；它们在不定义具体实现的情况下描述了一个函数（返回类型、参数类型、调用约定）。 工厂函数必须使用函数所需要的结果类型和参数类型来调用，并可被用作装饰器工厂函数，在此情况下可以通过 <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code> 语法应用于函数。 请参阅 <a class="reference internal" href="#ctypes-callback-functions"><span class="std std-ref">回调函数</span></a> 了解有关示例。</p>
<dl class="py function">
<dt class="sig sig-object py" id="ctypes.CFUNCTYPE">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">CFUNCTYPE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">restype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">argtypes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CFUNCTYPE" title="永久链接至目标">¶</a></dt>
<dd><p>返回的函数原型会创建使用标准 C 调用约定的函数。 该函数在调用过程中将释放 GIL。 如果 <em>use_errno</em> 设为真值，则在调用之前和之后系统 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 变量的 ctypes 私有副本会与真正的 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 值进行交换；<em>use_last_error</em> 会为 Windows 错误码执行同样的操作。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.WINFUNCTYPE">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">WINFUNCTYPE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">restype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">argtypes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WINFUNCTYPE" title="永久链接至目标">¶</a></dt>
<dd><p>仅限 Windows：返回的函数原型会创建使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定的函数。 该函数在调用过程中将会释放 GIL。 <em>use_errno</em> 和 <em>use_last_error</em> 具有与上文中相同的含义。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.PYFUNCTYPE">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">PYFUNCTYPE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">restype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">argtypes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PYFUNCTYPE" title="永久链接至目标">¶</a></dt>
<dd><p>返回的函数原型会创建使用 Python 调用约定的函数。 该函数在调用过程中将 <em>不会</em> 释放 GIL。</p>
</dd></dl>

<p>这些工厂函数所创建的函数原型可通过不同的方式来实例化，具体取决于调用中的类型与数量:</p>
<blockquote>
<div><dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在指定地址上返回一个外部函数，地址值必须为整数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基于 Python <em>callable</em> 创建一个 C 可调用函数（回调函数）。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_spec</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">paramflags</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回由一个共享库导出的外部函数。 <em>func_spec</em> 必须为一个 2 元组 <code class="docutils literal notranslate"><span class="pre">(name_or_ordinal,</span> <span class="pre">library)</span></code>。 第一项是字符串形式的所导出函数名称，或小整数形式的所导出函数序号。 第二项是该共享库实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vtbl_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">paramflags</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">iid</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回将调用一个 COM 方法的外部函数。 <em>vtbl_index</em> 虚拟函数表中的索引。 <em>name</em> 是 COM 方法的名称。 <em>iid</em> 是可选的指向接口标识符的指针，它被用于扩展的错误报告。</p>
<p>COM 方法使用特殊的调用约定：除了在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 元组中指定的形参，它们还要求一个指向 COM 接口的指针作为第一个参数。</p>
</dd></dl>

<p>可选的 <em>paramflags</em> 形参会创建相比上述特性具有更多功能的外部函数包装器。</p>
<p><em>paramflags</em> 必须为一个与 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 长度相同的元组。</p>
<p>此元组中的每一项都包含有关形参的更多信息，它必须为包含一个、两个或更多条目的元组。</p>
<p>第一项是包含形参指令旗标组合的整数。</p>
<blockquote>
<div><dl class="simple">
<dt>1</dt><dd><p>指定函数的一个输入形参。</p>
</dd>
<dt>2</dt><dd><p>输出形参。 外部函数会填入一个值。</p>
</dd>
<dt>4</dt><dd><p>默认为整数零值的输入形参。</p>
</dd>
</dl>
</div></blockquote>
<p>可选的第二项是字符串形式的形参名称。 如果指定此项，则可以使用该形参名称来调用外部函数。</p>
<p>可选的第三项是该形参的默认值。</p>
</div></blockquote>
<p>这个例子演示了如何包装 Windows 的 <code class="docutils literal notranslate"><span class="pre">MessageBoxW</span></code> 函数以使其支持默认形参和已命名参数。 相应 windows 头文件的 C 声明是这样的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="nb">int</span> <span class="n">WINAPI</span>
<span class="n">MessageBoxW</span><span class="p">(</span>
    <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpText</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpCaption</span><span class="p">,</span>
    <span class="n">UINT</span> <span class="n">uType</span><span class="p">);</span>
</pre></div>
</div>
<p>这是使用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 的包装:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="kn">import</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;Hi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;caption&quot;</span><span class="p">,</span> <span class="s2">&quot;Hello from ctypes&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;MessageBoxW&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
</pre></div>
</div>
<p>现在 <code class="docutils literal notranslate"><span class="pre">MessageBox</span></code> 外部函数可以通过以下方式来调用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;Spam, spam, spam&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;foo bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>第二个例子演示了输出形参。 这个 win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> 函数通过将指定窗口的维度拷贝至调用者必须提供的 <code class="docutils literal notranslate"><span class="pre">RECT</span></code> 结构体来提取这些值。 这是相应的 C 声明:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="n">BOOL</span> <span class="n">WINAPI</span>
<span class="n">GetWindowRect</span><span class="p">(</span>
     <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
     <span class="n">LPRECT</span> <span class="n">lpRect</span><span class="p">);</span>
</pre></div>
</div>
<p>这是使用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 的包装:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span><span class="p">,</span> <span class="n">WinError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="kn">import</span> <span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">RECT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">RECT</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;lprect&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;GetWindowRect&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>带有输出形参的函数如果输出形参存在单一值则会自动返回该值，或是当输出形参存在多个值时返回包含这些值的元组，因此当 GetWindowRect 被调用时现在将返回一个 RECT 实例。</p>
<p>输出形参可以与 <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> 协议相结合以执行进一步的输出处理与错误检查。 Win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> API 函数返回一个 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> 来表示成功或失败，因此此函数可执行错误检查，并在 API 调用失败时引发异常:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">args</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果 <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> 不加更改地返回它所接收的参数元组，则 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 会继续对输出形参执行常规处理。 如果你希望返回一个窗口坐标的元组而非 <code class="docutils literal notranslate"><span class="pre">RECT</span></code> 实例，你可以从函数中提取这些字段并返回它们，常规处理将不会再执行:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">rc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">right</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="utility-functions">
<span id="ctypes-utility-functions"></span><h3>工具函数<a class="headerlink" href="#utility-functions" title="永久链接至标题">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="ctypes.addressof">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">addressof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.addressof" title="永久链接至目标">¶</a></dt>
<dd><p>以整数形式返回内存缓冲区地址。 <em>obj</em> 必须为一个 ctypes 类型的实例。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.addressof</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">obj</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.alignment">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj_or_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.alignment" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个 ctypes 类型的对齐要求。 <em>obj_or_type</em> 必须为一个 ctypes 类型或实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.byref">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">byref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.byref" title="永久链接至目标">¶</a></dt>
<dd><p>返回指向 <em>obj</em> 的轻量指针，该对象必须为一个 ctypes 类型的实例。 <em>offset</em> 默认值为零，且必须为一个将被添加到内部指针值的整数。</p>
<p><code class="docutils literal notranslate"><span class="pre">byref(obj,</span> <span class="pre">offset)</span></code> 对应于这段 C 代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>返回的对象只能被用作外部函数调用形参。 它的行为类似于 <code class="docutils literal notranslate"><span class="pre">pointer(obj)</span></code>，但构造起来要快很多。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.cast">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.cast" title="永久链接至目标">¶</a></dt>
<dd><p>此函数类似于 C 的强制转换运算符。 它返回一个 <em>type</em> 的新实例，该实例指向与 <em>obj</em> 相同的内存块。 <em>type</em> 必须为指针类型，而 <em>obj</em> 必须为可以被作为指针来解读的对象。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.create_string_buffer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">create_string_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_or_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_string_buffer" title="永久链接至目标">¶</a></dt>
<dd><p>此函数会创建一个可变的字符缓冲区。 返回的对象是一个 <a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a> 的 ctypes 数组。</p>
<p><em>init_or_size</em> 必须是一个指明数组大小的整数，或者是一个将被用来初始化数组条目的字节串对象。</p>
<p>如果将一个字节串对象指定为第一个参数，则将使缓冲区大小比其长度多一项以便数组的最后一项为一个 NUL 终结符。 可以传入一个整数作为第二个参数以允许在不使用字节串长度的情况下指定数组大小。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.create_string_buffer</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.create_unicode_buffer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">create_unicode_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_or_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_unicode_buffer" title="永久链接至目标">¶</a></dt>
<dd><p>此函数会创建一个可变的 unicode 字符缓冲区。 返回的对象是一个 <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a> 的 ctypes 数组。</p>
<p><em>init_or_size</em> 必须是一个指明数组大小的整数，或者是一个将被用来初始化数组条目的字符串。</p>
<p>如果将一个字符串指定为第一个参数，则将使缓冲区大小比其长度多一项以便数组的最后一项为一个 NUL 终结符。 可以传入一个整数作为第二个参数以允许在不使用字符串长度的情况下指定数组大小。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.create_unicode_buffer</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.DllCanUnloadNow">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">DllCanUnloadNow</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllCanUnloadNow" title="永久链接至目标">¶</a></dt>
<dd><p>仅限 Windows：此函数是一个允许使用 ctypes 实现进程内 COM 服务的钩子。 它将由 _ctypes 扩展 dll 所导出的 DllCanUnloadNow 函数来调用。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.DllGetClassObject">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">DllGetClassObject</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllGetClassObject" title="永久链接至目标">¶</a></dt>
<dd><p>仅限 Windows：此函数是一个允许使用 ctypes 实现进程内 COM 服务的钩子。 它将由 <code class="docutils literal notranslate"><span class="pre">_ctypes</span></code> 扩展 dll 所导出的 DllGetClassObject 函数来调用。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.util.find_library">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">find_library</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_library" title="永久链接至目标">¶</a></dt>
<dd><p>尝试寻找一个库并返回路径名称。 <em>name</em> 是库名称并且不带任何前缀如 <code class="docutils literal notranslate"><span class="pre">lib</span></code> 以及后缀如 <code class="docutils literal notranslate"><span class="pre">.so</span></code>，<code class="docutils literal notranslate"><span class="pre">.dylib</span></code> 或版本号（形式与 posix 链接器选项 <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code> 所用的一致）。 如果找不到库，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>确切的功能取决于系统。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.util.find_msvcrt">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">find_msvcrt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_msvcrt" title="永久链接至目标">¶</a></dt>
<dd><p>仅限 Windows：返回 Python 以及扩展模块所使用的 VC 运行时库的文件名。 如果无法确定库名称，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>如果你需要通过调用 <code class="docutils literal notranslate"><span class="pre">free(void</span> <span class="pre">*)</span></code> 来释放内存，例如某个扩展模块所分配的内存，重要的一点是你应当使用分配内存的库中的函数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.FormatError">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">FormatError</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">code</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.FormatError" title="永久链接至目标">¶</a></dt>
<dd><p>仅限 Windows：返回错误码 <em>code</em> 的文本描述。 如果未指定错误码，则会通过调用 Windows api 函数 GetLastError 来获得最新的错误码。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.GetLastError">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">GetLastError</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.GetLastError" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: Returns the last error code set by Windows in the calling thread.
This function calls the Windows <code class="docutils literal notranslate"><span class="pre">GetLastError()</span></code> function directly,
it does not return the ctypes-private copy of the error code.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.get_errno">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">get_errno</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_errno" title="永久链接至目标">¶</a></dt>
<dd><p>返回调用线程中系统 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 变量的 ctypes 私有副本的当前值。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.get_errno</span></code>，不附带任何参数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.get_last_error">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">get_last_error</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_last_error" title="永久链接至目标">¶</a></dt>
<dd><p>仅限 Windows：返回调用线程中系统 <code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> 变量的 ctypes 私有副本的当前值。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.get_last_error</span></code>，不附带任何参数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.memmove">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">memmove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memmove" title="永久链接至目标">¶</a></dt>
<dd><p>与标准 C memmove 库函数相同：将 <em>count</em> 个字节从 <em>src</em> 拷贝到 <em>dst</em>。 <em>dst</em> 和 <em>src</em> 必须为整数或可被转换为指针的 ctypes 实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.memset">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">memset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memset" title="永久链接至目标">¶</a></dt>
<dd><p>与标准 C memset 库函数相同：将位于地址 <em>dst</em> 的内存块用 <em>count</em> 个字节的 <em>c</em> 值填充。 <em>dst</em> 必须为指定地址的整数或 ctypes 实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.POINTER">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">POINTER</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.POINTER" title="永久链接至目标">¶</a></dt>
<dd><p>这个工厂函数创建并返回一个新的 ctypes 指针类型。 指针类型会被缓存并在内部重用，因此重复调用此函数耗费不大。 <em>type</em> 必须为 ctypes 类型。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.pointer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">pointer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.pointer" title="永久链接至目标">¶</a></dt>
<dd><p>此函数会创建一个新的指向 <em>obj</em> 的指针实例。 返回的对象类型为 <code class="docutils literal notranslate"><span class="pre">POINTER(type(obj))</span></code>。</p>
<p>注意：如果你只是想向外部函数调用传递一个对象指针，你应当使用更为快速的 <code class="docutils literal notranslate"><span class="pre">byref(obj)</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.resize">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">resize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.resize" title="永久链接至目标">¶</a></dt>
<dd><p>此函数可改变 <em>obj</em> 的内部内存缓冲区大小，其参数必须为 ctypes 类型的实例。 没有可能将缓冲区设为小于对象类型的本机大小值，该值由 <code class="docutils literal notranslate"><span class="pre">sizeof(type(obj))</span></code> 给出，但将缓冲区加大则是可能的。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.set_errno">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">set_errno</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_errno" title="永久链接至目标">¶</a></dt>
<dd><p>设置调用线程中系统 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 变量的 ctypes 私有副本的当前值为 <em>value</em> 并返回原来的值。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.set_errno</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">errno</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.set_last_error">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">set_last_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_last_error" title="永久链接至目标">¶</a></dt>
<dd><p>仅限 Windows：设置调用线程中系统 <code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> 变量的 ctypes 私有副本的当前值为 <em>value</em> 并返回原来的值。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.set_last_error</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">error</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.sizeof">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">sizeof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj_or_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.sizeof" title="永久链接至目标">¶</a></dt>
<dd><p>返回 ctypes 类型或实例的内存缓冲区以字节表示的大小。 其功能与 C <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 运算符相同。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.string_at">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">string_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.string_at" title="永久链接至目标">¶</a></dt>
<dd><p>此函数返回从内存地址 <em>address</em> 开始的以字节串表示的 C 字符串。 如果指定了 size，则将其用作长度，否则将假定字符串以零值结尾。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.string_at</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">address</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.WinError">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">WinError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinError" title="永久链接至目标">¶</a></dt>
<dd><p>仅限 Windows：此函数可能是 ctypes 中名字起得最差的函数。 它会创建一个 OSError 的实例。 如果未指定 <em>code</em>，则会调用 <code class="docutils literal notranslate"><span class="pre">GetLastError</span></code> 来确定错误码。 如果未指定 <em>descr</em>，则会调用 <a class="reference internal" href="#ctypes.FormatError" title="ctypes.FormatError"><code class="xref py py-func docutils literal notranslate"><span class="pre">FormatError()</span></code></a> 来获取错误的文本描述。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>以前是会创建一个 <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> 的实例。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.wstring_at">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">wstring_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.wstring_at" title="永久链接至目标">¶</a></dt>
<dd><p>此函数返回从内存地址 <em>address</em> 开始的以字符串表示的宽字节字符串。 如果指定了 <em>size</em>，则将其用作字符串中的字符数量，否则将假定字符串以零值结尾。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.wstring_at</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">address</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>。</p>
</dd></dl>

</section>
<section id="data-types">
<span id="ctypes-data-types"></span><h3>数据类型<a class="headerlink" href="#data-types" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes._CData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_CData</span></span><a class="headerlink" href="#ctypes._CData" title="永久链接至目标">¶</a></dt>
<dd><p>这个非公有类是所有 ctypes 数据类型的共同基类。 另外，所有 ctypes 类型的实例都包含一个存放 C 兼容数据的内存块；该内存块的地址可由 <a class="reference internal" href="#ctypes.addressof" title="ctypes.addressof"><code class="xref py py-func docutils literal notranslate"><span class="pre">addressof()</span></code></a> 辅助函数返回。 还有一个实例变量被公开为 <a class="reference internal" href="#ctypes._CData._objects" title="ctypes._CData._objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_objects</span></code></a>；此变量包含其他在内存块包含指针的情况下需要保持存活的 Python 对象。</p>
<p>ctypes 数据类型的通用方法，它们都是类方法（严谨地说，它们是 <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a> 的方法）:</p>
<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_buffer">
<span class="sig-name descname"><span class="pre">from_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer" title="永久链接至目标">¶</a></dt>
<dd><p>此方法返回一个共享 <em>source</em> 对象缓冲区的 ctypes 实例。 <em>source</em> 对象必须支持可写缓冲区接口。 可选的 <em>offset</em> 形参指定以字节表示的源缓冲区内偏移量；默认值为零。 如果源缓冲区不够大则会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata/buffer</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">pointer</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">offset</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_buffer_copy">
<span class="sig-name descname"><span class="pre">from_buffer_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer_copy" title="永久链接至目标">¶</a></dt>
<dd><p>此方法创建一个 ctypes 实例，从 <em>source</em> 对象缓冲区拷贝缓冲区，该对象必须是可读的。 可选的 <em>offset</em> 形参指定以字节表示的源缓冲区内偏移量；默认值为零。 如果源缓冲区不够大则会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata/buffer</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">pointer</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">offset</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_address">
<span class="sig-name descname"><span class="pre">from_address</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_address" title="永久链接至目标">¶</a></dt>
<dd><p>此方法会使用 <em>address</em> 所指定的内存返回一个 ctypes 类型的实例，该参数必须为一个整数。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">address</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_param">
<span class="sig-name descname"><span class="pre">from_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_param" title="永久链接至目标">¶</a></dt>
<dd><p>此方法会将 <em>obj</em> 适配为一个 ctypes 类型。 它调用时会在当该类型存在于外部函数的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 元组时传入外部函数调用所使用的实际对象；它必须返回一个可被用作函数调用参数的对象。</p>
<p>所有 ctypes 数据类型都带有这个类方法的默认实现，它通常会返回 <em>obj</em>，如果该对象是此类型的实例的话。 某些类型也能接受其他对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.in_dll">
<span class="sig-name descname"><span class="pre">in_dll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">library</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.in_dll" title="永久链接至目标">¶</a></dt>
<dd><p>此方法返回一个由共享库导出的 ctypes 类型。 <em>name</em> 为导出数据的符号名称，<em>library</em> 为所加载的共享库。</p>
</dd></dl>

<p>ctypes 数据类型的通用实例变量:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData._b_base_">
<span class="sig-name descname"><span class="pre">_b_base_</span></span><a class="headerlink" href="#ctypes._CData._b_base_" title="永久链接至目标">¶</a></dt>
<dd><p>有时 ctypes 数据实例并不拥有它们所包含的内存块，它们只是共享了某个基对象的部分内存块。 <a class="reference internal" href="#ctypes._CData._b_base_" title="ctypes._CData._b_base_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_b_base_</span></code></a> 只读成员是拥有内存块的根 ctypes 对象。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData._b_needsfree_">
<span class="sig-name descname"><span class="pre">_b_needsfree_</span></span><a class="headerlink" href="#ctypes._CData._b_needsfree_" title="永久链接至目标">¶</a></dt>
<dd><p>这个只读变量在 ctypes 数据实例自身已分配了内存块时为真值，否则为假值。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData._objects">
<span class="sig-name descname"><span class="pre">_objects</span></span><a class="headerlink" href="#ctypes._CData._objects" title="永久链接至目标">¶</a></dt>
<dd><p>这个成员或者为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，或者为一个包含需要保持存活以使内存块的内存保持有效的 Python 对象的字典。 这个对象只是出于调试目的而对外公开；绝对不要修改此字典的内容。</p>
</dd></dl>

</dd></dl>

</section>
<section id="ctypes-fundamental-data-types-2">
<span id="id1"></span><h3>基础数据类型<a class="headerlink" href="#ctypes-fundamental-data-types-2" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes._SimpleCData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_SimpleCData</span></span><a class="headerlink" href="#ctypes._SimpleCData" title="永久链接至目标">¶</a></dt>
<dd><p>这个非公有类是所有基本 ctypes 数据类型的基类。 它在这里被提及是因为它包含基本 ctypes 数据类型共有的属性。 <a class="reference internal" href="#ctypes._SimpleCData" title="ctypes._SimpleCData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_SimpleCData</span></code></a> 是 <a class="reference internal" href="#ctypes._CData" title="ctypes._CData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_CData</span></code></a> 的子类，因此继承了其方法和属性。 非指针及不包含指针的 ctypes 数据类型现在将可以被封存。</p>
<p>实例拥有一个属性:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._SimpleCData.value">
<span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#ctypes._SimpleCData.value" title="永久链接至目标">¶</a></dt>
<dd><p>这个属性包含实例的实际值。 对于整数和指针类型，它是一个整数，对于字符类型，它是一个单字符字符串对象或字符串，对于字符指针类型，它是一个 Python 字节串对象或字符串。</p>
<p>当从 ctypes 实例提取 <code class="docutils literal notranslate"><span class="pre">value</span></code> 属性时，通常每次会返回一个新的对象。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 并 <em>没有</em> 实现原始对象返回，它总是会构造一个新的对象。 所有其他 ctypes 对象实例也同样如此。</p>
</dd></dl>

</dd></dl>

<p>基本数据类型当作为外部函数调用结果被返回或者作为结构字段成员或数组项被提取时，会透明地转换为原生 Python 类型。 换句话说，如果某个外部函数具有 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> 的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code>，你将总是得到一个 Python 字节串对象，而 <em>不是</em> 一个 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> 实例。</p>
<p>基本数据类型的子类并 <em>没有</em> 继续此行为。 因此，如果一个外部函数的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 是 <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a> 的一个子类，你将从函数调用得到一个该子类的实例。 当然，你可以通过访问 <code class="docutils literal notranslate"><span class="pre">value</span></code> 属性来获取指针的值。</p>
<p>这些是基本 ctypes 数据类型:</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_byte">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_byte</span></span><a class="headerlink" href="#ctypes.c_byte" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span></span> datatype, and interprets the value as
small integer.  The constructor accepts an optional integer initializer; no
overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_char">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_char</span></span><a class="headerlink" href="#ctypes.c_char" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">char</span></span> datatype, and interprets the value as a single
character.  The constructor accepts an optional string initializer, the
length of the string must be exactly one character.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_char_p">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_char_p</span></span><a class="headerlink" href="#ctypes.c_char_p" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span></span> datatype when it points to a zero-terminated
string.  For a general character pointer that may also point to binary data,
<code class="docutils literal notranslate"><span class="pre">POINTER(c_char)</span></code> must be used.  The constructor accepts an integer
address, or a bytes object.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_double">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_double</span></span><a class="headerlink" href="#ctypes.c_double" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> datatype.  The constructor accepts an
optional float initializer.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_longdouble">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_longdouble</span></span><a class="headerlink" href="#ctypes.c_longdouble" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">double</span></span> datatype.  The constructor accepts an
optional float initializer.  On platforms where <code class="docutils literal notranslate"><span class="pre">sizeof(long</span> <span class="pre">double)</span> <span class="pre">==</span>
<span class="pre">sizeof(double)</span></code> it is an alias to <a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_float">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_float</span></span><a class="headerlink" href="#ctypes.c_float" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">float</span></span> datatype.  The constructor accepts an
optional float initializer.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int</span></span><a class="headerlink" href="#ctypes.c_int" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On platforms
where <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> it is an alias to <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int8">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int8</span></span><a class="headerlink" href="#ctypes.c_int8" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 8-bit <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int16">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int16</span></span><a class="headerlink" href="#ctypes.c_int16" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 16-bit <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int32">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int32</span></span><a class="headerlink" href="#ctypes.c_int32" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 32-bit <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int64">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int64</span></span><a class="headerlink" href="#ctypes.c_int64" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 64-bit <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_long">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_long</span></span><a class="headerlink" href="#ctypes.c_long" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">long</span></span> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_longlong">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_longlong</span></span><a class="headerlink" href="#ctypes.c_longlong" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_short">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_short</span></span><a class="headerlink" href="#ctypes.c_short" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">short</span></span> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_size_t">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_size_t</span></span><a class="headerlink" href="#ctypes.c_size_t" title="永久链接至目标">¶</a></dt>
<dd><p>代表 C <code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code> 数据类型。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ssize_t">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ssize_t</span></span><a class="headerlink" href="#ctypes.c_ssize_t" title="永久链接至目标">¶</a></dt>
<dd><p>代表 C <code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code> 数据类型。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ubyte">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ubyte</span></span><a class="headerlink" href="#ctypes.c_ubyte" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span> datatype, it interprets the value as
small integer.  The constructor accepts an optional integer initializer; no
overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint</span></span><a class="headerlink" href="#ctypes.c_uint" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On platforms
where <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> it is an alias for <a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint8">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint8</span></span><a class="headerlink" href="#ctypes.c_uint8" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 8-bit <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint16">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint16</span></span><a class="headerlink" href="#ctypes.c_uint16" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 16-bit <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint32">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint32</span></span><a class="headerlink" href="#ctypes.c_uint32" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 32-bit <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint64">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint64</span></span><a class="headerlink" href="#ctypes.c_uint64" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 64-bit <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ulong">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ulong</span></span><a class="headerlink" href="#ctypes.c_ulong" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ulonglong">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ulonglong</span></span><a class="headerlink" href="#ctypes.c_ulonglong" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> datatype.  The constructor
accepts an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ushort">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ushort</span></span><a class="headerlink" href="#ctypes.c_ushort" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span></span> datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_void_p">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_void_p</span></span><a class="headerlink" href="#ctypes.c_void_p" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> type.  The value is represented as integer.
The constructor accepts an optional integer initializer.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_wchar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_wchar</span></span><a class="headerlink" href="#ctypes.c_wchar" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span></span> datatype, and interprets the value as a
single character unicode string.  The constructor accepts an optional string
initializer, the length of the string must be exactly one character.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_wchar_p">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_wchar_p</span></span><a class="headerlink" href="#ctypes.c_wchar_p" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> datatype, which must be a pointer to a
zero-terminated wide character string.  The constructor accepts an integer
address, or a string.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_bool">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_bool</span></span><a class="headerlink" href="#ctypes.c_bool" title="永久链接至目标">¶</a></dt>
<dd><p>Represent the C <span class="c-expr sig sig-inline c"><span class="kt">bool</span></span> datatype (more accurately, <span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span> from
C99).  Its value can be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, and the constructor accepts any object
that has a truth value.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.HRESULT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">HRESULT</span></span><a class="headerlink" href="#ctypes.HRESULT" title="永久链接至目标">¶</a></dt>
<dd><p>Windows 专属：代表一个 <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> 值，它包含某个函数或方法调用的成功或错误信息。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.py_object">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">py_object</span></span><a class="headerlink" href="#ctypes.py_object" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> datatype.  Calling this without an
argument creates a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> pointer.</p>
</dd></dl>

<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.wintypes</span></code> 模块提供了其他许多 Windows 专属的数据类型，例如 <code class="xref c c-type docutils literal notranslate"><span class="pre">HWND</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">WPARAM</span></code> 或 <code class="xref c c-type docutils literal notranslate"><span class="pre">DWORD</span></code>。 还定义了一些有用的结构体例如 <code class="xref c c-type docutils literal notranslate"><span class="pre">MSG</span></code> 或 <code class="xref c c-type docutils literal notranslate"><span class="pre">RECT</span></code>。</p>
</section>
<section id="structured-data-types">
<span id="ctypes-structured-data-types"></span><h3>结构化数据类型<a class="headerlink" href="#structured-data-types" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.Union">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">Union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Union" title="永久链接至目标">¶</a></dt>
<dd><p>本机字节序的联合所对应的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.BigEndianUnion">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">BigEndianUnion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianUnion" title="永久链接至目标">¶</a></dt>
<dd><p>Abstract base class for unions in <em>big endian</em> byte order.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.11 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.LittleEndianUnion">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">LittleEndianUnion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianUnion" title="永久链接至目标">¶</a></dt>
<dd><p>Abstract base class for unions in <em>little endian</em> byte order.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.11 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.BigEndianStructure">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">BigEndianStructure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianStructure" title="永久链接至目标">¶</a></dt>
<dd><p><em>大端</em> 字节序的结构体所对应的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.LittleEndianStructure">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">LittleEndianStructure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianStructure" title="永久链接至目标">¶</a></dt>
<dd><p><em>小端</em> 字节序的结构体所对应的抽象基类。</p>
</dd></dl>

<p>Structures and unions with non-native byte order cannot contain pointer type
fields, or any other data types containing pointer type fields.</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.Structure">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">Structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Structure" title="永久链接至目标">¶</a></dt>
<dd><p><em>本机</em> 字节序的结构体所对应的抽象基类。</p>
<p>实际的结构体和联合类型必须通过子类化这些类型之一来创建，并且至少要定义一个 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 类变量。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 将创建 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>，它允许通过直接属性访问来读取和写入字段。 这些是</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._fields_">
<span class="sig-name descname"><span class="pre">_fields_</span></span><a class="headerlink" href="#ctypes.Structure._fields_" title="永久链接至目标">¶</a></dt>
<dd><p>一个定义结构体字段的序列。 其中的条目必须为 2 元组或 3 元组。 元组的第一项是字段名称，第二项指明字段类型；它可以是任何 ctypes 数据类型。</p>
<p>对于整数类型字段例如 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>，可以给定第三个可选项。 它必须是一个定义字段比特位宽度的小正整数。</p>
<p>字段名称在一个结构体或联合中必须唯一。 不会检查这个唯一性，但当名称出现重复时将只有一个字段可被访问。</p>
<p>可以在定义 Structure 子类的类语句 <em>之后</em> 再定义 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 类变量，这将允许创建直接或间接引用其自身的数据类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">List</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">List</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;pnext&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">List</span><span class="p">)),</span>
                 <span class="o">...</span>
                <span class="p">]</span>
</pre></div>
</div>
<p>但是，<a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 类变量必须在类型第一次被使用（创建实例，调用 <a class="reference internal" href="#ctypes.sizeof" title="ctypes.sizeof"><code class="xref py py-func docutils literal notranslate"><span class="pre">sizeof()</span></code></a> 等等）之前进行定义。 在此之后对 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 类变量赋值将会引发 AttributeError。</p>
<p>可以定义结构体类型的子类，它们会继承基类的字段再加上在子类中定义的任何 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._pack_">
<span class="sig-name descname"><span class="pre">_pack_</span></span><a class="headerlink" href="#ctypes.Structure._pack_" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的小整数，它允许覆盖实体中结构体字段的对齐方式。 当 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 被赋值时必须已经定义了 <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a>，否则它将没有效果。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._anonymous_">
<span class="sig-name descname"><span class="pre">_anonymous_</span></span><a class="headerlink" href="#ctypes.Structure._anonymous_" title="永久链接至目标">¶</a></dt>
<dd><p>一个可选的序列，它会列出未命名（匿名）字段的名称。 当 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 被赋值时必须已经定义了 <a class="reference internal" href="#ctypes.Structure._anonymous_" title="ctypes.Structure._anonymous_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_anonymous_</span></code></a>，否则它将没有效果。</p>
<p>在此变量中列出的字段必须为结构体或联合类型字段。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 将在结构体类型中创建描述器以允许直接访问嵌套字段，而无需创建对应的结构体或联合字段。</p>
<p>以下是一个示例类型（Windows）:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">_U</span><span class="p">(</span><span class="n">Union</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;lptdesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">TYPEDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;lpadesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">ARRAYDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;hreftype&quot;</span><span class="p">,</span> <span class="n">HREFTYPE</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">TYPEDESC</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_anonymous_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,)</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">_U</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;vt&quot;</span><span class="p">,</span> <span class="n">VARTYPE</span><span class="p">)]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TYPEDESC</span></code> 结构体描述了一个 COM 数据类型，<code class="docutils literal notranslate"><span class="pre">vt</span></code> 字段指明哪个联合字段是有效的。 由于 <code class="docutils literal notranslate"><span class="pre">u</span></code> 字段被定义为匿名字段，现在可以直接从 TYPEDESC 实例访问成员。 <code class="docutils literal notranslate"><span class="pre">td.lptdesc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">td.u.lptdesc</span></code> 是等价的，但前者速度更快，因为它不需要创建临时的联合实例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">td</span> <span class="o">=</span> <span class="n">TYPEDESC</span><span class="p">()</span>
<span class="n">td</span><span class="o">.</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_PTR</span>
<span class="n">td</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
<span class="n">td</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p>可以定义结构体的子类，它们会继承基类的字段。 如果子类定义具有单独的 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 变量，在其中指定的字段会被添加到基类的字段中。</p>
<p>结构体和联合的构造器均可接受位置和关键字参数。 位置参数用于按照 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 中的出现顺序来初始化成员字段。 构造器中的关键字参数会被解读为属性赋值，因此它们将以相应的名称来初始化 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>，或为不存在于 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 中的名称创建新的属性。</p>
</dd></dl>

</section>
<section id="arrays-and-pointers">
<span id="ctypes-arrays-pointers"></span><h3>数组与指针<a class="headerlink" href="#arrays-and-pointers" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.Array">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">Array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Array" title="永久链接至目标">¶</a></dt>
<dd><p>数组的抽象基类。</p>
<p>创建实体数组类型的推荐方式是通过将任意 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 数据类型与一个非负整数相乘。 作为替代方式，你也可以子类化这个类型并定义 <a class="reference internal" href="#ctypes.Array._length_" title="ctypes.Array._length_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_length_</span></code></a> 和 <a class="reference internal" href="#ctypes.Array._type_" title="ctypes.Array._type_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_type_</span></code></a> 类变量。 数组元素可使用标准的抽取和切片操作来进行读写；对于切片读取，结果对象本身 <em>不是</em> 一个 <a class="reference internal" href="#ctypes.Array" title="ctypes.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Array._length_">
<span class="sig-name descname"><span class="pre">_length_</span></span><a class="headerlink" href="#ctypes.Array._length_" title="永久链接至目标">¶</a></dt>
<dd><p>一个指明数组中元素数量的正整数。 超出范围的抽取会导致 <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>。 该值将由 <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 返回。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Array._type_">
<span class="sig-name descname"><span class="pre">_type_</span></span><a class="headerlink" href="#ctypes.Array._type_" title="永久链接至目标">¶</a></dt>
<dd><p>指明数组中每个元素的类型。</p>
</dd></dl>

<p>Array 子类构造器可接受位置参数，用来按顺序初始化元素。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes._Pointer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_Pointer</span></span><a class="headerlink" href="#ctypes._Pointer" title="永久链接至目标">¶</a></dt>
<dd><p>私有对象，指针的抽象基类。</p>
<p>实际的指针类型是通过调用 <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> 并附带其将指向的类型来创建的；这会由 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 自动完成。</p>
<p>如果一个指针指向的是数组，则其元素可使用标准的抽取和切片方式来读写。 指针对象没有长度，因此 <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 将引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 抽取负值将会从指针 <em>之前</em> 的内存中读取（与 C 一样），并且超出范围的抽取将可能因非法访问而导致崩溃（视你的运气而定）。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._Pointer._type_">
<span class="sig-name descname"><span class="pre">_type_</span></span><a class="headerlink" href="#ctypes._Pointer._type_" title="永久链接至目标">¶</a></dt>
<dd><p>指明所指向的类型。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._Pointer.contents">
<span class="sig-name descname"><span class="pre">contents</span></span><a class="headerlink" href="#ctypes._Pointer.contents" title="永久链接至目标">¶</a></dt>
<dd><p>返回指针所指向的对象。 对此属性赋值会使指针改为指向所赋值的对象。</p>
</dd></dl>

</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> --- Python 的外部函数库</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">ctypes 教程</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">载入动态连接库</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">操作导入的动态链接库中的函数</a></li>
<li><a class="reference internal" href="#calling-functions">调用函数</a></li>
<li><a class="reference internal" href="#fundamental-data-types">基础数据类型</a></li>
<li><a class="reference internal" href="#calling-functions-continued">调用函数，继续</a></li>
<li><a class="reference internal" href="#calling-varadic-functions">Calling varadic functions</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">使用自定义的数据类型调用函数</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">指定必选参数的类型(函数原型)</a></li>
<li><a class="reference internal" href="#return-types">返回类型</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">传递指针（或以引用方式传递形参）</a></li>
<li><a class="reference internal" href="#structures-and-unions">结构体和联合</a></li>
<li><a class="reference internal" href="#structure-union-alignment-and-byte-order">结构体/联合字段对齐及字节顺序</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">结构体和联合中的位域</a></li>
<li><a class="reference internal" href="#arrays">数组</a></li>
<li><a class="reference internal" href="#pointers">指针</a></li>
<li><a class="reference internal" href="#type-conversions">类型转换</a></li>
<li><a class="reference internal" href="#incomplete-types">不完整类型</a></li>
<li><a class="reference internal" href="#callback-functions">回调函数</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">访问 dll 的导出变量</a></li>
<li><a class="reference internal" href="#surprises">意外</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">变长数据类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">ctypes 参考手册</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">寻找动态链接库</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">加载动态链接库</a></li>
<li><a class="reference internal" href="#foreign-functions">外部函数</a></li>
<li><a class="reference internal" href="#function-prototypes">函数原型</a></li>
<li><a class="reference internal" href="#utility-functions">工具函数</a></li>
<li><a class="reference internal" href="#data-types">数据类型</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">基础数据类型</a></li>
<li><a class="reference internal" href="#structured-data-types">结构化数据类型</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">数组与指针</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="errno.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">errno</span></code> --- 标准 errno 系统符号</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="concurrency.html"
                          title="下一章">并发执行</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/ctypes.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="并发执行"
             >下一页</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno --- 标准 errno 系统符号"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >通用操作系统服务</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> --- Python 的外部函数库</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 11月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0创建。
    </div>

  </body>
</html>