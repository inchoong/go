
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>术语对照表 &#8212; Python 3.11.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.0 文档 中搜索"
          href="_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="about.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="copyright" title="版权所有" href="copyright.html" />
    <link rel="next" title="文档说明" href="about.html" />
    <link rel="prev" title="“为什么我的电脑上安装了 Python ？”" href="faq/installed.html" />
    <link rel="canonical" href="https://docs.python.org/3/glossary.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="_static/py.svg" />
            <script type="text/javascript" src="_static/copybutton.js"></script>
            <script type="text/javascript" src="_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="上一章">“为什么我的电脑上安装了 Python ？”</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="about.html"
                          title="下一章">文档说明</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="about.html" title="文档说明"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="“为什么我的电脑上安装了 Python ？”"
             accesskey="P">上一页</a> |</li>

          <li><img src="_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.11.0 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">术语对照表</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="glossary">
<span id="id1"></span><h1>术语对照表<a class="headerlink" href="#glossary" title="永久链接至标题">¶</a></h1>
<dl class="glossary">
<dt id="term-0"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code><a class="headerlink" href="#term-0" title="Permalink to this term">¶</a></dt><dd><p>交互式终端中默认的 Python 提示符。往往会显示于能以交互方式在解释器里执行的样例代码之前。</p>
</dd>
<dt id="term-..."><code class="docutils literal notranslate"><span class="pre">...</span></code><a class="headerlink" href="#term-..." title="Permalink to this term">¶</a></dt><dd><p>具有以下含义：</p>
<ul class="simple">
<li><p>交互式终端中输入特殊代码行时默认的 Python 提示符，包括：缩进的代码块，成对的分隔符之内（圆括号、方括号、花括号或三重引号），或是指定一个装饰器之后。</p></li>
<li><p><a class="reference internal" href="library/constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a> 内置常量。</p></li>
</ul>
</dd>
<dt id="term-2to3">2to3<a class="headerlink" href="#term-2to3" title="Permalink to this term">¶</a></dt><dd><p>把 Python 2.x 代码转换为 Python 3.x 代码的工具，通过解析源码，遍历解析树，处理绝大多数检测到的不兼容问题。</p>
<p>2to3 包含在标准库中，模块名为 <a class="reference internal" href="library/2to3.html#module-lib2to3" title="lib2to3: The 2to3 library"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lib2to3</span></code></a>；提供了独立入口点 <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/2to3</span></code>。详见 <a class="reference internal" href="library/2to3.html#to3-reference"><span class="std std-ref">2to3 --- Automated Python 2 to 3 code translation</span></a>。</p>
</dd>
<dt id="term-abstract-base-class">abstract base class -- 抽象基类<a class="headerlink" href="#term-abstract-base-class" title="Permalink to this term">¶</a></dt><dd><p>抽象基类简称 ABC，是对 <a class="reference internal" href="#term-duck-typing"><span class="xref std std-term">duck-typing</span></a> 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 显得过于笨拙或有微妙错误（例如使用 <a class="reference internal" href="reference/datamodel.html#special-lookup"><span class="std std-ref">魔术方法</span></a>）。ABC 引入了虚拟子类，这种类并非继承自其他类，但却仍能被 <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 和 <a class="reference internal" href="library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 所认可；详见 <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 模块文档。Python 自带许多内置的 ABC 用于实现数据结构（在 <a class="reference internal" href="library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 模块中）、数字（在 <a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a> 模块中）、流（在 <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 模块中）、导入查找器和加载器（在 <a class="reference internal" href="library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> 模块中）。你可以使用 <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 模块来创建自己的 ABC。</p>
</dd>
<dt id="term-annotation">annotation -- 标注<a class="headerlink" href="#term-annotation" title="Permalink to this term">¶</a></dt><dd><p>关联到某个变量、类属性、函数形参或返回值的标签，被约定作为 <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">类型注解</span></a> 来使用。</p>
<p>局部变量的标注在运行时不可访问，但全局变量、类属性和函数的标注会分别存放模块、类和函数的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 特殊属性中。</p>
<p>参见 <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">variable annotation</span></a>, <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">function annotation</span></a>, <span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 和 <span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>，对此功能均有介绍。 另请参见 <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">对象注解属性的最佳实践</span></a> 了解使用标注的最佳实践。</p>
</dd>
<dt id="term-argument">argument -- 参数<a class="headerlink" href="#term-argument" title="Permalink to this term">¶</a></dt><dd><p>在调用函数时传给 <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> （或 <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> ）的值。参数分为两种：</p>
<ul>
<li><p><em class="dfn">关键字参数</em>: 在函数调用中前面带有标识符（例如 <code class="docutils literal notranslate"><span class="pre">name=</span></code>）或者作为包含在前面带有 <code class="docutils literal notranslate"><span class="pre">**</span></code> 的字典里的值传入。举例来说，<code class="docutils literal notranslate"><span class="pre">3</span></code> 和 <code class="docutils literal notranslate"><span class="pre">5</span></code> 在以下对 <a class="reference internal" href="library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> 的调用中均属于关键字参数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">位置参数</em>: 不属于关键字参数的参数。位置参数可出现于参数列表的开头以及/或者作为前面带有 <code class="docutils literal notranslate"><span class="pre">*</span></code> 的 <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a> 里的元素被传入。举例来说，<code class="docutils literal notranslate"><span class="pre">3</span></code> 和 <code class="docutils literal notranslate"><span class="pre">5</span></code> 在以下调用中均属于位置参数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p>参数会被赋值给函数体中对应的局部变量。有关赋值规则参见 <a class="reference internal" href="reference/expressions.html#calls"><span class="std std-ref">调用</span></a> 一节。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。</p>
<p>另参见 <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parameter</span></a> 术语表条目，常见问题中 <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">参数与形参的区别</span></a> 以及 <span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>。</p>
</dd>
<dt id="term-asynchronous-context-manager">asynchronous context manager -- 异步上下文管理器<a class="headerlink" href="#term-asynchronous-context-manager" title="Permalink to this term">¶</a></dt><dd><p>此种对象通过定义 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code> 方法来对 <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 语句中的环境进行控制。由 <span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 引入。</p>
</dd>
<dt id="term-asynchronous-generator">asynchronous generator -- 异步生成器<a class="headerlink" href="#term-asynchronous-generator" title="Permalink to this term">¶</a></dt><dd><p>返回值为 <a class="reference internal" href="#term-asynchronous-generator-iterator"><span class="xref std std-term">asynchronous generator iterator</span></a> 的函数。它与使用 <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 定义的协程函数很相似，不同之处在于它包含 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 表达式以产生一系列可在 <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 循环中使用的值。</p>
<p>此术语通常是指异步生成器函数，但在某些情况下则可能是指 <em>异步生成器迭代器</em>。如果需要清楚表达具体含义，请使用全称以避免歧义。</p>
<p>一个异步生成器函数可能包含 <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 表达式或者 <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 以及 <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 语句。</p>
</dd>
<dt id="term-asynchronous-generator-iterator">asynchronous generator iterator -- 异步生成器迭代器<a class="headerlink" href="#term-asynchronous-generator-iterator" title="Permalink to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> 函数所创建的对象。</p>
<p>此对象属于 <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>，当使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code> 方法调用时会返回一个可等待对象来执行异步生成器函数的代码直到下一个 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 表达式。</p>
<p>每个 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 会临时暂停处理，记住当前位置执行状态 (包括局部变量和挂起的 try 语句)。当该 <em>异步生成器迭代器</em> 与其他 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code> 返回的可等待对象有效恢复时，它会从离开位置继续执行。参见 <span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 和 <span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a>。</p>
</dd>
<dt id="term-asynchronous-iterable">asynchronous iterable -- 异步可迭代对象<a class="headerlink" href="#term-asynchronous-iterable" title="Permalink to this term">¶</a></dt><dd><p>可在 <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 语句中被使用的对象。必须通过它的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code> 方法返回一个 <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>。由 <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 引入。</p>
</dd>
<dt id="term-asynchronous-iterator">asynchronous iterator -- 异步迭代器<a class="headerlink" href="#term-asynchronous-iterator" title="Permalink to this term">¶</a></dt><dd><p>实现了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code> 方法的对象。<code class="docutils literal notranslate"><span class="pre">__anext__</span></code> 必须返回一个 <a class="reference internal" href="#term-awaitable"><span class="xref std std-term">awaitable</span></a> 对象。<a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 会处理异步迭代器的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code> 方法所返回的可等待对象，直到其引发一个 <a class="reference internal" href="library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 异常。由 <span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 引入。</p>
</dd>
<dt id="term-attribute">attribute -- 属性<a class="headerlink" href="#term-attribute" title="Permalink to this term">¶</a></dt><dd><p>A value associated with an object which is usually referenced by name
using dotted expressions.
For example, if an object <em>o</em> has an attribute
<em>a</em> it would be referenced as <em>o.a</em>.</p>
<p>It is possible to give an object an attribute whose name is not an
identifier as defined by <a class="reference internal" href="reference/lexical_analysis.html#identifiers"><span class="std std-ref">标识符和关键字</span></a>, for example using
<a class="reference internal" href="library/functions.html#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>, if the object allows it.
Such an attribute will not be accessible using a dotted expression,
and would instead need to be retrieved with <a class="reference internal" href="library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>.</p>
</dd>
<dt id="term-awaitable">awaitable -- 可等待对象<a class="headerlink" href="#term-awaitable" title="Permalink to this term">¶</a></dt><dd><p>能在 <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 表达式中使用的对象。可以是 <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a> 或是具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code> 方法的对象。参见 <span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>。</p>
</dd>
<dt id="term-BDFL">BDFL<a class="headerlink" href="#term-BDFL" title="Permalink to this term">¶</a></dt><dd><p>“终身仁慈独裁者”的英文缩写，即 <a class="reference external" href="https://gvanrossum.github.io/">Guido van Rossum</a>，Python 的创造者。</p>
</dd>
<dt id="term-binary-file">binary file -- 二进制文件<a class="headerlink" href="#term-binary-file" title="Permalink to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a> 能够读写 <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">字节类对象</span></a>。二进制文件的例子包括以二进制模式（<code class="docutils literal notranslate"><span class="pre">'rb'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wb'</span></code> or <code class="docutils literal notranslate"><span class="pre">'rb+'</span></code>）打开的文件、<code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin.buffer</span></code>、<code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout.buffer</span></code> 以及 <a class="reference internal" href="library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> 和 <a class="reference internal" href="library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a> 的实例。</p>
<p>另请参见 <a class="reference internal" href="#term-text-file"><span class="xref std std-term">text file</span></a> 了解能够读写 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象的文件对象。</p>
</dd>
<dt id="term-borrowed-reference">borrowed reference -- 借入引用<a class="headerlink" href="#term-borrowed-reference" title="Permalink to this term">¶</a></dt><dd><p>在 Python 的 C API 中，借入引用是指一种对象引用。 它不会修改对象引用计数。 如果对象被销毁则它会成为一个无目标指针。 例如，垃圾回收器可以移除对象的最后一个 <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a> 来销毁它。</p>
<p>推荐在 <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a> 上调用 <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> 以将其原地转换为 <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a>，除非是当该对象无法在借入引用的最后一次使用之前被销毁。 <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> 函数可以被用来创建一个新的 <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a>。</p>
</dd>
<dt id="term-bytes-like-object">bytes-like object -- 字节类对象<a class="headerlink" href="#term-bytes-like-object" title="Permalink to this term">¶</a></dt><dd><p>支持 <a class="reference internal" href="c-api/buffer.html#bufferobjects"><span class="std std-ref">缓冲协议</span></a> 并且能导出 C-<a class="reference internal" href="#term-contiguous"><span class="xref std std-term">contiguous</span></a> 缓冲的对象。这包括所有 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>、<a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 和 <a class="reference internal" href="library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a> 对象，以及许多普通 <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 对象。字节类对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。</p>
<p>某些操作需要可变的二进制数据。这种对象在文档中常被称为“可读写字节类对象”。可变缓冲对象的例子包括 <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 以及 <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 的 <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>。其他操作要求二进制数据存放于不可变对象 (&quot;只读字节类对象&quot;)；这种对象的例子包括 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 以及 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象的 <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>。</p>
</dd>
<dt id="term-bytecode">bytecode -- 字节码<a class="headerlink" href="#term-bytecode" title="Permalink to this term">¶</a></dt><dd><p>Python 源代码会被编译为字节码，即 CPython 解释器中表示 Python 程序的内部代码。字节码还会缓存在 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 文件中，这样第二次执行同一文件时速度更快（可以免去将源码重新编译为字节码）。这种 &quot;中间语言&quot; 运行在根据字节码执行相应机器码的 <a class="reference internal" href="#term-virtual-machine"><span class="xref std std-term">virtual machine</span></a> 之上。请注意不同 Python 虚拟机上的字节码不一定通用，也不一定能在不同 Python 版本上兼容。</p>
<p>字节码指令列表可以在 <a class="reference internal" href="library/dis.html#bytecodes"><span class="std std-ref">dis 模块</span></a> 的文档中查看。</p>
</dd>
<dt id="term-callable">可调用对象（Callable）<a class="headerlink" href="#term-callable" title="Permalink to this term">¶</a></dt><dd><p>A callable is an object that can be called, possibly with a set
of arguments (see <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>), with the following syntax:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">callable</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>A <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a>, and by extension a <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>, is a callable.
An instance of a class that implements the <a class="reference internal" href="reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a>
method is also a callable.</p>
</dd>
<dt id="term-callback">callback -- 回调<a class="headerlink" href="#term-callback" title="Permalink to this term">¶</a></dt><dd><p>一个作为参数被传入以用以在未来的某个时刻被调用的子例程函数。</p>
</dd>
<dt id="term-class">class -- 类<a class="headerlink" href="#term-class" title="Permalink to this term">¶</a></dt><dd><p>用来创建用户定义对象的模板。类定义通常包含对该类的实例进行操作的方法定义。</p>
</dd>
<dt id="term-class-variable">class variable -- 类变量<a class="headerlink" href="#term-class-variable" title="Permalink to this term">¶</a></dt><dd><p>在类中定义的变量，并且仅限在类的层级上修改 (而不是在类的实例中修改)。</p>
</dd>
<dt id="term-complex-number">complex number -- 复数<a class="headerlink" href="#term-complex-number" title="Permalink to this term">¶</a></dt><dd><p>对普通实数系统的扩展，其中所有数字都被表示为一个实部和一个虚部的和。虚数是虚数单位（<code class="docutils literal notranslate"><span class="pre">-1</span></code> 的平方根）的实倍数，通常在数学中写为 <code class="docutils literal notranslate"><span class="pre">i</span></code>，在工程学中写为 <code class="docutils literal notranslate"><span class="pre">j</span></code>。Python 内置了对复数的支持，采用工程学标记方式；虚部带有一个 <code class="docutils literal notranslate"><span class="pre">j</span></code> 后缀，例如 <code class="docutils literal notranslate"><span class="pre">3+1j</span></code>。如果需要 <a class="reference internal" href="library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 模块内对象的对应复数版本，请使用 <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a>，复数的使用是一个比较高级的数学特性。如果你感觉没有必要，忽略它们也几乎不会有任何问题。</p>
</dd>
<dt id="term-context-manager">context manager -- 上下文管理器<a class="headerlink" href="#term-context-manager" title="Permalink to this term">¶</a></dt><dd><p>在 <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句中使用，通过定义 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code> 方法来控制环境状态的对象。参见 <span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a>。</p>
</dd>
<dt id="term-context-variable">context variable -- 上下文变量<a class="headerlink" href="#term-context-variable" title="Permalink to this term">¶</a></dt><dd><p>一种根据其所属的上下文可以具有不同的值的变量。 这类似于在线程局部存储中每个执行线程可以具有不同的变量值。 不过，对于上下文变量来说，一个执行线程中可能会有多个上下文，而上下文变量的主要用途是对并发异步任务中变量进行追踪。 参见 <a class="reference internal" href="library/contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>。</p>
</dd>
<dt id="term-contiguous">contiguous -- 连续<a class="headerlink" href="#term-contiguous" title="Permalink to this term">¶</a></dt><dd><p id="index-10">一个缓冲如果是 <em>C 连续</em> 或 <em>Fortran 连续</em> 就会被认为是连续的。零维缓冲是 C 和 Fortran 连续的。在一维数组中，所有条目必须在内存中彼此相邻地排列，采用从零开始的递增索引顺序。在多维 C-连续数组中，当按内存地址排列时用最后一个索引访问条目时速度最快。但是在 Fortran 连续数组中则是用第一个索引最快。</p>
</dd>
<dt id="term-coroutine">coroutine -- 协程<a class="headerlink" href="#term-coroutine" title="Permalink to this term">¶</a></dt><dd><p>协程是子例程的更一般形式。  子例程可以在某一点进入并在另一点退出。 协程则可以在许多不同的点上进入、退出和恢复。 它们可通过 <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 语句来实现。 参见 <span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>。</p>
</dd>
<dt id="term-coroutine-function">coroutine function -- 协程函数<a class="headerlink" href="#term-coroutine-function" title="Permalink to this term">¶</a></dt><dd><p>返回一个 <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a> 对象的函数。协程函数可通过 <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 语句来定义，并可能包含 <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>、<a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 和 <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 关键字。这些特性是由 <span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 引入的。</p>
</dd>
<dt id="term-CPython">CPython<a class="headerlink" href="#term-CPython" title="Permalink to this term">¶</a></dt><dd><p>Python 编程语言的规范实现，在 <a class="reference external" href="https://www.python.org">python.org</a> 上发布。&quot;CPython&quot; 一词用于在必要时将此实现与其他实现例如 Jython 或 IronPython 相区别。</p>
</dd>
<dt id="term-decorator">decorator -- 装饰器<a class="headerlink" href="#term-decorator" title="Permalink to this term">¶</a></dt><dd><p>返回值为另一个函数的函数，通常使用 <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code> 语法形式来进行函数变换。 装饰器的常见例子包括 <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 和 <a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>。</p>
<p>装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>同样的概念也适用于类，但通常较少这样使用。有关装饰器的详情可参见 <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">函数定义</span></a> 和 <a class="reference internal" href="reference/compound_stmts.html#class"><span class="std std-ref">类定义</span></a> 的文档。</p>
</dd>
<dt id="term-descriptor">descriptor -- 描述器<a class="headerlink" href="#term-descriptor" title="Permalink to this term">¶</a></dt><dd><p>任何定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code> 方法的对象。当一个类属性为描述器时，它的特殊绑定行为就会在属性查找时被触发。通常情况下，使用 <em>a.b</em> 来获取、设置或删除一个属性时会在 <em>a</em> 的类字典中查找名称为 <em>b</em> 的对象，但如果 <em>b</em> 是一个描述器，则会调用对应的描述器方法。理解描述器的概念是更深层次理解 Python 的关键，因为这是许多重要特性的基础，包括函数、方法、属性、类方法、静态方法以及对超类的引用等等。</p>
<p>有关描述器的方法的更多信息，请参阅 <a class="reference internal" href="reference/datamodel.html#descriptors"><span class="std std-ref">实现描述器</span></a> 或 <a class="reference internal" href="howto/descriptor.html#descriptorhowto"><span class="std std-ref">描述器使用指南</span></a>。</p>
</dd>
<dt id="term-dictionary">dictionary -- 字典<a class="headerlink" href="#term-dictionary" title="Permalink to this term">¶</a></dt><dd><p>一个关联数组，其中的任意键都映射到相应的值。键可以是任何具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code> 方法的对象。在 Perl 语言中称为 hash。</p>
</dd>
<dt id="term-dictionary-comprehension">dictionary comprehension -- 字典推导式<a class="headerlink" href="#term-dictionary-comprehension" title="Permalink to this term">¶</a></dt><dd><p>处理一个可迭代对象中的所有或部分元素并返回结果字典的一种紧凑写法。 <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{n:</span> <span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">range(10)}</span></code> 将生成一个由键 <code class="docutils literal notranslate"><span class="pre">n</span></code> 到值 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span></code> 的映射构成的字典。 参见 <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">列表、集合与字典的显示</span></a>。</p>
</dd>
<dt id="term-dictionary-view">dictionary view -- 字典视图<a class="headerlink" href="#term-dictionary-view" title="Permalink to this term">¶</a></dt><dd><p>从 <a class="reference internal" href="library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a> 和 <a class="reference internal" href="library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> 返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。要将字典视图强制转换为真正的列表，可使用 <code class="docutils literal notranslate"><span class="pre">list(dictview)</span></code>。参见 <a class="reference internal" href="library/stdtypes.html#dict-views"><span class="std std-ref">字典视图对象</span></a>。</p>
</dd>
<dt id="term-docstring">docstring -- 文档字符串<a class="headerlink" href="#term-docstring" title="Permalink to this term">¶</a></dt><dd><p>作为类、函数或模块之内的第一个表达式出现的字符串字面值。它在代码执行时会被忽略，但会被解释器识别并放入所在类、函数或模块的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 属性中。由于它可用于代码内省，因此是对象存放文档的规范位置。</p>
</dd>
<dt id="term-duck-typing">duck-typing -- 鸭子类型<a class="headerlink" href="#term-duck-typing" title="Permalink to this term">¶</a></dt><dd><p>指一种编程风格，它并不依靠查找对象类型来确定其是否具有正确的接口，而是直接调用或使用其方法或属性（“看起来像鸭子，叫起来也像鸭子，那么肯定就是鸭子。”）由于强调接口而非特定类型，设计良好的代码可通过允许多态替代来提升灵活性。鸭子类型避免使用 <a class="reference internal" href="library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 或 <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 检测。(但要注意鸭子类型可以使用 <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">抽象基类</span></a> 作为补充。)  而往往会采用 <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 检测或是 <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> 编程。</p>
</dd>
<dt id="term-EAFP">EAFP<a class="headerlink" href="#term-EAFP" title="Permalink to this term">¶</a></dt><dd><p>“求原谅比求许可更容易”的英文缩写。这种 Python 常用代码编写风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特点就是大量运用 <a class="reference internal" href="reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 和 <a class="reference internal" href="reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 语句。于其相对的则是所谓 <a class="reference internal" href="#term-LBYL"><span class="xref std std-term">LBYL</span></a> 风格，常见于 C 等许多其他语言。</p>
</dd>
<dt id="term-expression">expression -- 表达式<a class="headerlink" href="#term-expression" title="Permalink to this term">¶</a></dt><dd><p>可以求出某个值的语法单元。 换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。 与许多其他语言不同，并非所有语言构件都是表达式。 还存在不能被用作表达式的 <a class="reference internal" href="#term-statement"><span class="xref std std-term">statement</span></a>，例如 <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>。 赋值也是属于语句而非表达式。</p>
</dd>
<dt id="term-extension-module">extension module -- 扩展模块<a class="headerlink" href="#term-extension-module" title="Permalink to this term">¶</a></dt><dd><p>以 C 或 C++ 编写的模块，使用 Python 的 C API 来与语言核心以及用户代码进行交互。</p>
</dd>
<dt id="term-f-string">f-string -- f-字符串<a class="headerlink" href="#term-f-string" title="Permalink to this term">¶</a></dt><dd><p>带有 <code class="docutils literal notranslate"><span class="pre">'f'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'F'</span></code> 前缀的字符串字面值通常被称为“f-字符串”即 <a class="reference internal" href="reference/lexical_analysis.html#f-strings"><span class="std std-ref">格式化字符串字面值</span></a> 的简写。参见 <span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0498/"><strong>PEP 498</strong></a>。</p>
</dd>
<dt id="term-file-object">file object -- 文件对象<a class="headerlink" href="#term-file-object" title="Permalink to this term">¶</a></dt><dd><p>对外提供面向文件 API 以使用下层资源的对象（带有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> 这样的方法）。根据其创建方式的不同，文件对象可以处理对真实磁盘文件，对其他类型存储，或是对通讯设备的访问（例如标准输入/输出、内存缓冲区、套接字、管道等等）。文件对象也被称为 <em class="dfn">文件类对象</em> 或 <em class="dfn">流</em>。</p>
<p>实际上共有三种类别的文件对象: 原始 <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">二进制文件</span></a>, 缓冲 <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">二进制文件</span></a> 以及 <a class="reference internal" href="#term-text-file"><span class="xref std std-term">文本文件</span></a>。它们的接口定义均在 <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 模块中。创建文件对象的规范方式是使用 <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 函数。</p>
</dd>
<dt id="term-file-like-object">file-like object -- 文件类对象<a class="headerlink" href="#term-file-like-object" title="Permalink to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a> 的同义词。</p>
</dd>
<dt id="term-filesystem-encoding-and-error-handler">filesystem encoding and error handler  -- 文件系统编码格式与错误处理句柄<a class="headerlink" href="#term-filesystem-encoding-and-error-handler" title="Permalink to this term">¶</a></dt><dd><p>Python 用来从操作系统解码字节串和向操作系统编码 Unicode 的编码格式与错误处理句柄。</p>
<p>文件系统编码格式必须保证能成功解码长度在 128 以下的所有字节串。 如果文件系统编码格式无法提供此保证，则 API 函数可能会引发 <a class="reference internal" href="library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>。</p>
<p><a class="reference internal" href="library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> 和 <a class="reference internal" href="library/sys.html#sys.getfilesystemencodeerrors" title="sys.getfilesystemencodeerrors"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencodeerrors()</span></code></a> 函数可被用来获取文件系统编码格式与错误处理句柄。</p>
<p><a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a> 是在 Python 启动时通过 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code> 函数来配置的：请参阅 <a class="reference internal" href="c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a> 的 <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_encoding" title="PyConfig.filesystem_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_encoding</span></code></a> 和 <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_errors" title="PyConfig.filesystem_errors"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_errors</span></code></a> 等成员。</p>
<p>另请参见 <a class="reference internal" href="#term-locale-encoding"><span class="xref std std-term">locale encoding</span></a>。</p>
</dd>
<dt id="term-finder">finder -- 查找器<a class="headerlink" href="#term-finder" title="Permalink to this term">¶</a></dt><dd><p>一种会尝试查找被导入模块的 <a class="reference internal" href="#term-loader"><span class="xref std std-term">loader</span></a> 的对象。</p>
<p>从 Python 3.3 起存在两种类型的查找器: <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">元路径查找器</span></a> 配合 <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 使用，以及 <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path entry finders</span></a> 配合 <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 使用。</p>
<p>更多详情可参见 <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>, <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> 和 <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a>。</p>
</dd>
<dt id="term-floor-division">floor division -- 向下取整除法<a class="headerlink" href="#term-floor-division" title="Permalink to this term">¶</a></dt><dd><p>向下舍入到最接近的整数的数学除法。向下取整除法的运算符是 <code class="docutils literal notranslate"><span class="pre">//</span></code> 。例如，表达式 <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></code> 的计算结果是 <code class="docutils literal notranslate"><span class="pre">2</span></code> ，而与之相反的是浮点数的真正除法返回 <code class="docutils literal notranslate"><span class="pre">2.75</span></code> 。注意 <code class="docutils literal notranslate"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></code> 会返回 <code class="docutils literal notranslate"><span class="pre">-3</span></code> 因为这是 <code class="docutils literal notranslate"><span class="pre">-2.75</span></code> <em>向下</em> 舍入得到的结果。见 <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a> 。</p>
</dd>
<dt id="term-function">function -- 函数<a class="headerlink" href="#term-function" title="Permalink to this term">¶</a></dt><dd><p>可以向调用者返回某个值的一组语句。还可以向其传入零个或多个 <a class="reference internal" href="#term-argument"><span class="xref std std-term">参数</span></a> 并在函数体执行中被使用。另见 <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parameter</span></a>, <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> 和 <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">函数定义</span></a> 等节。</p>
</dd>
<dt id="term-function-annotation">function annotation -- 函数标注<a class="headerlink" href="#term-function-annotation" title="Permalink to this term">¶</a></dt><dd><p>即针对函数形参或返回值的 <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> 。</p>
<p>函数标注通常用于 <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">类型提示</span></a>：例如以下函数预期接受两个 <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 参数并预期返回一个 <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_two_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>函数标注语法的详解见 <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">函数定义</span></a> 一节。</p>
<p>参见 <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">variable annotation</span></a> 和 <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>，其中描述了此功能。 另请参阅 <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">对象注解属性的最佳实践</span></a> 以了解使用标的最佳实践。</p>
</dd>
<dt id="term-__future__">__future__<a class="headerlink" href="#term-__future__" title="Permalink to this term">¶</a></dt><dd><p><a class="reference internal" href="reference/simple_stmts.html#future"><span class="std std-ref">future 语句</span></a>, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">&lt;feature&gt;</span></code> 指示编译器使用将在未来的 Python 发布版中成为标准的语法和语义来编译当前模块。 <a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> 模块文档记录了可能 的 <em>feature</em> 取值。 通过导入此模块并对其变量求值，你可以看到每项新特性在何时被首次加入到该语言中以及它将（或已）在何时成为默认:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt id="term-garbage-collection">garbage collection -- 垃圾回收<a class="headerlink" href="#term-garbage-collection" title="Permalink to this term">¶</a></dt><dd><p>释放不再被使用的内存空间的过程。Python 是通过引用计数和一个能够检测和打破循环引用的循环垃圾回收器来执行垃圾回收的。可以使用 <a class="reference internal" href="library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 模块来控制垃圾回收器。</p>
</dd>
<dt id="index-19"><span id="term-generator"></span>generator -- 生成器<a class="headerlink" href="#index-19" title="Permalink to this term">¶</a></dt><dd><p>返回一个 <a class="reference internal" href="#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> 的函数。它看起来很像普通函数，不同点在于其包含 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 表达式以便产生一系列值供给 for-循环使用或是通过 <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 函数逐一获取。</p>
<p>通常是指生成器函数，但在某些情况下也可能是指 <em>生成器迭代器</em>。如果需要清楚表达具体含义，请使用全称以避免歧义。</p>
</dd>
<dt id="term-generator-iterator">generator iterator -- 生成器迭代器<a class="headerlink" href="#term-generator-iterator" title="Permalink to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a> 函数所创建的对象。</p>
<p>每个 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 会临时暂停处理，记住当前位置执行状态（包括局部变量和挂起的 try 语句）。当该 <em>生成器迭代器</em> 恢复时，它会从离开位置继续执行（这与每次调用都从新开始的普通函数差别很大）。</p>
</dd>
<dt id="index-20"><span id="term-generator-expression"></span>generator expression -- 生成器表达式<a class="headerlink" href="#index-20" title="Permalink to this term">¶</a></dt><dd><p>返回一个迭代器的表达式。 它看起来很像普通表达式后面带有定义了一个循环变量、范围的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 子句，以及一个可选的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 子句。 以下复合表达式会为外层函数生成一系列值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt id="term-generic-function">generic function -- 泛型函数<a class="headerlink" href="#term-generic-function" title="Permalink to this term">¶</a></dt><dd><p>为不同的类型实现相同操作的多个函数所组成的函数。在调用时会由调度算法来确定应该使用哪个实现。</p>
<p>另请参见 <a class="reference internal" href="#term-single-dispatch"><span class="xref std std-term">single dispatch</span></a> 术语表条目、<a class="reference internal" href="library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a> 装饰器以及 <span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-0443/"><strong>PEP 443</strong></a>。</p>
</dd>
<dt id="term-generic-type">generic type -- 泛型类型<a class="headerlink" href="#term-generic-type" title="Permalink to this term">¶</a></dt><dd><p>可被形参化的 <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a>；通常为诸如 <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 和 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 的 <a class="reference internal" href="reference/datamodel.html#sequence-types"><span class="std std-ref">container class</span></a>。 可用于 <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">类型注解</span></a> 和 <a class="reference internal" href="#term-annotation"><span class="xref std std-term">标注</span></a>。</p>
<p>更多细节，请参见 <a class="reference internal" href="library/stdtypes.html#types-genericalias"><span class="std std-ref">通用别名类型</span></a>, <span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-0483/"><strong>PEP 483</strong></a> , <span class="target" id="index-97"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> , <span class="target" id="index-98"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> , 和 <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 模块。</p>
</dd>
<dt id="term-GIL">GIL<a class="headerlink" href="#term-GIL" title="Permalink to this term">¶</a></dt><dd><p>参见 <a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a>。</p>
</dd>
<dt id="term-global-interpreter-lock">global interpreter lock -- 全局解释器锁<a class="headerlink" href="#term-global-interpreter-lock" title="Permalink to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 Python <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a>。此机制通过设置对象模型（包括 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 等重要内置类型）针对并发访问的隐式安全简化了 CPython 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。</p>
<p>However, some extension modules, either standard or third-party,
are designed so as to release the GIL when doing computationally intensive
tasks such as compression or hashing.  Also, the GIL is always released
when doing I/O.</p>
<p>创建一个（以更精细粒度来锁定共享数据的）“自由线程”解释器的努力从未获得成功，因为这会牺牲在普通单处理器情况下的性能。据信克服这种性能问题的措施将导致实现变得更复杂，从而更难以维护。</p>
</dd>
<dt id="term-hash-based-pyc">hash-based pyc -- 基于哈希的 pyc<a class="headerlink" href="#term-hash-based-pyc" title="Permalink to this term">¶</a></dt><dd><p>使用对应源文件的哈希值而非最后修改时间来确定其有效性的字节码缓存文件。 参见 <a class="reference internal" href="reference/import.html#pyc-invalidation"><span class="std std-ref">已缓存字节码的失效</span></a>。</p>
</dd>
<dt id="term-hashable">hashable -- 可哈希<a class="headerlink" href="#term-hashable" title="Permalink to this term">¶</a></dt><dd><p>一个对象的哈希值如果在其生命周期内绝不改变，就被称为 <em>可哈希</em> （它需要具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法），并可以同其他对象进行比较（它需要具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code> 方法）。可哈希对象必须具有相同的哈希值比较结果才会相同。</p>
<p>可哈希性使得对象能够作为字典键或集合成员使用，因为这些数据结构要在内部使用哈希值。</p>
<p>大多数 Python 中的不可变内置对象都是可哈希的；可变容器（例如列表或字典）都不可哈希；不可变容器（例如元组和 frozenset）仅当它们的元素均为可哈希时才是可哈希的。 用户定义类的实例对象默认是可哈希的。 它们在比较时一定不相同（除非是与自己比较），它们的哈希值的生成是基于它们的 <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>。</p>
</dd>
<dt id="term-IDLE">IDLE<a class="headerlink" href="#term-IDLE" title="Permalink to this term">¶</a></dt><dd><p>An Integrated Development and Learning Environment for Python.
<a class="reference internal" href="library/idle.html#idle"><span class="std std-ref">IDLE</span></a> is a basic editor and interpreter environment
which ships with the standard distribution of Python.</p>
</dd>
<dt id="term-immutable">immutable -- 不可变对象<a class="headerlink" href="#term-immutable" title="Permalink to this term">¶</a></dt><dd><p>具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。它们在需要常量哈希值的地方起着重要作用，例如作为字典中的键。</p>
</dd>
<dt id="term-import-path">import path -- 导入路径<a class="headerlink" href="#term-import-path" title="Permalink to this term">¶</a></dt><dd><p>由多个位置（或 <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">路径条目</span></a>）组成的列表，会被模块的 <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> 用来查找导入目标。在导入时，此位置列表通常来自 <a class="reference internal" href="library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>，但对次级包来说也可能来自上级包的 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 属性。</p>
</dd>
<dt id="term-importing">importing -- 导入<a class="headerlink" href="#term-importing" title="Permalink to this term">¶</a></dt><dd><p>令一个模块中的 Python 代码能为另一个模块中的 Python 代码所使用的过程。</p>
</dd>
<dt id="term-importer">importer -- 导入器<a class="headerlink" href="#term-importer" title="Permalink to this term">¶</a></dt><dd><p>查找并加载模块的对象；此对象既属于 <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> 又属于 <a class="reference internal" href="#term-loader"><span class="xref std std-term">loader</span></a>。</p>
</dd>
<dt id="term-interactive">interactive -- 交互<a class="headerlink" href="#term-interactive" title="Permalink to this term">¶</a></dt><dd><p>Python 带有一个交互式解释器，即你可以在解释器提示符后输入语句和表达式，立即执行并查看其结果。只需不带参数地启动 <code class="docutils literal notranslate"><span class="pre">python</span></code> 命令（也可以在你的计算机开始菜单中选择相应菜单项）。在测试新想法或检验模块和包的时候用这种方式会非常方便（请记得使用 <code class="docutils literal notranslate"><span class="pre">help(x)</span></code>）。</p>
</dd>
<dt id="term-interpreted">interpreted -- 解释型<a class="headerlink" href="#term-interpreted" title="Permalink to this term">¶</a></dt><dd><p>Python 一是种解释型语言，与之相对的是编译型语言，虽然两者的区别由于字节码编译器的存在而会有所模糊。这意味着源文件可以直接运行而不必显式地创建可执行文件再运行。解释型语言通常具有比编译型语言更短的开发/调试周期，但是其程序往往运行得更慢。参见 <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interactive</span></a>。</p>
</dd>
<dt id="term-interpreter-shutdown">interpreter shutdown -- 解释器关闭<a class="headerlink" href="#term-interpreter-shutdown" title="Permalink to this term">¶</a></dt><dd><p>当被要求关闭时，Python 解释器将进入一个特殊运行阶段并逐步释放所有已分配资源，例如模块和各种关键内部结构等。它还会多次调用 <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">垃圾回收器</span></a>。这会触发用户定义析构器或弱引用回调中的代码执行。在关闭阶段执行的代码可能会遇到各种异常，因为其所依赖的资源已不再有效（常见的例子有库模块或警告机制等）。</p>
<p>解释器需要关闭的主要原因有 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 模块或所运行的脚本已完成执行。</p>
</dd>
<dt id="term-iterable">iterable -- 可迭代对象<a class="headerlink" href="#term-iterable" title="Permalink to this term">¶</a></dt><dd><p>An object capable of returning its members one at a time. Examples of
iterables include all sequence types (such as <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
and <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) and some non-sequence types like <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>,
<a class="reference internal" href="#term-file-object"><span class="xref std std-term">file objects</span></a>, and objects of any classes you define
with an <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> method or with a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> method
that implements <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> semantics.</p>
<p>可迭代对象被可用于 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 循环以及许多其他需要一个序列的地方（<a class="reference internal" href="library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>、<a class="reference internal" href="library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> ...）。当一个可迭代对象作为参数传给内置函数 <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 时，它会返回该对象的迭代器。这种迭代器适用于对值集合的一次性遍历。在使用可迭代对象时，你通常不需要调用 <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 或者自己处理迭代器对象。<code class="docutils literal notranslate"><span class="pre">for</span></code> 语句会为你自动处理那些操作，创建一个临时的未命名变量用来在循环期间保存迭代器。参见 <a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterator</span></a>、<a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> 以及 <a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a>。</p>
</dd>
<dt id="term-iterator">iterator -- 迭代器<a class="headerlink" href="#term-iterator" title="Permalink to this term">¶</a></dt><dd><p>用来表示一连串数据流的对象。重复调用迭代器的 <a class="reference internal" href="library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法（或将其传给内置函数 <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>）将逐个返回流中的项。当没有数据可用时则将引发 <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常。到这时迭代器对象中的数据项已耗尽，继续调用其 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> 方法只会再次引发 <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常。迭代器必须具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> 方法用来返回该迭代器对象自身，因此迭代器必定也是可迭代对象，可被用于其他可迭代对象适用的大部分场合。一个显著的例外是那些会多次重复访问迭代项的代码。容器对象（例如 <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>）在你每次向其传入 <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 函数或是在 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 循环中使用它时都会产生一个新的迭代器。如果在此情况下你尝试用迭代器则会返回在之前迭代过程中被耗尽的同一迭代器对象，使其看起来就像是一个空容器。</p>
<p>更多信息可查看 <a class="reference internal" href="library/stdtypes.html#typeiter"><span class="std std-ref">迭代器类型</span></a>。</p>
<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> CPython 没有统一应用迭代器定义 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> 的要求。</p>
</div>
</dd>
<dt id="term-key-function">key function -- 键函数<a class="headerlink" href="#term-key-function" title="Permalink to this term">¶</a></dt><dd><p>键函数或称整理函数，是能够返回用于排序或排位的值的可调用对象。例如，<a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.strxfrm()</span></code></a> 可用于生成一个符合特定区域排序约定的排序键。</p>
<p>Python 中有许多工具都允许用键函数来控制元素的排位或分组方式。其中包括 <a class="reference internal" href="library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.merge" title="heapq.merge"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.merge()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nsmallest()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nlargest()</span></code></a> 以及 <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a>。</p>
<p>There are several ways to create a key function.  For example. the
<a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.lower()</span></code></a> method can serve as a key function for case insensitive
sorts.  Alternatively, a key function can be built from a
<a class="reference internal" href="reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> expression such as <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></code>.  Also,
<a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.attrgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.itemgetter()</span></code></a>, and
<a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.methodcaller()</span></code></a> are three key function constructors.  See the <a class="reference internal" href="howto/sorting.html#sortinghowto"><span class="std std-ref">Sorting HOW TO</span></a> for examples of how to create and use key functions.</p>
</dd>
<dt id="term-keyword-argument">keyword argument -- 关键字参数<a class="headerlink" href="#term-keyword-argument" title="Permalink to this term">¶</a></dt><dd><p>参见 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>。</p>
</dd>
<dt id="term-lambda">lambda<a class="headerlink" href="#term-lambda" title="Permalink to this term">¶</a></dt><dd><p>由一个单独 <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a> 构成的匿名内联函数，表达式会在调用时被求值。创建 lambda 函数的句法为 <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">[parameters]:</span> <span class="pre">expression</span></code></p>
</dd>
<dt id="term-LBYL">LBYL<a class="headerlink" href="#term-LBYL" title="Permalink to this term">¶</a></dt><dd><p>“先查看后跳跃”的英文缩写。这种代码编写风格会在进行调用或查找之前显式地检查前提条件。此风格与 <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> 方式恰成对比，其特点是大量使用 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 语句。</p>
<p>在多线程环境中，LBYL 方式会导致“查看”和“跳跃”之间发生条件竞争风险。例如，以下代码 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">mapping:</span> <span class="pre">return</span> <span class="pre">mapping[key]</span></code> 可能由于在检查操作之后其他线程从 <em>mapping</em> 中移除了 <em>key</em> 而出错。这种问题可通过加锁或使用 EAFP 方式来解决。</p>
</dd>
<dt id="term-locale-encoding">locale encoding -- 语言区域编码格式<a class="headerlink" href="#term-locale-encoding" title="Permalink to this term">¶</a></dt><dd><p>On Unix, it is the encoding of the LC_CTYPE locale. It can be set with
<a class="reference internal" href="library/locale.html#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.setlocale(locale.LC_CTYPE,</span> <span class="pre">new_locale)</span></code></a>.</p>
<p>On Windows, it is the ANSI code page (ex: <code class="docutils literal notranslate"><span class="pre">&quot;cp1252&quot;</span></code>).</p>
<p>On Android and VxWorks, Python uses <code class="docutils literal notranslate"><span class="pre">&quot;utf-8&quot;</span></code> as the locale encoding.</p>
<p><code class="docutils literal notranslate"><span class="pre">locale.getencoding()</span></code> can be used to get the locale encoding.</p>
<p>See also the <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p>
</dd>
<dt id="term-list">list -- 列表<a class="headerlink" href="#term-list" title="Permalink to this term">¶</a></dt><dd><p>Python 内置的一种 <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>。虽然名为列表，但更类似于其他语言中的数组而非链接列表，因为访问元素的时间复杂度为 O(1)。</p>
</dd>
<dt id="term-list-comprehension">list comprehension -- 列表推导式<a class="headerlink" href="#term-list-comprehension" title="Permalink to this term">¶</a></dt><dd><p>处理一个序列中的所有或部分元素并返回结果列表的一种紧凑写法。<code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">['{:#04x}'.format(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></code> 将生成一个 0 到 255 范围内的十六进制偶数对应字符串（0x..）的列表。其中 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 子句是可选的，如果省略则 <code class="docutils literal notranslate"><span class="pre">range(256)</span></code> 中的所有元素都会被处理。</p>
</dd>
<dt id="term-loader">loader -- 加载器<a class="headerlink" href="#term-loader" title="Permalink to this term">¶</a></dt><dd><p>负责加载模块的对象。它必须定义名为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code> 的方法。加载器通常由一个 <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> 返回。详情参见 <span class="target" id="index-99"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>，对于 <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> 可参见 <a class="reference internal" href="library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.Loader</span></code></a>。</p>
</dd>
<dt id="term-magic-method">magic method -- 魔术方法<a class="headerlink" href="#term-magic-method" title="Permalink to this term">¶</a></dt><dd><p id="index-26"><a class="reference internal" href="#term-special-method"><span class="xref std std-term">special method</span></a> 的非正式同义词 。</p>
</dd>
<dt id="term-mapping">mapping -- 映射<a class="headerlink" href="#term-mapping" title="Permalink to this term">¶</a></dt><dd><p>A container object that supports arbitrary key lookups and implements the
methods specified in the <a class="reference internal" href="library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> or
<a class="reference internal" href="library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a>
<a class="reference internal" href="library/collections.abc.html#collections-abstract-base-classes"><span class="std std-ref">abstract base classes</span></a>.  Examples
include <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>,
<a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> and <a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>.</p>
</dd>
<dt id="term-meta-path-finder">meta path finder -- 元路径查找器<a class="headerlink" href="#term-meta-path-finder" title="Permalink to this term">¶</a></dt><dd><p><a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 的搜索所返回的 <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a>。元路径查找器与 <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path entry finders</span></a> 存在关联但并不相同。</p>
<p>请查看 <a class="reference internal" href="library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> 了解元路径查找器所实现的方法。</p>
</dd>
<dt id="term-metaclass">metaclass -- 元类<a class="headerlink" href="#term-metaclass" title="Permalink to this term">¶</a></dt><dd><p>一种用于创建类的类。类定义包含类名、类字典和基类列表。元类负责接受上述三个参数并创建相应的类。大部分面向对象的编程语言都会提供一个默认实现。Python 的特别之处在于可以创建自定义元类。大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。</p>
<p>更多详情参见 <a class="reference internal" href="reference/datamodel.html#metaclasses"><span class="std std-ref">元类</span></a>。</p>
</dd>
<dt id="term-method">method -- 方法<a class="headerlink" href="#term-method" title="Permalink to this term">¶</a></dt><dd><p>在类内部定义的函数。如果作为该类的实例的一个属性来调用，方法将会获取实例对象作为其第一个 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> (通常命名为 <code class="docutils literal notranslate"><span class="pre">self</span></code>)。参见 <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> 和 <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">nested scope</span></a>。</p>
</dd>
<dt id="term-method-resolution-order">method resolution order -- 方法解析顺序<a class="headerlink" href="#term-method-resolution-order" title="Permalink to this term">¶</a></dt><dd><p>方法解析顺序就是在查找成员时搜索全部基类所用的先后顺序。请查看 <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">Python 2.3 方法解析顺序</a> 了解自 2.3 版起 Python 解析器所用相关算法的详情。</p>
</dd>
<dt id="term-module">module -- 模块<a class="headerlink" href="#term-module" title="Permalink to this term">¶</a></dt><dd><p>此对象是 Python 代码的一种组织单位。各模块具有独立的命名空间，可包含任意 Python 对象。模块可通过 <a class="reference internal" href="#term-importing"><span class="xref std std-term">importing</span></a> 操作被加载到 Python 中。</p>
<p>另见 <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a>。</p>
</dd>
<dt id="term-module-spec">module spec -- 模块规格<a class="headerlink" href="#term-module-spec" title="Permalink to this term">¶</a></dt><dd><p>一个命名空间，其中包含用于加载模块的相关导入信息。是 <a class="reference internal" href="library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code></a> 的实例。</p>
</dd>
<dt id="term-MRO">MRO<a class="headerlink" href="#term-MRO" title="Permalink to this term">¶</a></dt><dd><p>参见 <a class="reference internal" href="#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a>。</p>
</dd>
<dt id="term-mutable">mutable -- 可变对象<a class="headerlink" href="#term-mutable" title="Permalink to this term">¶</a></dt><dd><p>可变对象可以在其 <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 保持固定的情况下改变其取值。另请参见 <a class="reference internal" href="#term-immutable"><span class="xref std std-term">immutable</span></a>。</p>
</dd>
<dt id="term-named-tuple">named tuple -- 具名元组<a class="headerlink" href="#term-named-tuple" title="Permalink to this term">¶</a></dt><dd><p>术语“具名元组”可用于任何继承自元组，并且其中的可索引元素还能使用名称属性来访问的类型或类。 这样的类型或类还可能拥有其他特性。</p>
<p>有些内置类型属于具名元组，包括 <a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> 和 <a class="reference internal" href="library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> 的返回值。 另一个例子是 <a class="reference internal" href="library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># indexed access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max_exp</span>              <span class="c1"># named field access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>   <span class="c1"># kind of tuple</span>
<span class="go">True</span>
</pre></div>
</div>
<p>有些具名元组是内置类型（例如上面的例子）。 此外，具名元组还可通过常规类定义从 <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 继承并定义名称字段的方式来创建。 这样的类可以手工编写，或者使用工厂函数 <a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 创建。 后一种方式还会添加一些手工编写或内置具名元组所没有的额外方法。</p>
</dd>
<dt id="term-namespace">namespace -- 命名空间<a class="headerlink" href="#term-namespace" title="Permalink to this term">¶</a></dt><dd><p>命名空间是存放变量的场所。命名空间有局部、全局和内置的，还有对象中的嵌套命名空间（在方法之内）。命名空间通过防止命名冲突来支持模块化。例如，函数 <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">builtins.open</span></code></a> 与 <a class="reference internal" href="library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> 可通过各自的命名空间来区分。命名空间还通过明确哪个模块实现那个函数来帮助提高可读性和可维护性。例如，<a class="reference internal" href="library/random.html#random.seed" title="random.seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.seed()</span></code></a> 或 <a class="reference internal" href="library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> 这种写法明确了这些函数是由 <a class="reference internal" href="library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> 与 <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> 模块分别实现的。</p>
</dd>
<dt id="term-namespace-package">namespace package -- 命名空间包<a class="headerlink" href="#term-namespace-package" title="Permalink to this term">¶</a></dt><dd><p><span class="target" id="index-100"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> 所引入的一种仅被用作子包的容器的 <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a>，命名空间包可以没有实体表示物，其描述方式与 <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a> 不同，因为它们没有 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件。</p>
<p>另可参见 <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a>。</p>
</dd>
<dt id="term-nested-scope">nested scope -- 嵌套作用域<a class="headerlink" href="#term-nested-scope" title="Permalink to this term">¶</a></dt><dd><p>在一个定义范围内引用变量的能力。例如，在另一函数之内定义的函数可以引用前者的变量。请注意嵌套作用域默认只对引用有效而对赋值无效。局部变量的读写都受限于最内层作用域。类似的，全局变量的读写则作用于全局命名空间。通过 <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 关键字可允许写入外层作用域。</p>
</dd>
<dt id="term-new-style-class">new-style class -- 新式类<a class="headerlink" href="#term-new-style-class" title="Permalink to this term">¶</a></dt><dd><p>对于目前已被应于所有类对象的类形式的旧称谓。在早先的 Python 版本中，只有新式类能够使用 Python 新增的更灵活特性，例如 <a class="reference internal" href="reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>、描述符、特征属性、<code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code>、类方法和静态方法等。</p>
</dd>
<dt id="term-object">object -- 对象<a class="headerlink" href="#term-object" title="Permalink to this term">¶</a></dt><dd><p>任何具有状态（属性或值）以及预定义行为（方法）的数据。object 也是任何 <a class="reference internal" href="#term-new-style-class"><span class="xref std std-term">new-style class</span></a> 的最顶层基类名。</p>
</dd>
<dt id="term-package">package -- 包<a class="headerlink" href="#term-package" title="Permalink to this term">¶</a></dt><dd><p>A Python <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a> which can contain submodules or recursively,
subpackages.  Technically, a package is a Python module with a
<code class="docutils literal notranslate"><span class="pre">__path__</span></code> attribute.</p>
<p>另参见 <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a> 和 <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a>。</p>
</dd>
<dt id="term-parameter">parameter -- 形参<a class="headerlink" href="#term-parameter" title="Permalink to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> （或方法）定义中的命名实体，它指定函数可以接受的一个 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> （或在某些情况下，多个实参）。有五种形参：</p>
<ul>
<li><p><em class="dfn">positional-or-keyword</em>：位置或关键字，指定一个可以作为 <a class="reference internal" href="#term-argument"><span class="xref std std-term">位置参数</span></a> 传入也可以作为 <a class="reference internal" href="#term-argument"><span class="xref std std-term">关键字参数</span></a> 传入的实参。这是默认的形参类型，例如下面的 <em>foo</em> 和 <em>bar</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="positional-only-parameter">
<li><p><em class="dfn">positional-only</em>：仅限位置，指定一个只能通过位置传入的参数。 仅限位置形参可通过在函数定义的形参列表中它们之后包含一个 <code class="docutils literal notranslate"><span class="pre">/</span></code> 字符来定义，例如下面的 <em>posonly1</em> 和 <em>posonly2</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">posonly1</span><span class="p">,</span> <span class="n">posonly2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">positional_or_keyword</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="keyword-only-parameter">
<li><p><em class="dfn">keyword-only</em>：仅限关键字，指定一个只能通过关键字传入的参数。仅限关键字形参可通过在函数定义的形参列表中包含单个可变位置形参或者在多个可变位置形参之前放一个 <code class="docutils literal notranslate"><span class="pre">*</span></code> 来定义，例如下面的 <em>kw_only1</em> 和 <em>kw_only2</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw_only1</span><span class="p">,</span> <span class="n">kw_only2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">var-positional</em>：可变位置，指定可以提供由一个任意数量的位置参数构成的序列（附加在其他形参已接受的位置参数之后）。这种形参可通过在形参名称前加缀 <code class="docutils literal notranslate"><span class="pre">*</span></code> 来定义，例如下面的 <em>args</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">var-keyword</em>：可变关键字，指定可以提供任意数量的关键字参数（附加在其他形参已接受的关键字参数之后）。这种形参可通过在形参名称前加缀 <code class="docutils literal notranslate"><span class="pre">**</span></code> 来定义，例如上面的 <em>kwargs</em>。</p></li>
</ul>
<p>形参可以同时指定可选和必选参数，也可以为某些可选参数指定默认值。</p>
<p>另参见 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> 术语表条目、<a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">参数与形参的区别</span></a> 中的常见问题、<a class="reference internal" href="library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Parameter</span></code></a> 类、<a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">函数定义</span></a> 一节以及 <span class="target" id="index-101"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>。</p>
</dd>
<dt id="term-path-entry">path entry -- 路径入口<a class="headerlink" href="#term-path-entry" title="Permalink to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-import-path"><span class="xref std std-term">import path</span></a> 中的一个单独位置，会被 <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> 用来查找要导入的模块。</p>
</dd>
<dt id="term-path-entry-finder">path entry finder -- 路径入口查找器<a class="headerlink" href="#term-path-entry-finder" title="Permalink to this term">¶</a></dt><dd><p>任一可调用对象使用 <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (即 <a class="reference internal" href="#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a>) 返回的 <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a>，此种对象能通过 <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path entry</span></a> 来定位模块。</p>
<p>请参看 <a class="reference internal" href="library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> 以了解路径入口查找器所实现的各个方法。</p>
</dd>
<dt id="term-path-entry-hook">path entry hook -- 路径入口钩子<a class="headerlink" href="#term-path-entry-hook" title="Permalink to this term">¶</a></dt><dd><p>一种可调用对象，在知道如何查找特定 <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path entry</span></a> 中的模块的情况下能够使用 <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hook</span></code> 列表返回一个 <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>。</p>
</dd>
<dt id="term-path-based-finder">path based finder -- 基于路径的查找器<a class="headerlink" href="#term-path-based-finder" title="Permalink to this term">¶</a></dt><dd><p>默认的一种 <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">元路径查找器</span></a>，可在一个 <a class="reference internal" href="#term-import-path"><span class="xref std std-term">import path</span></a> 中查找模块。</p>
</dd>
<dt id="term-path-like-object">path-like object -- 路径类对象<a class="headerlink" href="#term-path-like-object" title="Permalink to this term">¶</a></dt><dd><p>代表一个文件系统路径的对象。类路径对象可以是一个表示路径的 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或者 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象，还可以是一个实现了 <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 协议的对象。一个支持 <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 协议的对象可通过调用 <a class="reference internal" href="library/os.html#os.fspath" title="os.fspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a> 函数转换为 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或者 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型的文件系统路径；<a class="reference internal" href="library/os.html#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsdecode()</span></code></a> 和 <a class="reference internal" href="library/os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a> 可被分别用来确保获得 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型的结果。此对象是由 <span class="target" id="index-102"></span><a class="pep reference external" href="https://peps.python.org/pep-0519/"><strong>PEP 519</strong></a> 引入的。</p>
</dd>
<dt id="term-PEP">PEP<a class="headerlink" href="#term-PEP" title="Permalink to this term">¶</a></dt><dd><p>“Python 增强提议”的英文缩写。一个 PEP 就是一份设计文档，用来向 Python 社区提供信息，或描述一个 Python 的新增特性及其进度或环境。PEP 应当提供精确的技术规格和所提议特性的原理说明。</p>
<p>PEP 应被作为提出主要新特性建议、收集社区对特定问题反馈以及为必须加入 Python 的设计决策编写文档的首选机制。PEP 的作者有责任在社区内部建立共识，并应将不同意见也记入文档。</p>
<p>参见 <span class="target" id="index-103"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a>。</p>
</dd>
<dt id="term-portion">portion -- 部分<a class="headerlink" href="#term-portion" title="Permalink to this term">¶</a></dt><dd><p>构成一个命名空间包的单个目录内文件集合（也可能存放于一个 zip 文件内），具体定义见 <span class="target" id="index-104"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>。</p>
</dd>
<dt id="term-positional-argument">positional argument -- 位置参数<a class="headerlink" href="#term-positional-argument" title="Permalink to this term">¶</a></dt><dd><p>参见 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>。</p>
</dd>
<dt id="term-provisional-API">provisional API -- 暂定 API<a class="headerlink" href="#term-provisional-API" title="Permalink to this term">¶</a></dt><dd><p>暂定 API 是指被有意排除在标准库的向后兼容性保证之外的应用编程接口。虽然此类接口通常不会再有重大改变，但只要其被标记为暂定，就可能在核心开发者确定有必要的情况下进行向后不兼容的更改（甚至包括移除该接口）。此种更改并不会随意进行 -- 仅在 API 被加入之前未考虑到的严重基础性缺陷被发现时才可能会这样做。</p>
<p>即便是对暂定 API 来说，向后不兼容的更改也会被视为“最后的解决方案” —— 任何问题被确认时都会尽可能先尝试找到一种向后兼容的解决方案。</p>
<p>这种处理过程允许标准库持续不断地演进，不至于被有问题的长期性设计缺陷所困。详情见 <span class="target" id="index-105"></span><a class="pep reference external" href="https://peps.python.org/pep-0411/"><strong>PEP 411</strong></a>。</p>
</dd>
<dt id="term-provisional-package">provisional package -- 暂定包<a class="headerlink" href="#term-provisional-package" title="Permalink to this term">¶</a></dt><dd><p>参见 <a class="reference internal" href="#term-provisional-API"><span class="xref std std-term">provisional API</span></a>。</p>
</dd>
<dt id="term-Python-3000">Python 3000<a class="headerlink" href="#term-Python-3000" title="Permalink to this term">¶</a></dt><dd><p>Python 3.x 发布路线的昵称（这个名字在版本 3 的发布还遥遥无期的时候就已出现了）。有时也被缩写为“Py3k”。</p>
</dd>
<dt id="term-Pythonic">Pythonic<a class="headerlink" href="#term-Pythonic" title="Permalink to this term">¶</a></dt><dd><p>指一个思路或一段代码紧密遵循了 Python 语言最常用的风格和理念，而不是使用其他语言中通用的概念来实现代码。例如，Python 的常用风格是使用 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 语句循环来遍历一个可迭代对象中的所有元素。许多其他语言没有这样的结构，因此不熟悉 Python 的人有时会选择使用一个数字计数器:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>而相应的更简洁更 Pythonic 的方法是这样的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt id="term-qualified-name">qualified name -- 限定名称<a class="headerlink" href="#term-qualified-name" title="Permalink to this term">¶</a></dt><dd><p>一个以点号分隔的名称，显示从模块的全局作用域到该模块中定义的某个类、函数或方法的“路径”，相关定义见 <span class="target" id="index-106"></span><a class="pep reference external" href="https://peps.python.org/pep-3155/"><strong>PEP 3155</strong></a>。对于最高层级的函数和类，限定名称与对象名称一致:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">meth</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D.meth&#39;</span>
</pre></div>
</div>
<p>当被用于引用模块时，<em>完整限定名称</em> 意为标示该模块的以点号分隔的整个路径，其中包含其所有的父包，例如 <code class="docutils literal notranslate"><span class="pre">email.mime.text</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">email.mime.text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;email.mime.text&#39;</span>
</pre></div>
</div>
</dd>
<dt id="term-reference-count">reference count -- 引用计数<a class="headerlink" href="#term-reference-count" title="Permalink to this term">¶</a></dt><dd><p>The number of references to an object.  When the reference count of an
object drops to zero, it is deallocated.  Reference counting is
generally not visible to Python code, but it is a key element of the
<a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> implementation.  Programmers can call the
<a class="reference internal" href="library/sys.html#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrefcount()</span></code></a> function to return the
reference count for a particular object.</p>
</dd>
<dt id="term-regular-package">regular package -- 常规包<a class="headerlink" href="#term-regular-package" title="Permalink to this term">¶</a></dt><dd><p>传统型的 <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a>，例如包含有一个 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件的目录。</p>
<p>另参见 <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a>。</p>
</dd>
<dt id="term-__slots__">__slots__<a class="headerlink" href="#term-__slots__" title="Permalink to this term">¶</a></dt><dd><p>一种写在类内部的声明，通过预先声明实例属性等对象并移除实例字典来节省内存。虽然这种技巧很流行，但想要用好却并不容易，最好是只保留在少数情况下采用，例如极耗内存的应用程序，并且其中包含大量实例。</p>
</dd>
<dt id="term-sequence">sequence -- 序列<a class="headerlink" href="#term-sequence" title="Permalink to this term">¶</a></dt><dd><p>一种 <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a>，它支持通过 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> 特殊方法来使用整数索引进行高效的元素访问，并定义了一个返回序列长度的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> 方法。内置的序列类型有 <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>、<a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>。注意虽然 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 也支持 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>，但它被认为属于映射而非序列，因为它查找时使用任意的 <a class="reference internal" href="#term-immutable"><span class="xref std std-term">immutable</span></a> 键而非整数。</p>
<p><a class="reference internal" href="library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 抽象基类定义了一个更丰富的接口，它在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> 之外又添加了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code>。 实现此扩展接口的类型可以使用 <a class="reference internal" href="library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code></a> 来显式地注册。</p>
</dd>
<dt id="term-set-comprehension">set comprehension -- 集合推导式<a class="headerlink" href="#term-set-comprehension" title="Permalink to this term">¶</a></dt><dd><p>处理一个可迭代对象中的所有或部分元素并返回结果集合的一种紧凑写法。 <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">'abracadabra'</span> <span class="pre">if</span> <span class="pre">c</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">'abc'}</span></code> 将生成字符串集合 <code class="docutils literal notranslate"><span class="pre">{'r',</span> <span class="pre">'d'}</span></code>。 参见 <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">列表、集合与字典的显示</span></a>。</p>
</dd>
<dt id="term-single-dispatch">single dispatch -- 单分派<a class="headerlink" href="#term-single-dispatch" title="Permalink to this term">¶</a></dt><dd><p>一种 <a class="reference internal" href="#term-generic-function"><span class="xref std std-term">generic function</span></a> 分派形式，其实现是基于单个参数的类型来选择的。</p>
</dd>
<dt id="term-slice">slice -- 切片<a class="headerlink" href="#term-slice" title="Permalink to this term">¶</a></dt><dd><p>通常只包含了特定 <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> 的一部分的对象。切片是通过使用下标标记来创建的，在 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 中给出几个以冒号分隔的数字，例如 <code class="docutils literal notranslate"><span class="pre">variable_name[1:3:5]</span></code>。方括号（下标）标记在内部使用 <a class="reference internal" href="library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> 对象。</p>
</dd>
<dt id="term-special-method">special method -- 特殊方法<a class="headerlink" href="#term-special-method" title="Permalink to this term">¶</a></dt><dd><p id="index-34">一种由 Python 隐式调用的方法，用来对某个类型执行特定操作例如相加等等。这种方法的名称的首尾都为双下划线。特殊方法的文档参见 <a class="reference internal" href="reference/datamodel.html#specialnames"><span class="std std-ref">特殊方法名称</span></a>。</p>
</dd>
<dt id="term-statement">statement -- 语句<a class="headerlink" href="#term-statement" title="Permalink to this term">¶</a></dt><dd><p>语句是程序段（一个代码“块”）的组成单位。一条语句可以是一个 <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a> 或某个带有关键字的结构，例如 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>、<a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 或 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>。</p>
</dd>
<dt id="term-strong-reference">strong reference -- 强引用<a class="headerlink" href="#term-strong-reference" title="Permalink to this term">¶</a></dt><dd><p>在 Python 的 C API 中，强引用是对象引用的一种，当它被创建时将会增加对象引用计数而当它被删除时则会减少对象引用计数。</p>
<p><a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> 函数可被用于创建一个对象的强引用。 通常，必须在退出某个强引用的作用域时在该强引用上调用 <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> 函数，以避免引用的泄漏。</p>
<p>另请参阅 <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a>。</p>
</dd>
<dt id="term-text-encoding">text encoding -- 文本编码<a class="headerlink" href="#term-text-encoding" title="Permalink to this term">¶</a></dt><dd><p>在Python中，一个字符串是一串 Unicode 代码点（范围为``U+0000``--<code class="docutils literal notranslate"><span class="pre">U+10FFFF</span></code>）。为了存储或传输一个字符串，它需要被序列化为一串字节。</p>
<p>将一个字符串序列化为一个字节序列被称为 &quot;编码&quot;，而从字节序列中重新创建字符串被称为 &quot;解码&quot;。</p>
<p>有各种不同的文本序列化 <a class="reference internal" href="library/codecs.html#standard-encodings"><span class="std std-ref">编码器</span></a> ，它们被统称为 &quot;文本编码&quot;。</p>
</dd>
<dt id="term-text-file">text file -- 文本文件<a class="headerlink" href="#term-text-file" title="Permalink to this term">¶</a></dt><dd><p>一种能够读写 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象的 <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a>。通常一个文本文件实际是访问一个面向字节的数据流并自动处理 <a class="reference internal" href="#term-text-encoding"><span class="xref std std-term">text encoding</span></a>。文本文件的例子包括以文本模式（<code class="docutils literal notranslate"><span class="pre">'r'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'w'</span></code>）打开的文件、<a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>、<a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> 以及 <a class="reference internal" href="library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> 的实例。</p>
<p>另请参看 <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">binary file</span></a> 了解能够读写 <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">字节类对象</span></a> 的文件对象。</p>
</dd>
<dt id="term-triple-quoted-string">triple-quoted string -- 三引号字符串<a class="headerlink" href="#term-triple-quoted-string" title="Permalink to this term">¶</a></dt><dd><p>首尾各带三个连续双引号（&quot;）或者单引号（'）的字符串。它们在功能上与首尾各用一个引号标注的字符串没有什么不同，但是有多种用处。它们允许你在字符串内包含未经转义的单引号和双引号，并且可以跨越多行而无需使用连接符，在编写文档字符串时特别好用。</p>
</dd>
<dt id="term-type">type -- 类型<a class="headerlink" href="#term-type" title="Permalink to this term">¶</a></dt><dd><p>类型决定一个 Python 对象属于什么种类；每个对象都具有一种类型。要知道对象的类型，可以访问它的 <a class="reference internal" href="library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> 属性，或是通过 <code class="docutils literal notranslate"><span class="pre">type(obj)</span></code> 来获取。</p>
</dd>
<dt id="term-type-alias">type alias -- 类型别名<a class="headerlink" href="#term-type-alias" title="Permalink to this term">¶</a></dt><dd><p>一个类型的同义词，创建方式是把类型赋值给特定的标识符。</p>
<p>类型别名的作用是简化 <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">类型注解</span></a>。例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span>
        <span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>可以这样提高可读性:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span><span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>参见 <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 和 <span class="target" id="index-107"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>，其中有对此功能的详细描述。</p>
</dd>
<dt id="term-type-hint">type hint -- 类型注解<a class="headerlink" href="#term-type-hint" title="Permalink to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> 为变量、类属性、函数的形参或返回值指定预期的类型。</p>
<p>类型注解属于可选项，Python 不要求提供，但其可对静态类型分析工具起作用，并可协助 IDE 实现代码补全与重构。</p>
<p>全局变量、类属性和函数的类型注解可以使用 <a class="reference internal" href="library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a> 来访问，但局部变量则不可以。</p>
<p>参见 <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 和 <span class="target" id="index-108"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>，其中有对此功能的详细描述。</p>
</dd>
<dt id="term-universal-newlines">universal newlines -- 通用换行<a class="headerlink" href="#term-universal-newlines" title="Permalink to this term">¶</a></dt><dd><p>一种解读文本流的方式，将以下所有符号都识别为行结束标志：Unix 的行结束约定 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>、Windows 的约定 <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code> 以及旧版 Macintosh 的约定 <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>。参见 <span class="target" id="index-109"></span><a class="pep reference external" href="https://peps.python.org/pep-0278/"><strong>PEP 278</strong></a> 和 <span class="target" id="index-110"></span><a class="pep reference external" href="https://peps.python.org/pep-3116/"><strong>PEP 3116</strong></a> 和 <a class="reference internal" href="library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.splitlines()</span></code></a> 了解更多用法说明。</p>
</dd>
<dt id="term-variable-annotation">variable annotation -- 变量标注<a class="headerlink" href="#term-variable-annotation" title="Permalink to this term">¶</a></dt><dd><p>对变量或类属性的 <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a>。</p>
<p>在标注变量或类属性时，还可选择为其赋值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;annotation&#39;</span>
</pre></div>
</div>
<p>变量标注通常被用作 <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">类型注解</span></a>：例如以下变量预期接受 <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 类型的值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>变量标注语法的详细解释见 <a class="reference internal" href="reference/simple_stmts.html#annassign"><span class="std std-ref">带标注的赋值语句</span></a> 一节。</p>
<p>参见 <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">function annotation</span></a>, <span class="target" id="index-111"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 和 <span class="target" id="index-112"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>，其中描述了此功能。 另请参阅 <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">对象注解属性的最佳实践</span></a> 以了解使用标注的最佳实践。</p>
</dd>
<dt id="term-virtual-environment">virtual environment -- 虚拟环境<a class="headerlink" href="#term-virtual-environment" title="Permalink to this term">¶</a></dt><dd><p>一种采用协作式隔离的运行时环境，允许 Python 用户和应用程序在安装和升级 Python 分发包时不会干扰到同一系统上运行的其他 Python 应用程序的行为。</p>
<p>另参见 <a class="reference internal" href="library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a>。</p>
</dd>
<dt id="term-virtual-machine">virtual machine -- 虚拟机<a class="headerlink" href="#term-virtual-machine" title="Permalink to this term">¶</a></dt><dd><p>一台完全通过软件定义的计算机。Python 虚拟机可执行字节码编译器所生成的 <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a>。</p>
</dd>
<dt id="term-Zen-of-Python">Zen of Python -- Python 之禅<a class="headerlink" href="#term-Zen-of-Python" title="Permalink to this term">¶</a></dt><dd><p>列出 Python 设计的原则与哲学，有助于理解与使用这种语言。查看其具体内容可在交互模式提示符中输入 &quot;<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>&quot;。</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="上一章">“为什么我的电脑上安装了 Python ？”</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="about.html"
                          title="下一章">文档说明</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="about.html" title="文档说明"
             >下一页</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="“为什么我的电脑上安装了 Python ？”"
             >上一页</a> |</li>

          <li><img src="_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.11.0 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">术语对照表</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 11月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0创建。
    </div>

  </body>
</html>