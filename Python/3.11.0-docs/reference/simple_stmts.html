
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>7. 简单语句 &#8212; Python 3.11.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="8. 复合语句" href="compound_stmts.html" />
    <link rel="prev" title="6. 表达式" href="expressions.html" />
    <link rel="canonical" href="https://docs.python.org/3/reference/simple_stmts.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">7. 简单语句</a><ul>
<li><a class="reference internal" href="#expression-statements">7.1. 表达式语句</a></li>
<li><a class="reference internal" href="#assignment-statements">7.2. 赋值语句</a><ul>
<li><a class="reference internal" href="#augmented-assignment-statements">7.2.1. 增强赋值语句</a></li>
<li><a class="reference internal" href="#annotated-assignment-statements">7.2.2. 带标注的赋值语句</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-assert-statement">7.3. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-pass-statement">7.4. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-del-statement">7.5. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-return-statement">7.6. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-yield-statement">7.7. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-raise-statement">7.8. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-break-statement">7.9. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-continue-statement">7.10. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-import-statement">7.11. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 语句</a><ul>
<li><a class="reference internal" href="#future-statements">7.11.1. future 语句</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-global-statement">7.12. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-nonlocal-statement">7.13. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code> 语句</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="expressions.html"
                          title="上一章"><span class="section-number">6. </span>表达式</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="compound_stmts.html"
                          title="下一章"><span class="section-number">8. </span>复合语句</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/simple_stmts.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="compound_stmts.html" title="8. 复合语句"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 表达式"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 语言参考手册</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7. </span>简单语句</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="simple-statements">
<span id="simple"></span><h1><span class="section-number">7. </span>简单语句<a class="headerlink" href="#simple-statements" title="永久链接至标题">¶</a></h1>
<p id="index-0">简单语句由一个单独的逻辑行构成。 多条简单语句可以存在于同一行内并以分号分隔。 简单语句的句法为:</p>
<pre>
<strong id="grammar-token-python-grammar-simple_stmt"><span id="grammar-token-simple-stmt"></span>simple_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression_stmt"><code class="xref docutils literal notranslate"><span class="pre">expression_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-assert_stmt"><code class="xref docutils literal notranslate"><span class="pre">assert_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-assignment_stmt"><code class="xref docutils literal notranslate"><span class="pre">assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-augmented_assignment_stmt"><code class="xref docutils literal notranslate"><span class="pre">augmented_assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-annotated_assignment_stmt"><code class="xref docutils literal notranslate"><span class="pre">annotated_assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-pass_stmt"><code class="xref docutils literal notranslate"><span class="pre">pass_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-del_stmt"><code class="xref docutils literal notranslate"><span class="pre">del_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-return_stmt"><code class="xref docutils literal notranslate"><span class="pre">return_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-yield_stmt"><code class="xref docutils literal notranslate"><span class="pre">yield_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-raise_stmt"><code class="xref docutils literal notranslate"><span class="pre">raise_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-break_stmt"><code class="xref docutils literal notranslate"><span class="pre">break_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-continue_stmt"><code class="xref docutils literal notranslate"><span class="pre">continue_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-import_stmt"><code class="xref docutils literal notranslate"><span class="pre">import_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-future_stmt"><code class="xref docutils literal notranslate"><span class="pre">future_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-global_stmt"><code class="xref docutils literal notranslate"><span class="pre">global_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-python-grammar-nonlocal_stmt"><code class="xref docutils literal notranslate"><span class="pre">nonlocal_stmt</span></code></a>
</pre>
<section id="expression-statements">
<span id="exprstmts"></span><h2><span class="section-number">7.1. </span>表达式语句<a class="headerlink" href="#expression-statements" title="永久链接至标题">¶</a></h2>
<span class="target" id="index-1"></span><p id="index-2">表达式语句用于计算和写入值（大多是在交互模式下），或者（通常情况）调用一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 <code class="docutils literal notranslate"><span class="pre">None</span></code>)。 表达式语句的其他使用方式也是允许且有特定用处的。 表达式语句的句法为:</p>
<pre>
<strong id="grammar-token-python-grammar-expression_stmt"><span id="grammar-token-expression-stmt"></span>expression_stmt</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>
</pre>
<p>表达式语句会对指定的表达式列表（也可能为单一表达式）进行求值。</p>
<p id="index-3">在交互模式下，如果结果值不为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，它会通过内置的 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 函数转换为一个字符串，该结果字符串将以单独一行的形式写入标准输出（例外情况是如果结果为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则该过程调用不产生任何输出。）</p>
</section>
<section id="assignment-statements">
<span id="assignment"></span><h2><span class="section-number">7.2. </span>赋值语句<a class="headerlink" href="#assignment-statements" title="永久链接至标题">¶</a></h2>
<p id="index-4">赋值语句用于将名称（重）绑定到特定值，以及修改属性或可变对象的成员项:</p>
<pre>
<strong id="grammar-token-python-grammar-assignment_stmt"><span id="grammar-token-assignment-stmt"></span>assignment_stmt</strong> ::=  (<a class="reference internal" href="#grammar-token-python-grammar-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;=&quot;)+ (<a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>)
<strong id="grammar-token-python-grammar-target_list"><span id="grammar-token-target-list"></span>target_list    </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-target"><span id="grammar-token-target"></span>target         </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
                     | &quot;(&quot; [<a class="reference internal" href="#grammar-token-python-grammar-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a>] &quot;)&quot;
                     | &quot;[&quot; [<a class="reference internal" href="#grammar-token-python-grammar-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a>] &quot;]&quot;
                     | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a>
                     | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a>
                     | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a>
                     | &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a>
</pre>
<p>(请参阅 <a class="reference internal" href="expressions.html#primaries"><span class="std std-ref">原型</span></a> 一节了解 <em>属性引用</em>, <em>抽取</em> 和 <em>切片</em> 的句法定义。)</p>
<p>赋值语句会对指定的表达式列表进行求值（注意这可能为单一表达式或是由逗号分隔的列表，后者将产生一个元组）并将单一结果对象从左至右逐个赋值给目标列表。</p>
<p id="index-5">赋值是根据目标（列表）的格式递归地定义的。 当目标为一个可变对象（属性引用、抽取或切片）的组成部分时，该可变对象必须最终执行赋值并决定其有效性，如果赋值操作不可接受也可能引发异常。 各种类型可用的规则和引发的异常通过对象类型的定义给出（参见 <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">标准类型层级结构</span></a> 一节）。</p>
<p id="index-6">对象赋值的目标对象可以包含于圆括号或方括号内，具体操作按以下方式递归地定义。</p>
<ul class="simple">
<li><p>如果目标列表为后面不带逗号、可以包含于圆括号内的单一目标，则将对象赋值给该目标。</p></li>
<li><p>否则:</p>
<ul>
<li><p>如果目标列表包含一个带有星号前缀的目标，这称为“加星”目标：则该对象至少必须为与目标列表项数减一相同项数的可迭代对象。 该可迭代对象前面的项将按从左至右的顺序被赋值给加星目标之前的目标。 该可迭代对象末尾的项将被赋值给加星目标之后的目标。 然后该可迭代对象中剩余项的列表将被赋值给加星目标（该列表可以为空）。</p></li>
<li><p>否则：该对象必须为具有与目标列表相同项数的可迭代对象，这些项将按从左至右的顺序被赋值给对应的目标。</p></li>
</ul>
</li>
</ul>
<p>对象赋值给单个目标的操作按以下方式递归地定义。</p>
<ul>
<li><p>如果目标为标识符（名称）:</p>
<ul class="simple">
<li><p>如果该名称未出现于当前代码块的 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 或 <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 语句中：该名称将被绑定到当前局部命名空间的对象。</p></li>
<li><p>否则：该名称将被分别绑定到全局命名空间或由 <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 所确定的外层命名空间的对象。</p></li>
</ul>
<p id="index-7">如果该名称已经被绑定则将被重新绑定。 这可能导致之前被绑定到该名称的对象的引用计数变为零，造成该对象进入释放过程并调用其析构器（如果存在）。</p>
</li>
<li id="index-8"><p>如果该对象为属性引用：引用中的原型表达式会被求值。 它应该产生一个具有可赋值属性的对象；否则将引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 该对象会被要求将可赋值对象赋值给指定的属性；如果它无法执行赋值，则会引发异常 (通常应为 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 但并不强制要求)。</p>
<p id="attr-target-note">注意：如果该对象为类实例并且属性引用在赋值运算符的两侧都出现，则右侧表达式 <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 可以访问实例属性或（如果实例属性不存在）类属性。 左侧目标 <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 将总是设定为实例属性，并在必要时创建该实例属性。 因此 <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 的两次出现不一定指向相同的属性：如果右侧表达式指向一个类属性，则左侧会创建一个新的实例属性作为赋值的目标:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cls</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>             <span class="c1"># class variable</span>
<span class="n">inst</span> <span class="o">=</span> <span class="n">Cls</span><span class="p">()</span>
<span class="n">inst</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># writes inst.x as 4 leaving Cls.x as 3</span>
</pre></div>
</div>
<p>此描述不一定作用于描述器属性，例如通过 <a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 创建的特征属性。</p>
</li>
<li id="index-9"><p>如果目标为一个抽取项：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列表）或一个映射对象（例如字典）。 接下来，该抽取表达式会被求值。</p>
<p id="index-10">如果原型为一个可变序列对象（例如列表），抽取应产生一个整数。 如其为负值，则再加上序列长度。 结果值必须为一个小于序列长度的非负整数，序列将把被赋值对象赋值给该整数指定索引号的项。 如果索引超出范围，将会引发 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> (给被抽取序列赋值不能向列表添加新项)。</p>
<p id="index-11">如果原型为一个映射对象（例如字典），抽取必须具有与该映射的键类型相兼容的类型，然后映射中会创建一个将抽取映射到被赋值对象的键/值对。 这可以是替换一个现有键/值对并保持相同键值，也可以是插入一个新键/值对（如果具有相同值的键不存在）。</p>
<p>对于用户定义对象，会调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code> 方法并附带适当的参数。</p>
</li>
<li id="index-12"><p>如果目标为一个切片：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列表）。 被赋值对象应当是一个相同类型的序列对象。 接下来，下界与上界表达式如果存在的话将被求值；默认值分别为零和序列长度。 上下边界值应当为整数。 如果某一边界为负值，则会加上序列长度。 求出的边界会被裁剪至介于零和序列长度的开区间中。 最后，将要求序列对象以被赋值序列的项替换该切片。 切片的长度可能与被赋值序列的长度不同，这会在目标序列允许的情况下改变目标序列的长度。</p></li>
</ul>
<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> 在当前实现中，目标的句法被当作与表达式的句法相同，无效的句法会在代码生成阶段被拒绝，导致不太详细的错误信息。</p>
</div>
<p>虽然赋值的定义意味着左手边与右手边的重叠是“同时”进行的（例如 <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">b,</span> <span class="pre">a</span></code> 会交换两个变量的值），但在赋值给变量的多项集 <em>之内</em> 的重叠是从左至右进行的，这有时会令人混淆。 例如，以下程序将会打印出 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2]</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>         <span class="c1"># i is updated, then x[i] is updated</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-53"></span><a class="pep reference external" href="https://peps.python.org/pep-3132/"><strong>PEP 3132</strong></a> - 扩展的可迭代对象拆包</dt><dd><p>对 <code class="docutils literal notranslate"><span class="pre">*target</span></code> 特性的规范说明。</p>
</dd>
</dl>
</div>
<section id="augmented-assignment-statements">
<span id="augassign"></span><h3><span class="section-number">7.2.1. </span>增强赋值语句<a class="headerlink" href="#augmented-assignment-statements" title="永久链接至标题">¶</a></h3>
<p id="index-14">增强赋值语句就是在单个语句中将二元运算和赋值语句合为一体:</p>
<pre>
<strong id="grammar-token-python-grammar-augmented_assignment_stmt"><span id="grammar-token-augmented-assignment-stmt"></span>augmented_assignment_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-augtarget"><code class="xref docutils literal notranslate"><span class="pre">augtarget</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-augop"><code class="xref docutils literal notranslate"><span class="pre">augop</span></code></a> (<a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>)
<strong id="grammar-token-python-grammar-augtarget"><span id="grammar-token-augtarget"></span>augtarget                </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a>
<strong id="grammar-token-python-grammar-augop"><span id="grammar-token-augop"></span>augop                    </strong> ::=  &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;&#64;=&quot; | &quot;/=&quot; | &quot;//=&quot; | &quot;%=&quot; | &quot;**=&quot;
                               | &quot;&gt;&gt;=&quot; | &quot;&lt;&lt;=&quot; | &quot;&amp;=&quot; | &quot;^=&quot; | &quot;|=&quot;
</pre>
<p>（请参阅 <a class="reference internal" href="expressions.html#primaries"><span class="std std-ref">原型</span></a> 一节了解最后三种符号的句法定义。）</p>
<p>增强赋值语句将对目标和表达式列表求值（与普通赋值语句不同的是，前者不能为可迭代对象拆包），对两个操作数相应类型的赋值执行指定的二元运算，并将结果赋值给原始目标。 目标仅会被求值一次。</p>
<p>增强赋值语句例如 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">1</span></code> 可以改写为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> 获得类似但并非完全等价的效果。 在增强赋值的版本中，<code class="docutils literal notranslate"><span class="pre">x</span></code> 仅会被求值一次。 而且，在可能的情况下，实际的运算是 <em>原地</em> 执行的，也就是说并不是创建一个新对象并将其赋值给目标，而是直接修改原对象。</p>
<p>不同于普通赋值，增强赋值会在对右手边求值 <em>之前</em> 对左手边求值。 例如，<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+=</span> <span class="pre">f(x)</span></code> 首先查找 <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>，然后对 <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> 求值并执行加法操作，最后将结果写回到 <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>。</p>
<p>除了在单个语句中赋值给元组和多个目标的例外情况，增强赋值语句的赋值操作处理方式与普通赋值相同。 类似地，除了可能存在 <em>原地</em> 操作行为的例外情况，增强赋值语句执行的二元运算也与普通二元运算相同。</p>
<p>对于属性引用类目标，针对常规赋值的 <a class="reference internal" href="#attr-target-note"><span class="std std-ref">关于类和实例属性的警告</span></a> 也同样适用。</p>
</section>
<section id="annotated-assignment-statements">
<span id="annassign"></span><h3><span class="section-number">7.2.2. </span>带标注的赋值语句<a class="headerlink" href="#annotated-assignment-statements" title="永久链接至标题">¶</a></h3>
<p id="index-15"><a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">标注</span></a> 赋值就是在单个语句中将变量或属性标注和可选的赋值语句合为一体:</p>
<pre>
<strong id="grammar-token-python-grammar-annotated_assignment_stmt"><span id="grammar-token-annotated-assignment-stmt"></span>annotated_assignment_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-augtarget"><code class="xref docutils literal notranslate"><span class="pre">augtarget</span></code></a> &quot;:&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
                               [&quot;=&quot; (<a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>)]
</pre>
<p>The difference from normal <a class="reference internal" href="#assignment"><span class="std std-ref">赋值语句</span></a> is that only a single target is allowed.</p>
<p>对于将简单名称作为赋值目标的情况，如果是在类或模块作用域中，标注会被求值并存入一个特殊的类或模块属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 中，这是一个将变量名称（如为私有会被移除）映射到被求值标注的字典。 此属性为可写并且在类或模块体开始执行时如果静态地发现标注就会自动创建。</p>
<p>对于将表达式作为赋值目标的情况，如果是在类或模块作用域中，标注会被求值，但不会保存。</p>
<p>如果一个名称在函数作用域内被标注，则该名称为该作用域的局部变量。 标注绝不会在函数作用域内被求值和保存。</p>
<p>如果存在右手边，带标注的赋值会在对标注求值之前（如果适用）执行实际的赋值。 如果用作表达式目标的右手边不存在，则解释器会对目标求值，但最后的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code> 调用除外。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-54"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a> - 变量标注的语法</dt><dd><p>该提议增加了标注变量（也包括类变量和实例变量）类型的语法，而不再是通过注释来进行表达。</p>
</dd>
<dt><span class="target" id="index-55"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> - 类型提示</dt><dd><p>该提议增加了 <a class="reference internal" href="../library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 模块以便为类型标注提供标准句法，可被静态分析工具和 IDE 所使用。</p>
</dd>
</dl>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>Now annotated assignments allow the same expressions in the right hand side as
regular assignments. Previously, some expressions (like un-parenthesized
tuple expressions) caused a syntax error.</p>
</div>
</section>
</section>
<section id="the-assert-statement">
<span id="assert"></span><h2><span class="section-number">7.3. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code> 语句<a class="headerlink" href="#the-assert-statement" title="永久链接至标题">¶</a></h2>
<p id="index-18">assert 语句是在程序中插入调试性断言的简便方式:</p>
<pre>
<strong id="grammar-token-python-grammar-assert_stmt"><span id="grammar-token-assert-stmt"></span>assert_stmt</strong> ::=  &quot;assert&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
</pre>
<p>简单形式 <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">expression</span></code> 等价于</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expression</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AssertionError</span>
</pre></div>
</div>
<p>扩展形式 <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">expression1,</span> <span class="pre">expression2</span></code> 等价于</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expression1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">expression2</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-19">以上等价形式假定 <a class="reference internal" href="../library/constants.html#debug__" title="__debug__"><code class="xref py py-const docutils literal notranslate"><span class="pre">__debug__</span></code></a> 和 <a class="reference internal" href="../library/exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 指向具有指定名称的内置变量。 在当前实现中，内置变量 <a class="reference internal" href="../library/constants.html#debug__" title="__debug__"><code class="xref py py-const docutils literal notranslate"><span class="pre">__debug__</span></code></a> 在正常情况下为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，在请求优化时为 <code class="docutils literal notranslate"><span class="pre">False</span></code> (对应命令行选项为 <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a>)。 如果在编译时请求优化，当前代码生成器不会为 assert 语句发出任何代码。 请注意不必在错误信息中包含失败表达式的源代码；它会被作为栈追踪的一部分被显示。</p>
<p>赋值给 <a class="reference internal" href="../library/constants.html#debug__" title="__debug__"><code class="xref py py-const docutils literal notranslate"><span class="pre">__debug__</span></code></a> 是非法的。 该内置变量的值会在解释器启动时确定。</p>
</section>
<section id="the-pass-statement">
<span id="pass"></span><h2><span class="section-number">7.4. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code> 语句<a class="headerlink" href="#the-pass-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-20">
<strong id="grammar-token-python-grammar-pass_stmt"><span id="grammar-token-pass-stmt"></span>pass_stmt</strong> ::=  &quot;pass&quot;
</pre>
<p><a class="reference internal" href="#pass"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code></a> 是一个空操作 --- 当它被执行时，什么都不发生。 它适合当语法上需要一条语句但并不需要执行任何代码时用来临时占位，例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span> <span class="k">pass</span>    <span class="c1"># a function that does nothing (yet)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span> <span class="k">pass</span>       <span class="c1"># a class with no methods (yet)</span>
</pre></div>
</div>
</section>
<section id="the-del-statement">
<span id="del"></span><h2><span class="section-number">7.5. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code> 语句<a class="headerlink" href="#the-del-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-21">
<strong id="grammar-token-python-grammar-del_stmt"><span id="grammar-token-del-stmt"></span>del_stmt</strong> ::=  &quot;del&quot; <a class="reference internal" href="#grammar-token-python-grammar-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a>
</pre>
<p>删除是递归定义的，与赋值的定义方式非常类似。 此处不再详细说明，只给出一些提示。</p>
<p>目标列表的删除将从左至右递归地删除每一个目标。</p>
<p id="index-22">名称的删除将从局部或全局命名空间中移除该名称的绑定，具体作用域的确定是看该名称是否有在同一代码块的 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 语句中出现。 如果该名称未被绑定，将会引发 <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>。</p>
<p id="index-23">属性引用、抽取和切片的删除会被传递给相应的原型对象；删除一个切片基本等价于赋值为一个右侧类型的空切片（但即便这一点也是由切片对象决定的）。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>在之前版本中，如果一个名称作为被嵌套代码块中的自由变量出现，则将其从局部命名空间中删除是非法的。</p>
</div>
</section>
<section id="the-return-statement">
<span id="return"></span><h2><span class="section-number">7.6. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 语句<a class="headerlink" href="#the-return-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-24">
<strong id="grammar-token-python-grammar-return_stmt"><span id="grammar-token-return-stmt"></span>return_stmt</strong> ::=  &quot;return&quot; [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a>]
</pre>
<p><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 在语法上只会出现于函数定义所嵌套的代码，不会出现于类定义所嵌套的代码。</p>
<p>如果提供了表达式列表，它将被求值，否则以 <code class="docutils literal notranslate"><span class="pre">None</span></code> 替代。</p>
<p><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 会离开当前函数调用，并以表达式列表 (或 <code class="docutils literal notranslate"><span class="pre">None</span></code>) 作为返回值。</p>
<p id="index-25">当 <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 将控制流传出一个带有 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 子句的 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 语句时，该 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 子句会先被执行然后再真正离开该函数。</p>
<p>在一个生成器函数中，<a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句表示生成器已完成并将导致 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 被引发。 返回值（如果有的话）会被当作一个参数用来构建 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 并成为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">StopIteration.value</span></code> 属性。</p>
<p>在一个异步生成器函数中，一个空的 <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句表示异步生成器已完成并将导致 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 被引发。 一个非空的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 语句在异步生成器函数中会导致语法错误。</p>
</section>
<section id="the-yield-statement">
<span id="yield"></span><h2><span class="section-number">7.7. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句<a class="headerlink" href="#the-yield-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-26">
<strong id="grammar-token-python-grammar-yield_stmt"><span id="grammar-token-yield-stmt"></span>yield_stmt</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>
</pre>
<p><a class="reference internal" href="#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句在语义上等同于 <a class="reference internal" href="expressions.html#yieldexpr"><span class="std std-ref">yield 表达式</span></a>。 yield 语句可用来省略在使用等效的 yield 表达式语句时所必须的圆括号。 例如，以下 yield 语句</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">yield</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span>
<span class="k">yield from</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>等同于以下 yield 表达式语句</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">yield</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="k">yield from</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>yield 表达式和语句仅在定义 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> 函数时使用，并且仅被用于生成器函数的函数体内部。 在函数定义中使用 yield 就足以使得该定义创建的是生成器函数而非普通函数。</p>
<p>有关 <a class="reference internal" href="#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语义的完整细节请参看 <a class="reference internal" href="expressions.html#yieldexpr"><span class="std std-ref">yield 表达式</span></a> 一节。</p>
</section>
<section id="the-raise-statement">
<span id="raise"></span><h2><span class="section-number">7.8. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code> 语句<a class="headerlink" href="#the-raise-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-27">
<strong id="grammar-token-python-grammar-raise_stmt"><span id="grammar-token-raise-stmt"></span>raise_stmt</strong> ::=  &quot;raise&quot; [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;from&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]]
</pre>
<p>如果没有提供表达式，则 <a class="reference internal" href="#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> 会重新引发当前正在处理的异常，它也被称为 <em>活动的异常</em>。 如果当前没有活动的异常，则会引发 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 来提示发生了错误。</p>
<p>否则的话，<a class="reference internal" href="#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> 会将第一个表达式求值为异常对象。 它必须为 <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseException</span></code></a> 的子类或实例。 如果它是一个类，当需要时会通过不带参数地实例化该类来获得异常的实例。</p>
<p>异常的 <em class="dfn">类型</em> 为异常实例的类，<em class="dfn">值</em> 为实例本身。</p>
<p id="index-28">当有异常被引发时通常会自动创建一个回溯对象并将其关联到它的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code> 属性，该属性是可写的。 你可以创建一个异常并使用 <a class="reference internal" href="../library/exceptions.html#BaseException.with_traceback" title="BaseException.with_traceback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_traceback()</span></code></a> 异常方法（该方法将返回同一异常实例，并将回溯对象设为其参数）直接设置自己的回溯对象，就像这样like so:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;foo occurred&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tracebackobj</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-29"><code class="docutils literal notranslate"><span class="pre">from</span></code> 子句用于异常串连：如果有该子句，则第二个 <em>表达式</em> 必须为另一个异常类或实例。 如果第二个表达式是一个异常实例，它将作为可写的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code> 属性被关联到所引发的异常。 如果该表达式是一个异常类，这个类将被实例化且所生成的异常实例将作为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code> 属性被关联到所引发的异常。 如果所引发的异常未被处理，则两个异常都将被打印出来:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>

<span class="go">The above exception was the direct cause of the following exception:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p>当已经有一个异常在处理时如果有新的异常被引发则类似的机制会隐式地起作用。 异常可以通过使用 <a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 或 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 子句或是 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句来处理。 之前的异常将被关联至新异常的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code> 属性:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>

<span class="go">During handling of the above exception, another exception occurred:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p>异常串连可通过在 <code class="docutils literal notranslate"><span class="pre">from</span></code> 子句中指定 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 来显式地加以抑制:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p>有关异常的更多信息可在 <a class="reference internal" href="executionmodel.html#exceptions"><span class="std std-ref">异常</span></a> 一节查看，有关处理异常的信息可在 <a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 语句</span></a> 一节查看。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span><a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 现在允许被用作 <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">X</span> <span class="pre">from</span> <span class="pre">Y</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">Y</span></code>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能: </span>使用 <code class="docutils literal notranslate"><span class="pre">__suppress_context__</span></code> 属性来抑制异常上下文的自动显示。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版更改: </span>If the traceback of the active exception is modified in an <a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>
clause, a subsequent <code class="docutils literal notranslate"><span class="pre">raise</span></code> statement re-raises the exception with the
modified traceback. Previously, the exception was re-raised with the
traceback it had when it was caught.</p>
</div>
</section>
<section id="the-break-statement">
<span id="break"></span><h2><span class="section-number">7.9. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code> 语句<a class="headerlink" href="#the-break-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-30">
<strong id="grammar-token-python-grammar-break_stmt"><span id="grammar-token-break-stmt"></span>break_stmt</strong> ::=  &quot;break&quot;
</pre>
<p><a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 在语法上只会出现于 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 或 <a class="reference internal" href="compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 循环所嵌套的代码，但不会出现于该循环内部的函数或类定义所嵌套的代码。</p>
<p id="index-31">它会终结最近的外层循环，如果循环有可选的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code> 子句，也会跳过该子句。</p>
<p>如果一个 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 循环被 <a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 所终结，该循环的控制目标会保持其当前值。</p>
<p id="index-32">当 <a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 将控制流传出一个带有 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 子句的 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 语句时，该 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 子句会先被执行然后再真正离开该循环。</p>
</section>
<section id="the-continue-statement">
<span id="continue"></span><h2><span class="section-number">7.10. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code> 语句<a class="headerlink" href="#the-continue-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-33">
<strong id="grammar-token-python-grammar-continue_stmt"><span id="grammar-token-continue-stmt"></span>continue_stmt</strong> ::=  &quot;continue&quot;
</pre>
<p><a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 在语法上只会出现于 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 或 <a class="reference internal" href="compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 循环所嵌套的代码中，但不会出现于该循环内部的函数或类定义中。 它会继续执行最近的外层循环的下一个轮次。</p>
<p>当 <a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 将控制流传出一个带有 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 子句的 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 语句时，该 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 子句会先被执行然后再真正开始循环的下一个轮次。</p>
</section>
<section id="the-import-statement">
<span id="from"></span><span id="import"></span><h2><span class="section-number">7.11. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 语句<a class="headerlink" href="#the-import-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-34">
<strong id="grammar-token-python-grammar-import_stmt"><span id="grammar-token-import-stmt"></span>import_stmt    </strong> ::=  &quot;import&quot; <a class="reference internal" href="#grammar-token-python-grammar-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>] (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>])*
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-python-grammar-relative_module"><code class="xref docutils literal notranslate"><span class="pre">relative_module</span></code></a> &quot;import&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>]
                     (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>])*
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-python-grammar-relative_module"><code class="xref docutils literal notranslate"><span class="pre">relative_module</span></code></a> &quot;import&quot; &quot;(&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>]
                     (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>])* [&quot;,&quot;] &quot;)&quot;
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-python-grammar-relative_module"><code class="xref docutils literal notranslate"><span class="pre">relative_module</span></code></a> &quot;import&quot; &quot;*&quot;
<strong id="grammar-token-python-grammar-module"><span id="grammar-token-module"></span>module         </strong> ::=  (<a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;.&quot;)* <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
<strong id="grammar-token-python-grammar-relative_module"><span id="grammar-token-relative-module"></span>relative_module</strong> ::=  &quot;.&quot;* <a class="reference internal" href="#grammar-token-python-grammar-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> | &quot;.&quot;+
</pre>
<p>基本的 import 语句（不带 <a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 子句）会分两步执行:</p>
<ol class="arabic simple">
<li><p>查找一个模块，如果有必要还会加载并初始化模块。</p></li>
<li><p>在局部命名空间中为 <a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句发生位置所处的作用域定义一个或多个名称。</p></li>
</ol>
<p>当语句包含多个子句（由逗号分隔）时这两个步骤将对每个子句分别执行，如同这些子句被分成独立的 import 语句一样。</p>
<p>The details of the first step, finding and loading modules, are described in
greater detail in the section on the <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">import system</span></a>,
which also describes the various types of packages and modules that can
be imported, as well as all the hooks that can be used to customize
the import system. Note that failures in this step may indicate either
that the module could not be located, <em>or</em> that an error occurred while
initializing the module, which includes execution of the module's code.</p>
<p>如果成功获取到请求的模块，则可以通过以下三种方式一之在局部命名空间中使用它:</p>
<ul class="simple" id="index-35">
<li><p>模块名后使用 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 时，直接把 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 后的名称与导入模块绑定。</p></li>
<li><p>如果没有指定其他名称，且被导入的模块为最高层级模块，则模块的名称将被绑定到局部命名空间作为对所导入模块的引用。</p></li>
<li><p>如果被导入的模块 <em>不是</em> 最高层级模块，则包含该模块的最高层级包的名称将被绑定到局部命名空间作为对该最高层级包的引用。 所导入的模块必须使用其完整限定名称来访问而不能直接访问。</p></li>
</ul>
<p id="index-36"><a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 形式使用的过程略微繁复一些:</p>
<ol class="arabic simple">
<li><p>查找 <a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 子句中指定的模块，如有必要还会加载并初始化模块；</p></li>
<li><p>对于 <a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 子句中指定的每个标识符：</p>
<ol class="arabic simple">
<li><p>检查被导入模块是否有该名称的属性</p></li>
<li><p>如果没有，尝试导入具有该名称的子模块，然后再次检查被导入模块是否有该属性</p></li>
<li><p>如果未找到该属性，则引发 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>。</p></li>
<li><p>否则的话，将对该值的引用存入局部命名空间，如果有 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 子句则使用其指定的名称，否则使用该属性的名称</p></li>
</ol>
</li>
</ol>
<p>示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">foo</span>                 <span class="c1"># foo imported and bound locally</span>
<span class="kn">import</span> <span class="nn">foo.bar.baz</span>         <span class="c1"># foo, foo.bar, and foo.bar.baz imported, foo bound locally</span>
<span class="kn">import</span> <span class="nn">foo.bar.baz</span> <span class="k">as</span> <span class="nn">fbb</span>  <span class="c1"># foo, foo.bar, and foo.bar.baz imported, foo.bar.baz bound as fbb</span>
<span class="kn">from</span> <span class="nn">foo.bar</span> <span class="kn">import</span> <span class="n">baz</span>    <span class="c1"># foo, foo.bar, and foo.bar.baz imported, foo.bar.baz bound as baz</span>
<span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">attr</span>       <span class="c1"># foo imported and foo.attr bound as attr</span>
</pre></div>
</div>
<p id="index-37">如果标识符列表改为一个星号 (<code class="docutils literal notranslate"><span class="pre">'*'</span></code>)，则在模块中定义的全部公有名称都将按 <a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句所在的作用域被绑定到局部命名空间。</p>
<p id="index-38">一个模块所定义的 <em>公有名称</em> 是由在模块的命名空间中检测一个名为 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 的变量来确定的；如果有定义，它必须是一个字符串列表，其中的项为该模块所定义或导入的名称。 在 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 中所给出的名称都会被视为公有并且应当存在。 如果 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 没有被定义，则公有名称的集合将包含在模块的命名空间中找到的所有不以下划线字符 (<code class="docutils literal notranslate"><span class="pre">'_'</span></code>) 打头的名称。 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 应当包括整个公有 API。 它的目标是避免意外地导出不属于 API 的一部分的项（例如在模块内部被导入和使用的库模块）。</p>
<p>通配符形式的导入 --- <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> --- 仅在模块层级上被允许。 尝试在类或函数定义中使用它将引发 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>。</p>
<p id="index-39">当指定要导入哪个模块时，你不必指定模块的绝对名称。 当一个模块或包被包含在另一个包之中时，可以在同一个最高层级包中进行相对导入，而不必提及包名称。 通过在 <a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 之后指定的模块或包中使用前缀点号，你可以在不指定确切名称的情况下指明在当前包层级结构中要上溯多少级。 一个前缀点号表示是执行导入的模块所在的当前包，两个点号表示上溯一个包层级。 三个点号表示上溯两级，依此类推。 因此如果你执行 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">import</span> <span class="pre">mod</span></code> 时所处位置为 <code class="docutils literal notranslate"><span class="pre">pkg</span></code> 包内的一个模块，则最终你将导入 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>。 如果你执行 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">..subpkg2</span> <span class="pre">import</span> <span class="pre">mod</span></code> 时所处位置为 <code class="docutils literal notranslate"><span class="pre">pkg.subpkg1</span></code> 则你将导入 <code class="docutils literal notranslate"><span class="pre">pkg.subpkg2.mod</span></code>。 有关相对导入的规范说明包含在 <a class="reference internal" href="import.html#relativeimports"><span class="std std-ref">包相对导入</span></a> 一节中。</p>
<p><a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 被提供用来为动态地确定要导入模块的应用提供支持。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">import</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">module</span></code>, <code class="docutils literal notranslate"><span class="pre">filename</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.meta_path</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code>。</p>
<section id="future-statements">
<span id="future"></span><h3><span class="section-number">7.11.1. </span>future 语句<a class="headerlink" href="#future-statements" title="永久链接至标题">¶</a></h3>
<p id="index-40"><em class="dfn">future 语句</em> 是一种针对编译器的指令，指明某个特定模块应当使用在特定的未来某个 Python 发行版中成为标准特性的语法或语义。</p>
<p>future 语句的目的是使得向在语言中引入了不兼容改变的 Python 未来版本的迁移更为容易。 它允许基于每个模块在某种新特性成为标准之前的发行版中使用该特性。</p>
<pre>
<strong id="grammar-token-python-grammar-future_stmt"><span id="grammar-token-future-stmt"></span>future_stmt</strong> ::=  &quot;from&quot; &quot;__future__&quot; &quot;import&quot; <a class="reference internal" href="#grammar-token-python-grammar-feature"><code class="xref docutils literal notranslate"><span class="pre">feature</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>]
                 (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-feature"><code class="xref docutils literal notranslate"><span class="pre">feature</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>])*
                 | &quot;from&quot; &quot;__future__&quot; &quot;import&quot; &quot;(&quot; <a class="reference internal" href="#grammar-token-python-grammar-feature"><code class="xref docutils literal notranslate"><span class="pre">feature</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>]
                 (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-feature"><code class="xref docutils literal notranslate"><span class="pre">feature</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>])* [&quot;,&quot;] &quot;)&quot;
<strong id="grammar-token-python-grammar-feature"><span id="grammar-token-feature"></span>feature    </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p>future 语句必须在靠近模块开头的位置出现。 可以出现在 future 语句之前行只有:</p>
<ul class="simple">
<li><p>模块的文档字符串（如果存在），</p></li>
<li><p>注释，</p></li>
<li><p>空行，以及</p></li>
<li><p>其他 future 语句。</p></li>
</ul>
<p>唯一需要使用 future 语句的特性是 <code class="docutils literal notranslate"><span class="pre">标注</span></code> (参见 <span class="target" id="index-56"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a>)。</p>
<p>future 语句所启用的所有历史特性仍然为 Python 3 所认可。  其中包括 <code class="docutils literal notranslate"><span class="pre">absolute_import</span></code>, <code class="docutils literal notranslate"><span class="pre">division</span></code>, <code class="docutils literal notranslate"><span class="pre">generators</span></code>, <code class="docutils literal notranslate"><span class="pre">generator_stop</span></code>, <code class="docutils literal notranslate"><span class="pre">unicode_literals</span></code>, <code class="docutils literal notranslate"><span class="pre">print_function</span></code>, <code class="docutils literal notranslate"><span class="pre">nested_scopes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">with_statement</span></code>。 它们都已成为冗余项，因为它们总是为已启用状态，保留它们只是为了向后兼容。</p>
<p>future 语句在编译时会被识别并做特殊对待：对核心构造语义的改变常常是通过生成不同的代码来实现。 新的特性甚至可能会引入新的不兼容语法（例如新的保留字），在这种情况下编译器可能需要以不同的方式来解析模块。 这样的决定不能推迟到运行时方才作出。</p>
<p>对于任何给定的发布版本，编译器要知道哪些特性名称已被定义，如果某个 future 语句包含未知的特性则会引发编译时错误。</p>
<p>直接运行时的语义与任何 import 语句相同：存在一个后文将详细说明的标准模块 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>，它会在执行 future 语句时以通常的方式被导入。</p>
<p>相应的运行时语义取决于 future 语句所启用的指定特性。</p>
<p>请注意以下语句没有任何特别之处:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">__future__</span> <span class="p">[</span><span class="k">as</span> <span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p>这并非 future 语句；它只是一条没有特殊语义或语法限制的普通 import 语句。</p>
<p>在默认情况下，通过对Code compiled by calls to the 内置函数 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 的调用所编译的代码如果出现于一个包含有 future 语句的模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code> 之中，就会使用 future 语句所关联的语法和语义。 此行为可以通过 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 的可选参数加以控制 --- 请参阅该函数的文档以了解详情。</p>
<p>在交互式解释器提示符中键入的 future 语句将在解释器会话此后的交互中有效。 如果一个解释器的启动使用了 <a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 选项启动，并传入了一个脚本名称来执行，且该脚本包含 future 语句，它将在交互式会话开始执行脚本之后保持有效。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-57"></span><a class="pep reference external" href="https://peps.python.org/pep-0236/"><strong>PEP 236</strong></a> - 回到 __future__</dt><dd><p>有关 __future__ 机制的最初提议。</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="the-global-statement">
<span id="global"></span><h2><span class="section-number">7.12. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 语句<a class="headerlink" href="#the-global-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-43">
<strong id="grammar-token-python-grammar-global_stmt"><span id="grammar-token-global-stmt"></span>global_stmt</strong> ::=  &quot;global&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>)*
</pre>
<p><a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。</p>
<p>在 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 语句中列出的名称不得在同一代码块内该 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 语句之前的位置中使用。</p>
<p>在 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 语句中列出的名称不能被定义为形式参数，也不能被作为 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句或 <a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 子句的目标，以及 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 循环的目标列表、<a class="reference internal" href="compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 定义、函数定义、<a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句或变量标注等等。</p>
<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> 当前的实现并未强制要求所有的上述限制，但程序不应当滥用这样的自由，因为未来的实现可能会改为强制要求，并静默地改变程序的含义。</p>
</div>
<p id="index-44"><strong>程序员注意事项:</strong> <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 是对解析器的指令。 它仅对与 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 语句同时被解析的代码起作用。 特别地，包含在提供给内置 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数字符串或代码对象中的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 语句并不会影响 <em>包含</em> 该函数调用的代码块，而包含在这种字符串中的代码也不会受到包含该函数调用的代码中的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 语句影响。 这同样适用于 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 函数。</p>
</section>
<section id="the-nonlocal-statement">
<span id="nonlocal"></span><h2><span class="section-number">7.13. </span><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code> 语句<a class="headerlink" href="#the-nonlocal-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-45">
<strong id="grammar-token-python-grammar-nonlocal_stmt"><span id="grammar-token-nonlocal-stmt"></span>nonlocal_stmt</strong> ::=  &quot;nonlocal&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>)*
</pre>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的除全局变量以外的变量。 这种功能很重要，因为绑定的默认行为是先搜索局部命名空间。 这个语句允许被封装的代码重新绑定局部作用域以外且非全局（模块）作用域当中的变量。</p>
<p>与 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 语句中列出的名称不同，<a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 语句中列出的名称必须指向之前存在于包含作用域之中的绑定（在这个应当用来创建新绑定的作用域不能被无歧义地确定）。</p>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 语句中列出的名称不得与之前存在于局部作用域中的绑定相冲突。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-58"></span><a class="pep reference external" href="https://peps.python.org/pep-3104/"><strong>PEP 3104</strong></a> - 访问外层作用域中的名称</dt><dd><p>有关 <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 语句的规范说明。</p>
</dd>
</dl>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">7. 简单语句</a><ul>
<li><a class="reference internal" href="#expression-statements">7.1. 表达式语句</a></li>
<li><a class="reference internal" href="#assignment-statements">7.2. 赋值语句</a><ul>
<li><a class="reference internal" href="#augmented-assignment-statements">7.2.1. 增强赋值语句</a></li>
<li><a class="reference internal" href="#annotated-assignment-statements">7.2.2. 带标注的赋值语句</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-assert-statement">7.3. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-pass-statement">7.4. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-del-statement">7.5. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-return-statement">7.6. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-yield-statement">7.7. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-raise-statement">7.8. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-break-statement">7.9. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-continue-statement">7.10. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-import-statement">7.11. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 语句</a><ul>
<li><a class="reference internal" href="#future-statements">7.11.1. future 语句</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-global-statement">7.12. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code> 语句</a></li>
<li><a class="reference internal" href="#the-nonlocal-statement">7.13. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code> 语句</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="expressions.html"
                          title="上一章"><span class="section-number">6. </span>表达式</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="compound_stmts.html"
                          title="下一章"><span class="section-number">8. </span>复合语句</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/simple_stmts.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="compound_stmts.html" title="8. 复合语句"
             >下一页</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 表达式"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 语言参考手册</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7. </span>简单语句</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 11月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0创建。
    </div>

  </body>
</html>