
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>email.message: 表示一封电子邮件信息 &#8212; Python 3.11.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="email.parser: 解析电子邮件信息" href="email.parser.html" />
    <link rel="prev" title="email --- 电子邮件与 MIME 处理包" href="email.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/email.message.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="email.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 电子邮件与 MIME 处理包</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="email.parser.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code>: 解析电子邮件信息</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/email.message.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="email.parser.html" title="email.parser: 解析电子邮件信息"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="email.html" title="email --- 电子邮件与 MIME 处理包"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >互联网数据处理</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 电子邮件与 MIME 处理包</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code>: 表示一封电子邮件信息</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-email.message">
<span id="email-message-representing-an-email-message"></span><h1><a class="reference internal" href="#module-email.message" title="email.message: The base class representing email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code></a>: 表示一封电子邮件信息<a class="headerlink" href="#module-email.message" title="永久链接至标题">¶</a></h1>
<p><strong>源代码:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/email/message.py">Lib/email/message.py</a></p>
<hr class="docutils" />
<div class="versionadded">
<p><span class="versionmodified added">3.6 新版功能: </span><a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
</div>
<p>位于 <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 包的中心的类就是 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 类。这个类导入自 <a class="reference internal" href="#module-email.message" title="email.message: The base class representing email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code></a> 模块。它是 <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 对象模型的基类。<a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 为设置和查询头字段内容、访问信息体的内容、以及创建和修改结构化信息提供了核心功能。</p>
<p>一份电子邮件信息由 <em>标头</em> 和 <em>载荷</em> （又被称为 <em>内容</em> ）组成。 标头遵循 <span class="target" id="index-21"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a> 或者 <span class="target" id="index-22"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6532.html"><strong>RFC 6532</strong></a> 风格的字段名和值，字段名和字段值之间由一个冒号隔开。 这个冒号既不属于字段名，也不属于字段值。信息的载荷可能是一段简单的文字消息，也可能是一个二进制的对象，更可能是由多个拥有各自标头和载荷的子信息组成的结构化子信息序列。 对于后者类型的载荷，信息的 MIME 类型将会被指明为诸如 <em class="mimetype">multipart/*</em> 或 <em class="mimetype">message/rfc822</em> 的类型。</p>
<p><a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 对象所提供的抽象概念模型是一个头字段组成的有序字典加一个代表 <span class="target" id="index-23"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a> 标准的信息体的 <em>载荷</em> 。 载荷有可能是一系列子 <code class="docutils literal notranslate"><span class="pre">EmailMessage</span></code> 对象的列表。你除了可以通过一般的字典方法来访问头字段名和值，还可以使用特制方法来访问头的特定字段（比如说 MIME 内容类型字段）、操纵载荷、生成信息的序列化版本、递归遍历对象树。</p>
<p><a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 的类字典接口的字典索引是头字段名，头字段名必须是ASCII值。字典值是带有一些附加方法的字符串。虽然头字段的存储和获取都是保留其原始大小写的，但是字段名的匹配是大小写不敏感的。与真正的字典不同，键与键之间不但存在顺序关系，还可以重复。我们提供了额外的方法来处理含有重复键的头。</p>
<p><em>载荷</em> 是多样的。对于简单的信息对象，它是字符串或字节对象；对于诸如 <em class="mimetype">multipart/*</em> 和 <em class="mimetype">message/rfc822</em> 信息对象的 MIME 容器文档，它是一个 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 对象列表。</p>
<dl class="py class">
<dt class="sig sig-object py" id="email.message.EmailMessage">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">email.message.</span></span><span class="sig-name descname"><span class="pre">EmailMessage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">default</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage" title="永久链接至目标">¶</a></dt>
<dd><p>如果指定了 <em>policy</em> ，消息将由这个 <em>policy</em> 所指定的规则来更新和序列化信息的表达。如果没有指定 <em>policy</em> ，其将默认使用 <a class="reference internal" href="email.policy.html#email.policy.default" title="email.policy.default"><code class="xref py py-class docutils literal notranslate"><span class="pre">default</span></code></a> 策略。这个策略遵循电子邮件的RFC标准，除了行终止符号（RFC要求使用 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code> ，此策略使用Python标准的 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 行终止符）。请前往 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 的文档获取更多信息。</p>
<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.as_string">
<span class="sig-name descname"><span class="pre">as_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unixfrom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxheaderlen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.as_string" title="永久链接至目标">¶</a></dt>
<dd><p>以一段字符串的形式返回整个消息对象。 若可选的 <em>unixform</em> 参数为真，返回的字符串会包含信封头。 <em>unixform</em> 的默认值是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 为了保持与基类 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 的兼容性，<em>maxheaderlen</em> 是被接受的，但是其默认值是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 这个默认值表示行长度由策略的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">max_line_length</span></code> 属性所控制。从信息实例所获取到的策略可以通过 <em>policy</em> 参数重写。 这样可以对该方法所产生的输出进行略微的控制，因为指定的 <em>policy</em> 会被传递到 <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 当中。</p>
<p>扁平化信息可能会对 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 做出修改。这是因为为了完成向字符串的转换，一些内容需要使用默认值填入（举个例子，MIME 边界字段可能会被生成或被修改）。</p>
<p>请注意，这个方法是为了便利而提供，不一定是适合你的应用程序的最理想的序列化信息的方法。这在你处理多封信息的时候尤甚。如果你需要使用更加灵活的API来序列化信息，请参见 <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.generator.Generator</span></code></a> 。同时请注意，当 <a class="reference internal" href="email.policy.html#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a> 属性为其默认值 <code class="docutils literal notranslate"><span class="pre">False</span></code> 的时候，本方法将限制其行为为生成以“7 bit clean”方式序列化的信息。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span><em>maxheaderlen</em> 没有被指定时的默认行为从默认为0修改为默认为策略的 <em>max_line_length</em> 值。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__str__" title="永久链接至目标">¶</a></dt>
<dd><p>与 <code class="docutils literal notranslate"><span class="pre">as_string(policy=self.policy.clone(utf8=True))</span></code> 等价。这将让 <code class="docutils literal notranslate"><span class="pre">str(msg)</span></code> 产生的字符串包含人类可读的的序列化信息内容。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>本方法开始使用 <code class="docutils literal notranslate"><span class="pre">utf8=True</span></code> ，而非 <a class="reference internal" href="#email.message.EmailMessage.as_string" title="email.message.EmailMessage.as_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_string()</span></code></a> 的直接替身。使用 <code class="docutils literal notranslate"><span class="pre">utf8=True</span></code> 会产生类似于 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6531.html"><strong>RFC 6531</strong></a> 的信息表达。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.as_bytes">
<span class="sig-name descname"><span class="pre">as_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unixfrom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.as_bytes" title="永久链接至目标">¶</a></dt>
<dd><p>以字节串对象的形式返回整个扁平化后的消息。 当可选的 <em>unixfrom</em> 为真值时，返回的字符串会包含信封标头。 <em>unixfrom</em> 的默认值为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 <em>policy</em> 参数可被用于重载从消息实例获取的默认 policy。 这可被用来控制该方法所产生的部分格式效果，因为指定的 <em>policy</em> 将被传递给 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a>。</p>
<p>扁平化信息可能会对 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 做出修改。这是因为为了完成向字符串的转换，一些内容需要使用默认值填入（举个例子，MIME 边界字段可能会被生成或被修改）。</p>
<p>请注意，这个方法是为了便利而提供，不一定是适合你的应用程序的最理想的序列化信息的方法。这在你处理多封信息的时候尤甚。如果你需要使用更加灵活的API来序列化信息，请参见 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.generator.BytesGenerator</span></code></a> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.__bytes__">
<span class="sig-name descname"><span class="pre">__bytes__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__bytes__" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#email.message.EmailMessage.as_bytes" title="email.message.EmailMessage.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a> 等价。这将让 <code class="docutils literal notranslate"><span class="pre">bytes(msg)</span></code> 产生一个包含序列化信息内容的字节序列对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.is_multipart">
<span class="sig-name descname"><span class="pre">is_multipart</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.is_multipart" title="永久链接至目标">¶</a></dt>
<dd><p>如果该信息的载荷是一个子 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 对象列表，返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> ；否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。在 <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的场合下，载荷应当是一个字符串对象（有可能是一个使用了内容传输编码进行编码的二进制载荷）。请注意， <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 不意味着 <code class="docutils literal notranslate"><span class="pre">msg.get_content_maintype()</span> <span class="pre">==</span> <span class="pre">'multipart'</span></code> 也会返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。举个例子， <code class="docutils literal notranslate"><span class="pre">is_multipart</span></code> 在 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 是 <code class="docutils literal notranslate"><span class="pre">message/rfc822</span></code> 类型的信息的情况下，其返回值也是 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.set_unixfrom">
<span class="sig-name descname"><span class="pre">set_unixfrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unixfrom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_unixfrom" title="永久链接至目标">¶</a></dt>
<dd><p>将信息的信封头设置为 <em>unixform</em> ，这应当是一个字符串。（在  <a class="reference internal" href="mailbox.html#mailbox.mboxMessage" title="mailbox.mboxMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">mboxMessage</span></code></a> 中有关于这个头的一段简短介绍。）</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_unixfrom">
<span class="sig-name descname"><span class="pre">get_unixfrom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_unixfrom" title="永久链接至目标">¶</a></dt>
<dd><p>返回消息的信封头。如果信封头从未被设置过，默认返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
</dd></dl>

<p>以下方法实现了对信息的头字段进行访问的类映射接口。请留意，只是类映射接口，这与平常的映射接口（比如说字典映射）有一些语义上的不同。举个例子，在一个字典当中，键之间不可重复，但是信息头字段是可以重复的。不光如此，在字典当中调用 <a class="reference internal" href="#email.message.EmailMessage.keys" title="email.message.EmailMessage.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code></a> 方法返回的结果，其顺序没有保证；但是在一个 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 对象当中，返回的头字段永远以其在原信息当中出现的顺序，或以其加入信息的顺序为序。任何删了后又重新加回去的头字段总是添加在当时列表的末尾。</p>
<p>这些语义上的不同是刻意而为之的，是出于在绝大多数常见使用情景中都方便的初衷下设计的。</p>
<p>请注意在任何情况下，消息当中的任何封包标头都不会包含在映射接口当中。</p>
<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.__len__">
<span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__len__" title="永久链接至目标">¶</a></dt>
<dd><p>返回标头的总数，包括重复项。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.__contains__">
<span class="sig-name descname"><span class="pre">__contains__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__contains__" title="永久链接至目标">¶</a></dt>
<dd><p>如果消息对象中有一个名为 <em>name</em> 的字段，其返回值为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。匹配无视大小写差异， <em>name</em> 也不包含末尾的的冒号。  <code class="docutils literal notranslate"><span class="pre">in</span></code> 操作符的实现中用到了这个方法，比如说：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="s1">&#39;message-id&#39;</span> <span class="ow">in</span> <span class="n">myMessage</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Message-ID:&#39;</span><span class="p">,</span> <span class="n">myMessage</span><span class="p">[</span><span class="s1">&#39;message-id&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__getitem__" title="永久链接至目标">¶</a></dt>
<dd><p>返回头字段名对应的字段值。 <em>name</em> 不含冒号分隔符。如果字段未找到，返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 异常永不抛出。</p>
<p>请注意，如果对应名字的字段找到了多个，具体返回哪个字段值是未定义的。请使用 <a class="reference internal" href="#email.message.EmailMessage.get_all" title="email.message.EmailMessage.get_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_all()</span></code></a> 方法获取当前匹配字段名的所有字段值。</p>
<p>使用标准策略（非 <code class="docutils literal notranslate"><span class="pre">compat32</span></code>）时，返回值是 <a class="reference internal" href="email.headerregistry.html#email.headerregistry.BaseHeader" title="email.headerregistry.BaseHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.headerregistry.BaseHeader</span></code></a> 的某个子类的一个实例。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.__setitem__">
<span class="sig-name descname"><span class="pre">__setitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__setitem__" title="永久链接至目标">¶</a></dt>
<dd><p>在信息头中添加名为 <em>name</em> 值为 <em>val</em> 的字段。这个字段会被添加在已有字段列表的结尾处。</p>
<p>请注意，这个方法 <em>既不会</em> 覆盖 <em>也不会</em> 删除任何字段名重名的已有字段。如果你确实想保证新字段是整个信息头当中唯一拥有 <em>name</em> 字段名的字段，你需要先把旧字段删除。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span>
<span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Python roolz!&#39;</span>
</pre></div>
</div>
<p>如果 <code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code> 明确要求某些字段是唯一的（至少标准策略就有这么做），对这些字段在已有同名字段的情况下仍然调用此方法尝试为字段名赋值会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。这是为了一致性而刻意设计出的行为，不过我们随时可能会突然觉得“还是在这种情况下自动把旧字段删除比较好吧”而把这个行为改掉，所以不要以为这是特性而依赖这个行为。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.__delitem__">
<span class="sig-name descname"><span class="pre">__delitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__delitem__" title="永久链接至目标">¶</a></dt>
<dd><p>删除信息头当中字段名匹配 <em>name</em> 的所有字段。如果匹配指定名称的字段没有找到，也不会抛出任何异常。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.keys" title="永久链接至目标">¶</a></dt>
<dd><p>以列表形式返回消息头中所有的字段名。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.values" title="永久链接至目标">¶</a></dt>
<dd><p>以列表形式返回消息头中所有的字段值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.items" title="永久链接至目标">¶</a></dt>
<dd><p>以二元元组的列表形式返回消息头中所有的字段名和字段值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get" title="永久链接至目标">¶</a></dt>
<dd><p>返回对应字段名的字段值。这个方法与 <a class="reference internal" href="#email.message.EmailMessage.__getitem__" title="email.message.EmailMessage.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 是一样的，只不过如果对应字段名的字段没有找到，该方法会返回 <em>failobj</em> 。这个参数是可选的（默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> ）。</p>
</dd></dl>

<p>以下是一些与头有关的更多有用方法：</p>
<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_all">
<span class="sig-name descname"><span class="pre">get_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_all" title="永久链接至目标">¶</a></dt>
<dd><p>返回字段名为 <em>name</em> 的所有字段值的列表。如果信息内不存在匹配的字段，返回 <em>failobj</em> （其默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> ）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.add_header">
<span class="sig-name descname"><span class="pre">add_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_header" title="永久链接至目标">¶</a></dt>
<dd><p>高级头字段设定。这个方法与 <a class="reference internal" href="#email.message.EmailMessage.__setitem__" title="email.message.EmailMessage.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> 类似，不过你可以使用关键字参数为字段提供附加参数。 <em>_name</em> 是字段名， <em>_value</em> 是字段 <em>主</em> 值。</p>
<p>对于关键字参数字典 <em>_params</em> 的每个键值对而言，它的键被用作参数的名字，其中下划线被替换为短横杠（毕竟短横杠不是合法的Python标识符）。一般来讲，参数以 <code class="docutils literal notranslate"><span class="pre">键=&quot;值&quot;</span></code> 的方式添加，除非值是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。要真的是这样的话，只有键会被添加。</p>
<p>如果值含有非ASCII字符，你可以将值写成 <code class="docutils literal notranslate"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAGE,</span> <span class="pre">VALUE)</span></code> 形式的三元组，这样你可以人为控制字符的字符集和语言。 <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code> 是一个字符串，它为你的值的编码命名； <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> 一般可以直接设为 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，也可以直接设为空字符串（其他可能取值参见 :rfc`2231` ）； <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> 是一个字符串值，其包含非ASCII的码点。如果你没有使用三元组，你的字符串又含有非ASCII字符，那么它就会使用 <span class="target" id="index-25"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a> 中， <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code> 为 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> ， <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的格式编码。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;bud.gif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>会添加一个形如下文的头字段：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Disposition</span><span class="p">:</span> <span class="n">attachment</span><span class="p">;</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;bud.gif&quot;</span>
</pre></div>
</div>
<p>带有非ASCII字符的拓展接口：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span>
               <span class="n">filename</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;iso-8859-1&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;Fußballer.ppt&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.replace_header">
<span class="sig-name descname"><span class="pre">replace_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.replace_header" title="永久链接至目标">¶</a></dt>
<dd><p>替换头字段。只会替换掉信息内找到的第一个字段名匹配 <em>_name</em> 的字段值。字段的顺序不变，原字段名的大小写也不变。如果没有找到匹配的字段，抛出 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 异常。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_content_type">
<span class="sig-name descname"><span class="pre">get_content_type</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_type" title="永久链接至目标">¶</a></dt>
<dd><p>返回信息的内容类型，其形如 <em class="mimetype">maintype/subtype</em> ，强制全小写。如果信息的 <em class="mailheader">Content-Type</em> 头字段不存在则返回 <a class="reference internal" href="#email.message.EmailMessage.get_default_type" title="email.message.EmailMessage.get_default_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_default_type()</span></code></a> 的返回值；如果信息的 <em class="mailheader">Content-Type</em> 头字段无效则返回 <code class="docutils literal notranslate"><span class="pre">text/plain</span></code> 。</p>
<p>（根据 <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> 所述，信息永远都有一个默认类型，所以 <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a> 一定会返回一个值。 <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> 定义信息的默认类型为 <em class="mimetype">text/plain</em> 或 <em class="mimetype">message/rfc822</em> ，其中后者仅出现在消息头位于一个 <em class="mimetype">multipart/digest</em> 容器中的场合中。如果消息头的 <em class="mailheader">Content-Type</em> 字段所指定的类型是无效的， <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> 令其默认类型为 <em class="mimetype">text/plain</em> 。）</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_content_maintype">
<span class="sig-name descname"><span class="pre">get_content_maintype</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_maintype" title="永久链接至目标">¶</a></dt>
<dd><p>返回信息的主要内容类型。准确来说，此方法返回的是 <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a> 方法所返回的形如 <em class="mimetype">maintype/subtype</em> 的字符串当中的 <em class="mimetype">maintype</em> 部分。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_content_subtype">
<span class="sig-name descname"><span class="pre">get_content_subtype</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_subtype" title="永久链接至目标">¶</a></dt>
<dd><p>返回信息的子内容类型。准确来说，此方法返回的是 <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a> 方法所返回的形如 <em class="mimetype">maintype/subtype</em> 的字符串当中的 <em class="mimetype">subtype</em> 部分。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_default_type">
<span class="sig-name descname"><span class="pre">get_default_type</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_default_type" title="永久链接至目标">¶</a></dt>
<dd><p>返回默认的内容类型。绝大多数的信息，其默认内容类型都是 <em class="mimetype">text/plain</em> 。作为 <em class="mimetype">multipart/digest</em> 容器内子部分的信息除外，它们的默认内容类型是 <em class="mimetype">message/rfc822</em> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.set_default_type">
<span class="sig-name descname"><span class="pre">set_default_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_default_type" title="永久链接至目标">¶</a></dt>
<dd><p>设置默认的内容类型。 尽管并非强制，但是 <em>ctype</em> 仍应当是 <em class="mimetype">text/plain</em> 或 <em class="mimetype">message/rfc822</em> 二者取一。默认内容类型并不存储在 <em class="mailheader">Content-Type</em> 头字段当中，所以设置此项的唯一作用就是决定当 <em class="mailheader">Content-Type</em> 头字段在信息中不存在时，<code class="docutils literal notranslate"><span class="pre">get_content_type</span></code> 方法的返回值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.set_param">
<span class="sig-name descname"><span class="pre">set_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Content-Type'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requote</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">charset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">language</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_param" title="永久链接至目标">¶</a></dt>
<dd><p>在 <em class="mailheader">Content-Type</em> 头字段当中设置一个参数。如果该参数已于字段中存在，将其旧值替换为 <em>value</em> 。如果 <em>header</em> 是 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> （默认值），并且该头字段于信息中尚未存在，则会先添加该字段，将其值设置为 <em class="mimetype">text/plain</em> ，并附加参数值。可选的 <em>header</em> 可以让你指定 <em class="mailheader">Content-Type</em> 之外的另一个头字段。</p>
<p>如果值包含非ASCII字符，其字符集和语言可以通过可选参数 <em>charset</em> 和 <em>language</em> 显式指定。可选参数 <em>language</em> 指定 <span class="target" id="index-29"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a> 当中的语言，其默认值是空字符串。 <em>charset</em> 和 <em>language</em> 都应当字符串。默认使用的是 <code class="docutils literal notranslate"><span class="pre">utf8</span></code> <em>charset</em> ，<em>language</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
<p>如果 <em>replace</em> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> （默认值），该头字段会被移动到所有头字段列表的末尾。如果 <em>replace</em> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，字段会被原地更新。</p>
<p>于 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 对象而言， <em>requote</em> 参数已被弃用。</p>
<p>请注意，头字段已有的参数值可以通过头字段的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">params</span></code> 属性来访问（举例： <code class="docutils literal notranslate"><span class="pre">msg['Content-Type'].params['charset']</span></code> ）。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>添加了 <code class="docutils literal notranslate"><span class="pre">replace</span></code> 关键字。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.del_param">
<span class="sig-name descname"><span class="pre">del_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'content-type'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requote</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.del_param" title="永久链接至目标">¶</a></dt>
<dd><p>从 <em class="mailheader">Content-Type</em> 头字段中完全移去给定的参数。头字段会被原地重写，重写后的字段不含参数和值。可选的 <em>header</em> 可以让你指定 <em class="mailheader">Content-Type</em> 之外的另一个字段。</p>
<p>于 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 对象而言， <em>requote</em> 参数已被弃用。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_filename">
<span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_filename" title="永久链接至目标">¶</a></dt>
<dd><p>返回信息头当中 <em class="mailheader">Content-Disposition</em> 字段当中名为 <code class="docutils literal notranslate"><span class="pre">filename</span></code> 的参数值。如果该字段当中没有此参数，该方法会退而寻找 <em class="mailheader">Content-Type</em> 字段当中的 <code class="docutils literal notranslate"><span class="pre">name</span></code> 参数值。如果这个也没有找到，或者这些个字段压根就不存在，返回 <em>failobj</em> 。返回的字符串永远按照 <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a> 方法去除引号。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_boundary">
<span class="sig-name descname"><span class="pre">get_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_boundary" title="永久链接至目标">¶</a></dt>
<dd><p>返回信息头当中 <em class="mailheader">Content-Type</em> 字段当中名为 <code class="docutils literal notranslate"><span class="pre">boundary</span></code> 的参数值。如果字段当中没有此参数，或者这些个字段压根就不存在，返回 <em>failobj</em> 。返回的字符串永远按照 <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a> 方法去除引号。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.set_boundary">
<span class="sig-name descname"><span class="pre">set_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boundary</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_boundary" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em class="mailheader">Content-Type</em> 头字段的 <code class="docutils literal notranslate"><span class="pre">boundary</span></code> 参数设置为 <em>boundary</em> 。 <a class="reference internal" href="#email.message.EmailMessage.set_boundary" title="email.message.EmailMessage.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a> 方法永远都会在必要的时候为 <em>boundary</em> 添加引号。如果信息对象中没有 <em class="mailheader">Content-Type</em> 头字段，抛出 <a class="reference internal" href="email.errors.html#email.errors.HeaderParseError" title="email.errors.HeaderParseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HeaderParseError</span></code></a> 异常。</p>
<p>请注意使用这个方法与直接删除旧的 <em class="mailheader">Content-Type</em> 头字段然后使用 <a class="reference internal" href="#email.message.EmailMessage.add_header" title="email.message.EmailMessage.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a> 方法添加一个带有新边界值参数的 <em class="mailheader">Content-Type</em> 头字段有细微差距。 <a class="reference internal" href="#email.message.EmailMessage.set_boundary" title="email.message.EmailMessage.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a> 方法会保留 <em class="mailheader">Content-Type</em> 头字段在原信息头当中的位置。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_content_charset">
<span class="sig-name descname"><span class="pre">get_content_charset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_charset" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em class="mailheader">Content-Type</em> 头字段中的 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 参数，强制小写。如果字段当中没有此参数，或者这个字段压根不存在，返回 <em>failobj</em> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_charsets">
<span class="sig-name descname"><span class="pre">get_charsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_charsets" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个包含了信息内所有字符集名字的列表。 如果信息是 <em class="mimetype">multipart</em> 类型的，那么列表当中的每一项都对应其载荷的子部分的字符集名字。 否则，该列表是一个长度为 1 的列表。</p>
<p>列表当中的每一项都是一个字符串，其值为对应子部分的 <em class="mailheader">Content-Type</em> 头字段的 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 参数值。如果该子部分没有此头字段，或者没有此参数，或者其主要 MIME 类型并非 <em class="mimetype">text</em> ，那么列表中的那一项即为 <em>failobj</em> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.is_attachment">
<span class="sig-name descname"><span class="pre">is_attachment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.is_attachment" title="永久链接至目标">¶</a></dt>
<dd><p>如果信息头当中存在一个名为 <em class="mailheader">Content-Disposition</em> 的字段，且该字段的值为 <code class="docutils literal notranslate"><span class="pre">attachment</span></code> （大小写无关），返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。否则，返回 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4.2 版更改: </span>为了与 <a class="reference internal" href="email.compat32-message.html#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 方法一致，is_attachment 现在是一个方法，不再是属性了。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_content_disposition">
<span class="sig-name descname"><span class="pre">get_content_disposition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_disposition" title="永久链接至目标">¶</a></dt>
<dd><p>如果信息的 <em class="mailheader">Content-Disposition</em> 头字段存在，返回其字段值；否则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。返回的值均为小写，不包含参数。如果信息遵循 <span class="target" id="index-30"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2183.html"><strong>RFC 2183</strong></a> 标准，则此方法的返回值只可能在 <em>inline</em> 、 <em>attachment</em> 和 <code class="docutils literal notranslate"><span class="pre">None</span></code> 之间选择。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<p>下列方法与信息内容（载荷）之访问与操控有关。</p>
<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.walk">
<span class="sig-name descname"><span class="pre">walk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.walk" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> 方法是一个多功能生成器。它可以被用来以深度优先顺序遍历信息对象树的所有部分和子部分。一般而言， <a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> 会被用作 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环的迭代器，每一次迭代都返回其下一个子部分。</p>
<p>以下例子会打印出一封具有多部分结构之信息的每个部分的 MIME 类型。</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_type</span><span class="p">())</span>
<span class="go">multipart/report</span>
<span class="go">text/plain</span>
<span class="go">message/delivery-status</span>
<span class="go">text/plain</span>
<span class="go">text/plain</span>
<span class="go">message/rfc822</span>
<span class="go">text/plain</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">walk</span></code> 会遍历所有 <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 方法返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的部分之子部分，哪怕 <code class="docutils literal notranslate"><span class="pre">msg.get_content_maintype()</span> <span class="pre">==</span> <span class="pre">'multipart'</span></code> 返回的是 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。使用 <code class="docutils literal notranslate"><span class="pre">_structure</span></code> 除错帮助函数可以帮助我们在下面这个例子当中看清楚这一点：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email.iterators</span> <span class="kn">import</span> <span class="n">_structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_maintype</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;multipart&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">part</span><span class="o">.</span><span class="n">is_multipart</span><span class="p">())</span>
<span class="go">True True</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_structure</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">multipart/report</span>
<span class="go">    text/plain</span>
<span class="go">    message/delivery-status</span>
<span class="go">        text/plain</span>
<span class="go">        text/plain</span>
<span class="go">    message/rfc822</span>
<span class="go">        text/plain</span>
</pre></div>
</div>
<p>在这里， <code class="docutils literal notranslate"><span class="pre">message</span></code> 的部分并非 <code class="docutils literal notranslate"><span class="pre">multiparts</span></code> ，但是它们真的包含子部分！ <code class="docutils literal notranslate"><span class="pre">is_multipart()</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> ， <code class="docutils literal notranslate"><span class="pre">walk</span></code> 也深入进这些子部分中。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_body">
<span class="sig-name descname"><span class="pre">get_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preferencelist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('related',</span> <span class="pre">'html',</span> <span class="pre">'plain')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_body" title="永久链接至目标">¶</a></dt>
<dd><p>返回信息的 MIME 部分。这个部分是最可能成为信息体的部分。</p>
<p><em>preferencelist</em> 必须是一个字符串序列，其内容从 <code class="docutils literal notranslate"><span class="pre">related</span></code> 、 <code class="docutils literal notranslate"><span class="pre">html</span></code> 和 <code class="docutils literal notranslate"><span class="pre">plain</span></code> 这三者组成的集合中选取。这个序列代表着返回的部分的内容类型之偏好。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">get_body</span></code> 方法被调用的对象上寻找匹配的候选者。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">related</span></code> 未包括在 <em>preferencelist</em> 中，可考虑将所遇到的任意相关的根部分（或根部分的子部分）在该（子）部分与一个首选项相匹配时作为候选项。</p>
<p>当遇到一个 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 时，将检查 <code class="docutils literal notranslate"><span class="pre">start</span></code> 形参并且如果找到了一个匹配 <em class="mailheader">Content-ID</em> 的部分，在查找候选匹配时只考虑它。 在其他情况下则只考虑 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 的第一个（默认的根）部分。</p>
<p>如果一个部分具有 <em class="mailheader">Content-Disposition</em> 标头，则当标头值为 <code class="docutils literal notranslate"><span class="pre">inline</span></code> 时将只考虑将该部分作为候选匹配。</p>
<p>如果没有任何候选部分匹配 <em>preferencelist</em> 中的任何首选项，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>注: (1) 对于大多数应用来说有意义的 <em>preferencelist</em> 组合仅有 <code class="docutils literal notranslate"><span class="pre">('plain',)</span></code>, <code class="docutils literal notranslate"><span class="pre">('html',</span> <span class="pre">'plain')</span></code> 以及默认的 <code class="docutils literal notranslate"><span class="pre">('related',</span> <span class="pre">'html',</span> <span class="pre">'plain')</span></code>。 (2) 由于匹配是从调用 <code class="docutils literal notranslate"><span class="pre">get_body</span></code> 的对象开始的，因此在 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 上调用 <code class="docutils literal notranslate"><span class="pre">get_body</span></code> 将返回对象本身，除非 <em>preferencelist</em> 具有非默认值。 (3) 未指定 <em class="mailheader">Content-Type</em> 或者 <em class="mailheader">Content-Type</em> 标头无效的消息（或消息部分）将被当作具有 <code class="docutils literal notranslate"><span class="pre">text/plain</span></code> 类型来处理，这有时可能导致 <code class="docutils literal notranslate"><span class="pre">get_body</span></code> 返回非预期的结果。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.iter_attachments">
<span class="sig-name descname"><span class="pre">iter_attachments</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.iter_attachments" title="永久链接至目标">¶</a></dt>
<dd><p>返回包含所有不是候选 &quot;body&quot; 部分的消息的直接子部分的迭代器。 也就是说，跳过首次出现的每个 <code class="docutils literal notranslate"><span class="pre">text/plain</span></code>, <code class="docutils literal notranslate"><span class="pre">text/html</span></code>, <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 或 <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code> (除非通过 <em class="mailheader">Content-Disposition: attachment</em> 将它们显式地标记为附件)，并返回所有的其余部分。 当直接应用于 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 时，将返回包含除根部分之外所有相关部分的迭代器（即由 <code class="docutils literal notranslate"><span class="pre">start</span></code> 形参所指向的部分，或者当没有 <code class="docutils literal notranslate"><span class="pre">start</span></code> 形参或 <code class="docutils literal notranslate"><span class="pre">start</span></code> 形参不能匹配任何部分的 <em class="mailheader">Content-ID</em> 时则为第一部分）。 当直接应用于 <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code> 或非 <code class="docutils literal notranslate"><span class="pre">multipart</span></code> 时，将返回一个空迭代器。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.iter_parts">
<span class="sig-name descname"><span class="pre">iter_parts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.iter_parts" title="永久链接至目标">¶</a></dt>
<dd><p>返回包含消息的所有直接子部分的迭代器，对于非 <code class="docutils literal notranslate"><span class="pre">multipart</span></code> 将为空对象。 （另请参阅 <a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a>。）</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.get_content">
<span class="sig-name descname"><span class="pre">get_content</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">content_manager</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content" title="永久链接至目标">¶</a></dt>
<dd><p>调用 <em>content_manager</em> 的 <a class="reference internal" href="email.contentmanager.html#email.contentmanager.ContentManager.get_content" title="email.contentmanager.ContentManager.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a> 方法，将自身作为消息对象传入，并将其他参数或关键字作为额外参数传入。 如果未指定 <em>content_manager</em>，则会使用当前 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 所指定的 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.set_content">
<span class="sig-name descname"><span class="pre">set_content</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">content_manager</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_content" title="永久链接至目标">¶</a></dt>
<dd><p>调用 <em>content_manager</em> 的 <a class="reference internal" href="email.contentmanager.html#email.contentmanager.ContentManager.set_content" title="email.contentmanager.ContentManager.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 方法，将自身作为消息传入，并将其他参数或关键字作为额外参数传入。 如果未指定 <em>content_manager</em>，则会使用当前 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 所指定的 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.make_related">
<span class="sig-name descname"><span class="pre">make_related</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.make_related" title="永久链接至目标">¶</a></dt>
<dd><p>将非 <code class="docutils literal notranslate"><span class="pre">multipart</span></code> 消息转换为 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 消息，将任何现有的 <em class="mailheader">Content-</em> 标头和载荷移入 <code class="docutils literal notranslate"><span class="pre">multipart</span></code> 的（新加）首部分。 如果指定了 <em>boundary</em>，会用它作为 multipart 中的分界字符串，否则会在必要时自动创建分界（例如当消息被序列化时）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.make_alternative">
<span class="sig-name descname"><span class="pre">make_alternative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.make_alternative" title="永久链接至目标">¶</a></dt>
<dd><p>将非 <code class="docutils literal notranslate"><span class="pre">multipart</span></code> 或 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code>，将任何现有的 <em class="mailheader">Content-</em> 标头和载荷移入 <code class="docutils literal notranslate"><span class="pre">multipart</span></code> 的（新加）首部分。 如果指定了 <em>boundary</em>，会用它作为 multipart 中的分界字符串，否则会在必要时自动创建分界（例如当消息被序列化时）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.make_mixed">
<span class="sig-name descname"><span class="pre">make_mixed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.make_mixed" title="永久链接至目标">¶</a></dt>
<dd><p>将非 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>, <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 或 <code class="docutils literal notranslate"><span class="pre">multipart-alternative</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">multipart/mixed</span></code>，将任何现有的 <em class="mailheader">Content-</em> 标头和载荷移入 <code class="docutils literal notranslate"><span class="pre">multipart</span></code> 的（新加）首部分。 如果指定了 <em>boundary</em>，会用它作为 multipart 中的分界字符串，否则会在必要时自动创建分界（例如当消息被序列化时）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.add_related">
<span class="sig-name descname"><span class="pre">add_related</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">content_manager</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_related" title="永久链接至目标">¶</a></dt>
<dd><p>如果消息为 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>，则创建一个新的消息对象，将所有参数传给其 <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 方法，并将其 <a class="reference internal" href="email.compat32-message.html#email.message.Message.attach" title="email.message.Message.attach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach()</span></code></a> 到 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>。 如果消息为非 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>，则先调用 <a class="reference internal" href="#email.message.EmailMessage.make_related" title="email.message.EmailMessage.make_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_related()</span></code></a> 然后再继续上述步骤。 如果消息为任何其他类型的 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>，则会引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 如果未指定 <em>content_manager</em>，则使用当前 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 所指定的 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>。 如果添加的部分没有 <em class="mailheader">Content-Disposition</em> 标头，则会添加一个值为 <code class="docutils literal notranslate"><span class="pre">inline</span></code> 的标头。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.add_alternative">
<span class="sig-name descname"><span class="pre">add_alternative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">content_manager</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_alternative" title="永久链接至目标">¶</a></dt>
<dd><p>如果消息为 <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code>，则创建一个新的消息对象，将所有参数传给其 <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 方法，并将其 <a class="reference internal" href="email.compat32-message.html#email.message.Message.attach" title="email.message.Message.attach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach()</span></code></a> 到 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>。 如果消息为非 <code class="docutils literal notranslate"><span class="pre">multipart</span></code> 或 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>，则先调用 <a class="reference internal" href="#email.message.EmailMessage.make_alternative" title="email.message.EmailMessage.make_alternative"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_alternative()</span></code></a> 然后再继续上述步骤。 如果消息为任何其他类型的 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>，则会引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 如果未指定 <em>content_manager</em>，则会使用当前 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 所指定的 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.add_attachment">
<span class="sig-name descname"><span class="pre">add_attachment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">content_manager</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_attachment" title="永久链接至目标">¶</a></dt>
<dd><p>如果消息为 <code class="docutils literal notranslate"><span class="pre">multipart/mixed</span></code>，则创建一个新的消息对象，将所有参数传给其 <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 方法，并将其 <a class="reference internal" href="email.compat32-message.html#email.message.Message.attach" title="email.message.Message.attach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach()</span></code></a> 到 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>。 如果消息为非 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>, <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 或 <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code>，则先调用 <a class="reference internal" href="#email.message.EmailMessage.make_mixed" title="email.message.EmailMessage.make_mixed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_mixed()</span></code></a> 然后再继续上述步骤。 如果未指定 <em>content_manager</em>，则使用当前 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 所指定的 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>。 如果添加的部分没有 <em class="mailheader">Content-Disposition</em> 标头，则会添加一个值为 <code class="docutils literal notranslate"><span class="pre">attachment</span></code> 的标头。 此方法对于显式附件 (<em class="mailheader">Content-Disposition: attachment</em>) 和 <code class="docutils literal notranslate"><span class="pre">inline</span></code> 附件 (<em class="mailheader">Content-Disposition: inline</em>) 均可使用，只须向 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code> 传入适当的选项即可。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.clear" title="永久链接至目标">¶</a></dt>
<dd><p>移除所有载荷和所有标头。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.EmailMessage.clear_content">
<span class="sig-name descname"><span class="pre">clear_content</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.clear_content" title="永久链接至目标">¶</a></dt>
<dd><p>移除载荷以及所有 <code class="xref py py-exc docutils literal notranslate"><span class="pre">Content-</span></code> 标头，其他标头不加改变并且保持其原有顺序。</p>
</dd></dl>

<p><a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 对象具有下列实例属性:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="email.message.EmailMessage.preamble">
<span class="sig-name descname"><span class="pre">preamble</span></span><a class="headerlink" href="#email.message.EmailMessage.preamble" title="永久链接至目标">¶</a></dt>
<dd><p>MIME 文档格式在标头之后的空白行以及第一个多部分的分界字符串之间允许添加一些文本， 通常，此文本在支持 MIME 的邮件阅读器中永远不可见，因为它处在标准 MIME 保护范围之外。 但是，当查看消息的原始文本，或当在不支持 MIME 的阅读器中查看消息时，此文本会变得可见。</p>
<p><em>preamble</em> 属性包含 MIME 文档开头部分的这些处于保护范围之外的文本。 当 <a class="reference internal" href="email.parser.html#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> 在标头之后及第一个分界字符串之前发现一些文本时，它会将这些文本赋值给消息的 <em>preamble</em> 属性。 当 <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 写出 MIME 消息的纯文本表示形式时，如果它发现消息具有 <em>preamble</em> 属性，它将在标头及第一个分界之间区域写出这些文本。 请参阅 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a> 和 <a class="reference internal" href="email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.generator</span></code></a> 了解更多细节。</p>
<p>请注意如果消息对象没有前导文本，则 <em>preamble</em> 属性将为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.message.EmailMessage.epilogue">
<span class="sig-name descname"><span class="pre">epilogue</span></span><a class="headerlink" href="#email.message.EmailMessage.epilogue" title="永久链接至目标">¶</a></dt>
<dd><p><em>epilogue</em> 属性的作用方式与 <em>preamble</em> 相同，区别在于它包含在最后一个分界及消息结尾之间出现的文本。 与 <a class="reference internal" href="#email.message.EmailMessage.preamble" title="email.message.EmailMessage.preamble"><code class="xref py py-attr docutils literal notranslate"><span class="pre">preamble</span></code></a> 类似，如果没有附加文本，则此属性将为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.message.EmailMessage.defects">
<span class="sig-name descname"><span class="pre">defects</span></span><a class="headerlink" href="#email.message.EmailMessage.defects" title="永久链接至目标">¶</a></dt>
<dd><p><em>defects</em> 属性包含在解析消息时发现的所有问题的列表。 请参阅 <a class="reference internal" href="email.errors.html#module-email.errors" title="email.errors: The exception classes used by the email package."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code></a> 了解可能的解析缺陷的详细描述。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="email.message.MIMEPart">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">email.message.</span></span><span class="sig-name descname"><span class="pre">MIMEPart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">default</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.MIMEPart" title="永久链接至目标">¶</a></dt>
<dd><p>这个类代表 MIME 消息的子部分。 它与 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 相似，不同之处在于当 <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 被调用时不会添加 <em class="mailheader">MIME-Version</em> 标头，因为子部分不需要有它们自己的 <em class="mailheader">MIME-Version</em> 标头。</p>
</dd></dl>

<p class="rubric">备注</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>原先在3.4版本中以 <a class="reference internal" href="../glossary.html#term-provisional-package"><span class="xref std std-term">provisional module</span></a> 添加。过时的文档被移动至 <a class="reference internal" href="email.compat32-message.html#compat32-message"><span class="std std-ref">email.message.Message: 使用 compat32 API 来表示电子邮件消息</span></a> 。</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="email.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 电子邮件与 MIME 处理包</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="email.parser.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code>: 解析电子邮件信息</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/email.message.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="email.parser.html" title="email.parser: 解析电子邮件信息"
             >下一页</a> |</li>
        <li class="right" >
          <a href="email.html" title="email --- 电子邮件与 MIME 处理包"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >互联网数据处理</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 电子邮件与 MIME 处理包</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code>: 表示一封电子邮件信息</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 11月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0创建。
    </div>

  </body>
</html>