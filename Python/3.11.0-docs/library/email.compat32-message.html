
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>email.message.Message: 使用 compat32 API 来表示电子邮件消息 &#8212; Python 3.11.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="email.mime: 从头创建电子邮件和 MIME 对象" href="email.mime.html" />
    <link rel="prev" title="email: 示例" href="email.examples.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/email.compat32-message.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="email.examples.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code>: 示例</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="email.mime.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime</span></code>: 从头创建电子邮件和 MIME 对象</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/email.compat32-message.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="email.mime.html" title="email.mime: 从头创建电子邮件和 MIME 对象"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="email.examples.html" title="email: 示例"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >互联网数据处理</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 电子邮件与 MIME 处理包</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message.Message</span></code>: 使用 <code class="xref py py-data docutils literal notranslate"><span class="pre">compat32</span></code> API 来表示电子邮件消息</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="email-message-message-representing-an-email-message-using-the-compat32-api">
<span id="compat32-message"></span><h1><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message.Message</span></code></a>: 使用 <a class="reference internal" href="email.policy.html#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-data docutils literal notranslate"><span class="pre">compat32</span></code></a> API 来表示电子邮件消息<a class="headerlink" href="#email-message-message-representing-an-email-message-using-the-compat32-api" title="永久链接至标题">¶</a></h1>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 类与 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 类非常相似，但没有该类所添加的方法，并且某些方法的默认行为也略有不同。 我们还在这里记录了一些虽然被 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 类所支持但并不推荐的方法，除非你是在处理旧有代码。</p>
<p>在其他情况下这两个类的理念和结构都是相同的。</p>
<p>本文档描述了默认 (对于 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>) 策略 <a class="reference internal" href="email.policy.html#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Compat32</span></code></a> 之下的行为。 如果你要使用其他策略，你应当改用 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 类。</p>
<p>电子邮件消息由多个 <em>标头</em> 和一个 <em>载荷</em> 组成。 标头必须为 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a> 风格的名称和值，其中字典名和值由冒号分隔。 冒号不是字段名或字段值的组成部分。 载荷可以是简单的文本消息，或是二进制对象，或是多个子消息的结构化序列，每个子消息都有自己的标头集合和自己的载荷。 后一种类型的载荷是由具有 <em class="mimetype">multipart/*</em> 或 <em class="mimetype">message/rfc822</em> 等 MIME 类型的消息来指明的。</p>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象所提供了概念化模型是由标头组成的有序字典，加上用于访问标头中的特殊信息以及访问载荷的额外方法，以便能生成消息的序列化版本，并递归地遍历对象树。 请注意重复的标头是受支持的，但必须使用特殊的方法来访问它们。</p>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 伪字典以标头名作为索引，标头名必须为 ASCII 值。 字典的值为应当只包含 ASCII 字符的字符串；对于非 ASCII 输入有一些特殊处理，但这并不总能产生正确的结果。 标头以保留原大小写的形式存储和返回，但字段名称匹配对大小写不敏感。 还可能会有一个单独的封包标头，也称 <em>Unix-From</em> 标头或 <code class="docutils literal notranslate"><span class="pre">From_</span></code> 标头。 <em>载荷</em> 对于简单消息对象的情况是一个字符串或字节串，对于 MIME 容器文档的情况 (例如 <em class="mimetype">multipart/*</em> 和 <em class="mimetype">message/rfc822</em>) 则是一个 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象。</p>
<p>以下是 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 类的方法:</p>
<dl class="py class">
<dt class="sig sig-object py" id="email.message.Message">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">email.message.</span></span><span class="sig-name descname"><span class="pre">Message</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">compat32</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message" title="永久链接至目标">¶</a></dt>
<dd><p>如果指定了 <em>policy</em> (它必须为 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 类的实例) 则使用它所设置的规则来更新和序列化消息的表示形式。 如果未设置 <em>policy</em>，则使用 <a class="reference internal" href="email.policy.html#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">compat32</span></code></a> 策略，该策略会保持对 Python 3.2 版 email 包的向下兼容性。 更多信息请参阅 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 文档。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>policy</em> 关键字参数。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.as_string">
<span class="sig-name descname"><span class="pre">as_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unixfrom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxheaderlen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.as_string" title="永久链接至目标">¶</a></dt>
<dd><p>以展平的字符串形式返回整个消息对象。 或可选的 <em>unixfrom</em> 为真值，返回的字符串会包括封包标头。 <em>unixfrom</em> 的默认值是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 出于保持向下兼容性的原因，<em>maxheaderlen</em> 的默认值是 <code class="docutils literal notranslate"><span class="pre">0</span></code>，因此如果你想要不同的值你必须显式地重载它（在策略中为 <em>max_line_length</em> 指定的值将被此方法忽略）。 <em>policy</em> 参数可被用于覆盖从消息实例获取的默认策略。 这可以用来对该方法所输出的格式进行一些控制，因为指定的 <em>policy</em> 将被传递给 <code class="docutils literal notranslate"><span class="pre">Generator</span></code>。</p>
<p>如果需要填充默认值以完成对字符串的转换则展平消息可能触发对 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 的修改（例如，MIME 边界可能会被生成或被修改）。</p>
<p>Note that this method is provided as a convenience and may not always
format the message the way you want.  For example, by default it does
not do the mangling of lines that begin with <code class="docutils literal notranslate"><span class="pre">From</span></code> that is
required by the Unix mbox format.  For more flexibility, instantiate a
<a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> instance and use its
<a class="reference internal" href="email.generator.html#email.generator.Generator.flatten" title="email.generator.Generator.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flatten()</span></code></a> method directly.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">email.generator</span> <span class="kn">import</span> <span class="n">Generator</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">mangle_from_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxheaderlen</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
</pre></div>
</div>
<p>如果消息对象包含未按照 RFC 标准进行编码的二进制数据，则这些不合规数据将被 unicode &quot;unknown character&quot; 码位值所替代。 （另请参阅 <a class="reference internal" href="#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a> 和 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a>。）</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>增加了 <em>policy</em> 关键字参数。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__str__" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#email.message.Message.as_string" title="email.message.Message.as_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_string()</span></code></a> 等价。 这将让 <code class="docutils literal notranslate"><span class="pre">str(msg)</span></code> 产生一个包含已格式化消息的字符号。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.as_bytes">
<span class="sig-name descname"><span class="pre">as_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unixfrom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.as_bytes" title="永久链接至目标">¶</a></dt>
<dd><p>以字节串对象的形式返回整个扁平化后的消息。 当可选的 <em>unixfrom</em> 为真值时，返回的字符串会包括封包标头。 <em>unixfrom</em> 的默认值为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 <em>policy</em> 参数可被用于重载从消息实例获取的默认策略。 这可被用来控制该方法所产生的部分格式化效果，因为指定的 <em>policy</em> 将被传递给 <code class="docutils literal notranslate"><span class="pre">BytesGenerator</span></code>。</p>
<p>如果需要填充默认值以完成对字符串的转换则展平消息可能触发对 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 的修改（例如，MIME 边界可能会被生成或被修改）。</p>
<p>Note that this method is provided as a convenience and may not always
format the message the way you want.  For example, by default it does
not do the mangling of lines that begin with <code class="docutils literal notranslate"><span class="pre">From</span></code> that is
required by the Unix mbox format.  For more flexibility, instantiate a
<a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a> instance and use its
<a class="reference internal" href="email.generator.html#email.generator.BytesGenerator.flatten" title="email.generator.BytesGenerator.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flatten()</span></code></a> method directly.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span> <span class="nn">email.generator</span> <span class="kn">import</span> <span class="n">BytesGenerator</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">BytesGenerator</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">mangle_from_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxheaderlen</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.__bytes__">
<span class="sig-name descname"><span class="pre">__bytes__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__bytes__" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a> 等价。 这将让 <code class="docutils literal notranslate"><span class="pre">bytes(msg)</span></code> 产生一个包含已格式化消息的字节串对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.is_multipart">
<span class="sig-name descname"><span class="pre">is_multipart</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.is_multipart" title="永久链接至目标">¶</a></dt>
<dd><p>如果该消息的载荷是一个子 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象列表则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 当 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">False</span></code> 时，载荷应当是一个字符串对象（有可能是一个 CTE 编码的二进制载荷）。 （请注意 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 并不意味着 &quot;msg.get_content_maintype() == 'multipart'&quot; 将返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 例如，<code class="docutils literal notranslate"><span class="pre">is_multipart</span></code> 在 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 类型为 <code class="docutils literal notranslate"><span class="pre">message/rfc822</span></code> 时也将返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。）</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.set_unixfrom">
<span class="sig-name descname"><span class="pre">set_unixfrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unixfrom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_unixfrom" title="永久链接至目标">¶</a></dt>
<dd><p>将消息的封包标头设为 <em>unixfrom</em>，这应当是一个字符串。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_unixfrom">
<span class="sig-name descname"><span class="pre">get_unixfrom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_unixfrom" title="永久链接至目标">¶</a></dt>
<dd><p>返回消息的信封头。如果信封头从未被设置过，默认返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.attach">
<span class="sig-name descname"><span class="pre">attach</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">payload</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.attach" title="永久链接至目标">¶</a></dt>
<dd><p>将给定的 <em>payload</em> 添加到当前载荷中，当前载荷在该调用之前必须为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或是一个 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象列表。 在调用之后，此载荷将总是一个 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象列表。 如果你想将此载荷设为一个标量对象（如字符串），请改用 <a class="reference internal" href="#email.message.Message.set_payload" title="email.message.Message.set_payload"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_payload()</span></code></a>。</p>
<p>这是一个过时的方法。 在 <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 类上它的功能已被 <a class="reference internal" href="email.message.html#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 及相应的 <code class="docutils literal notranslate"><span class="pre">make</span></code> 和 <code class="docutils literal notranslate"><span class="pre">add</span></code> 方法所替代。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_payload">
<span class="sig-name descname"><span class="pre">get_payload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_payload" title="永久链接至目标">¶</a></dt>
<dd><p>返回当前的载荷，它在 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 时将是一个 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象列表，在 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 时则是一个字符串。 如果该载荷是一个列表且你修改了这个列表对象，那么你就是原地修改了消息的载荷。</p>
<p>传入可选参数 <em>i</em> 时，如果 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，<a class="reference internal" href="#email.message.Message.get_payload" title="email.message.Message.get_payload"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_payload()</span></code></a> 将返回载荷从零开始计数的第 <em>i</em> 个元素。 如果 <em>i</em> 小于 0 或大于等于载荷中的条目数则将引发 <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>。 如果载荷是一个字符串 (即 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code>) 且给出了 <em>i</em>，则会引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p>可选的 <em>decode</em> 是一个指明载荷是否应根据 <em class="mailheader">Content-Transfer-Encoding</em> 标头被解码的旗标。 当其值为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 且消息没有多个部分时，如果此标头值为 <code class="docutils literal notranslate"><span class="pre">quoted-printable</span></code> 或 <code class="docutils literal notranslate"><span class="pre">base64</span></code> 则载荷将被解码。 如果使用了其他编码格式，或者找不到 <em class="mailheader">Content-Transfer-Encoding</em> 标头时，载荷将被原样返回（不编码）。 在所有情况下返回值都是二进制数据。 如果消息有多个部分且 <em>decode</em> 旗标为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则将返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 如果载荷为 base64 但内容不完全正确（如缺少填充符、存在 base64 字母表以外的字符等），则将在消息的缺陷属性中添加适当的缺陷值 (分别为 <code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidBase64PaddingDefect</span></code> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidBase64CharactersDefect</span></code>)。</p>
<p>当 <em>decode</em> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> (默认值) 时消息体会作为字符串返回而不解码 <em class="mailheader">Content-Transfer-Encoding</em>。 但是，对于 <em class="mailheader">Content-Transfer-Encoding</em> 为 8bit 的情况，会尝试使用 <em class="mailheader">Content-Type</em> 标头指定的 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 来解码原始字节串，并使用 <code class="docutils literal notranslate"><span class="pre">replace</span></code> 错误处理程序。  如果未指定 <code class="docutils literal notranslate"><span class="pre">charset</span></code>，或者如果指定的 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 未被 email 包所识别，则会使用默认的 ASCII 字符集来解码消息体。</p>
<p>这是一个过时的方法。 在 <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 类上它的功能已被 <a class="reference internal" href="email.message.html#email.message.EmailMessage.get_content" title="email.message.EmailMessage.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a> 和 <a class="reference internal" href="email.message.html#email.message.EmailMessage.iter_parts" title="email.message.EmailMessage.iter_parts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iter_parts()</span></code></a> 方法所替代。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.set_payload">
<span class="sig-name descname"><span class="pre">set_payload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">payload</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">charset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_payload" title="永久链接至目标">¶</a></dt>
<dd><p>将整个消息对象的载荷设为 <em>payload</em>。 客户端要负责确保载荷的不变性。 可选的 <em>charset</em> 用于设置消息的默认字符集；详情请参阅 <a class="reference internal" href="#email.message.Message.set_charset" title="email.message.Message.set_charset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_charset()</span></code></a>。</p>
<p>这是一个过时的方法。 在 <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 类上它的功能已被 <a class="reference internal" href="email.message.html#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 方法所替代。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.set_charset">
<span class="sig-name descname"><span class="pre">set_charset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">charset</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_charset" title="永久链接至目标">¶</a></dt>
<dd><p>将载荷的字符集设为 <em>charset</em>，它可以是 <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> 实例 (参见 <a class="reference internal" href="email.charset.html#module-email.charset" title="email.charset: Character Sets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.charset</span></code></a>)、字符集名称字符串或 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 如果是字符串，它将被转换为一个 <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> 实例。 如果 <em>charset</em> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code>，<code class="docutils literal notranslate"><span class="pre">charset</span></code> 形参将从 <em class="mailheader">Content-Type</em> 标头中被删除（消息将不会进行其他修改）。 任何其他值都将导致 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p>如果 <em class="mailheader">MIME-Version</em> 标头不存在则将被添加。 如果 <em class="mailheader">Content-Type</em> 标头不存在，则将添加一个值为 <em class="mimetype">text/plain</em> 的该标头。 无论 <em class="mailheader">Content-Type</em> 标头是否已存在，其 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 形参都将被设为 <em>charset.output_charset</em>。 如果 <em>charset.input_charset</em> 和 <em>charset.output_charset</em> 不同，则载荷将被重编码为 <em>output_charset</em>。 如果 <em class="mailheader">Content-Transfer-Encoding</em> 标头不存在，则载荷将在必要时使用指定的 <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> 来转换编码，并将添加一个具有相应值的标头。 如果 <em class="mailheader">Content-Transfer-Encoding</em> 标头已存在，则会假定载荷已使用该 <em class="mailheader">Content-Transfer-Encoding</em> 进行正确编码并不会再被修改。</p>
<p>这是一个过时的方法。 在 <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 类上它的功能已被 <code class="xref py py-meth docutils literal notranslate"><span class="pre">email.emailmessage.EmailMessage.set_content()</span></code> 方法的 <em>charset</em> 形参所替代。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_charset">
<span class="sig-name descname"><span class="pre">get_charset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_charset" title="永久链接至目标">¶</a></dt>
<dd><p>返回与消息的载荷相关联的 <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> 实例。</p>
<p>这是一个过时的方法。 在 <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 类上它将总是返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<p>以下方法实现了用于访问消息的 <span class="target" id="index-25"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2822.html"><strong>RFC 2822</strong></a> 标头的类映射接口。  请注意这些方法和普通映射（例如字典）接口之间存在一些语义上的不同。 举例来说，在一个字典中不能有重复的键，但消息标头则可能有重复。 并且，在字典中由 <a class="reference internal" href="#email.message.Message.keys" title="email.message.Message.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code></a> 返回的键的顺序是没有保证的，但在 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象中，标头总是会按它们在原始消息中的出现或后继加入顺序返回。 任何已删除再重新加入的标头总是会添加到标头列表的末尾。</p>
<p>这些语义上的差异是有意为之且其目的是为了提供最大的便利性。</p>
<p>请注意在任何情况下，消息当中的任何封包标头都不会包含在映射接口当中。</p>
<p>In a model generated from bytes, any header values that (in contravention of
the RFCs) contain non-ASCII bytes will, when retrieved through this
interface, be represented as <a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> objects with
a charset of <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.__len__">
<span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__len__" title="永久链接至目标">¶</a></dt>
<dd><p>返回标头的总数，包括重复项。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.__contains__">
<span class="sig-name descname"><span class="pre">__contains__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__contains__" title="永久链接至目标">¶</a></dt>
<dd><p>如果消息对象中有一个名为 <em>name</em> 的字段则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 匹配操作对大小写不敏感并且 <em>name</em> 不应包括末尾的冒号。 用于 <code class="docutils literal notranslate"><span class="pre">in</span></code> 运算符，例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="s1">&#39;message-id&#39;</span> <span class="ow">in</span> <span class="n">myMessage</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Message-ID:&#39;</span><span class="p">,</span> <span class="n">myMessage</span><span class="p">[</span><span class="s1">&#39;message-id&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__getitem__" title="永久链接至目标">¶</a></dt>
<dd><p>返回指定名称标头字段的值。 <em>name</em> 不应包括作为字段分隔符的冒号。 如果标头未找到，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>；<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 永远不会被引发。</p>
<p>请注意如果指定名称的字段在消息标头中多次出现，具体将返回哪个字段值是未定义的。 请使用 <a class="reference internal" href="#email.message.Message.get_all" title="email.message.Message.get_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_all()</span></code></a> 方法来获取所有指定名称标头的值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.__setitem__">
<span class="sig-name descname"><span class="pre">__setitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__setitem__" title="永久链接至目标">¶</a></dt>
<dd><p>将具有字段名 <em>name</em> 和值 <em>val</em> 的标头添加到消息中。 字段会被添加到消息的现有字段的末尾。</p>
<p>请注意，这个方法 <em>既不会</em> 覆盖 <em>也不会</em> 删除任何字段名重名的已有字段。如果你确实想保证新字段是整个信息头当中唯一拥有 <em>name</em> 字段名的字段，你需要先把旧字段删除。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span>
<span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Python roolz!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.__delitem__">
<span class="sig-name descname"><span class="pre">__delitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__delitem__" title="永久链接至目标">¶</a></dt>
<dd><p>删除信息头当中字段名匹配 <em>name</em> 的所有字段。如果匹配指定名称的字段没有找到，也不会抛出任何异常。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.keys" title="永久链接至目标">¶</a></dt>
<dd><p>以列表形式返回消息头中所有的字段名。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.values" title="永久链接至目标">¶</a></dt>
<dd><p>以列表形式返回消息头中所有的字段值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.items" title="永久链接至目标">¶</a></dt>
<dd><p>以二元元组的列表形式返回消息头中所有的字段名和字段值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get" title="永久链接至目标">¶</a></dt>
<dd><p>返回指定名称标头字段的值。 这与 <a class="reference internal" href="#email.message.Message.__getitem__" title="email.message.Message.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 是一样的，不同之处在于如果指定名称标头未找到则会返回可选的 <em>failobj</em> (默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>)。</p>
</dd></dl>

<p>以下是一些有用的附加方法:</p>
<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_all">
<span class="sig-name descname"><span class="pre">get_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_all" title="永久链接至目标">¶</a></dt>
<dd><p>返回字段名为 <em>name</em> 的所有字段值的列表。如果信息内不存在匹配的字段，返回 <em>failobj</em> （其默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> ）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.add_header">
<span class="sig-name descname"><span class="pre">add_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.add_header" title="永久链接至目标">¶</a></dt>
<dd><p>高级头字段设定。这个方法与 <a class="reference internal" href="#email.message.Message.__setitem__" title="email.message.Message.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> 类似，不过你可以使用关键字参数为字段提供附加参数。 <em>_name</em> 是字段名， <em>_value</em> 是字段 <em>主</em> 值。</p>
<p>对于关键字参数字典 <em>_params</em> 中的每一项，其键会被当作形参名，并执行下划线和连字符间的转换（因为连字符不是合法的 Python 标识符）。 通常，形参将以 <code class="docutils literal notranslate"><span class="pre">key=&quot;value&quot;</span></code> 的形式添加，除非值为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，在这种情况下将只添加键。 如果值包含非 ASCII 字符，可将其指定为格式为 <code class="docutils literal notranslate"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAGE,</span> <span class="pre">VALUE)</span></code> 的三元组，其中 <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code> 为要用来编码值的字符集名称字符串，<code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> 通常可设为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或空字符串（请参阅 <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a> 了解其他可能的取值），而 <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> 为包含非 ASCII 码位的字符串值。 如果不是传入一个三元组且值包含非 ASCII 字符，则会自动以 <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a> 格式使用 <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code> 为 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> 和 <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 对其进行编码。</p>
<p>以下是为示例代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;bud.gif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>会添加一个形如下文的头字段：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Disposition</span><span class="p">:</span> <span class="n">attachment</span><span class="p">;</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;bud.gif&quot;</span>
</pre></div>
</div>
<p>使用非 ASCII 字符的示例代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span>
               <span class="n">filename</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;iso-8859-1&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;Fußballer.ppt&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>它的输出结果为</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Disposition</span><span class="p">:</span> <span class="n">attachment</span><span class="p">;</span> <span class="n">filename</span><span class="o">*=</span><span class="s2">&quot;iso-8859-1&#39;&#39;Fu%DFballer.ppt&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.replace_header">
<span class="sig-name descname"><span class="pre">replace_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.replace_header" title="永久链接至目标">¶</a></dt>
<dd><p>替换一个标头。 将替换在匹配 <em>_name</em> 的消息中找到的第一个标头，标头顺序和字段名大小写保持不变。 如果未找到匹配的标头，则会引发 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_content_type">
<span class="sig-name descname"><span class="pre">get_content_type</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_type" title="永久链接至目标">¶</a></dt>
<dd><p>返回消息的内容类型。 返回的字符串会强制转换为 <em class="mimetype">maintype/subtype</em> 的全小写形式。 如果消息中没有 <em class="mailheader">Content-Type</em> 标头则将返回由 <a class="reference internal" href="#email.message.Message.get_default_type" title="email.message.Message.get_default_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_default_type()</span></code></a> 给出的默认类型。 因为根据 <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a>，消息总是要有一个默认类型，所以 <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a> 将总是返回一个值。</p>
<p><span class="target" id="index-29"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> 将消息的默认类型定义为 <em class="mimetype">text/plain</em>，除非它是出现在 <em class="mimetype">multipart/digest</em> 容器内，在这种情况下其类型应为 <em class="mimetype">message/rfc822</em>。 如果 <em class="mailheader">Content-Type</em> 标头指定了无效的类型，<span class="target" id="index-30"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> 规定其默认类型应为 <em class="mimetype">text/plain</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_content_maintype">
<span class="sig-name descname"><span class="pre">get_content_maintype</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_maintype" title="永久链接至目标">¶</a></dt>
<dd><p>返回信息的主要内容类型。准确来说，此方法返回的是 <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a> 方法所返回的形如 <em class="mimetype">maintype/subtype</em> 的字符串当中的 <em class="mimetype">maintype</em> 部分。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_content_subtype">
<span class="sig-name descname"><span class="pre">get_content_subtype</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_subtype" title="永久链接至目标">¶</a></dt>
<dd><p>返回信息的子内容类型。准确来说，此方法返回的是 <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a> 方法所返回的形如 <em class="mimetype">maintype/subtype</em> 的字符串当中的 <em class="mimetype">subtype</em> 部分。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_default_type">
<span class="sig-name descname"><span class="pre">get_default_type</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_default_type" title="永久链接至目标">¶</a></dt>
<dd><p>返回默认的内容类型。绝大多数的信息，其默认内容类型都是 <em class="mimetype">text/plain</em> 。作为 <em class="mimetype">multipart/digest</em> 容器内子部分的信息除外，它们的默认内容类型是 <em class="mimetype">message/rfc822</em> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.set_default_type">
<span class="sig-name descname"><span class="pre">set_default_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_default_type" title="永久链接至目标">¶</a></dt>
<dd><p>设置默认的内容类型。 <em>ctype</em> 应当为 <em class="mimetype">text/plain</em> 或者 <em class="mimetype">message/rfc822</em>，尽管这并非强制。 默认的内容类型不会存储在 <em class="mailheader">Content-Type</em> 标头中。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_params">
<span class="sig-name descname"><span class="pre">get_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'content-type'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unquote</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_params" title="永久链接至目标">¶</a></dt>
<dd><p>将消息的 <em class="mailheader">Content-Type</em> 形参作为列表返回。 所返回列表的元素为以 <code class="docutils literal notranslate"><span class="pre">'='</span></code> 号拆分出的键/值对 2 元组。 <code class="docutils literal notranslate"><span class="pre">'='</span></code> 左侧的为键，右侧的为值。 如果形参值中没有 <code class="docutils literal notranslate"><span class="pre">'='</span></code> 号，否则该将值如 <a class="reference internal" href="#email.message.Message.get_param" title="email.message.Message.get_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_param()</span></code></a> 描述并且在可选 <em>unquote</em> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code> (默认值) 时会被取消转义。</p>
<p>可选的 <em>failobj</em> 是在没有 <em class="mailheader">Content-Type</em> 标头时要返回的对象。 可选的 <em>header</em> 是要替代 <em class="mailheader">Content-Type</em> 被搜索的标头。</p>
<p>这是一个过时的方法。 在 <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 类上它的功能已被标头访问方法所返回的单独标头对象的 <em>params</em> 特征属性所替代。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_param">
<span class="sig-name descname"><span class="pre">get_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'content-type'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unquote</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_param" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em class="mailheader">Content-Type</em> 标头的形参 <em>param</em> 作为字符串返回。 如果消息没有 <em class="mailheader">Content-Type</em> 标头或者没有这样的形参，则返回 <em>failobj</em> (默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>)。</p>
<p>如果给出可选的 <em>header</em>，它会指定要替代 <em class="mailheader">Content-Type</em> 来使用的消息标头。</p>
<p>形参的键总是以大小写不敏感的方式来比较的。 返回值可以是一个字符串，或者如果形参以 <span class="target" id="index-31"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a> 编码则是一个 3 元组。 当为 3 元组时，值中的元素采用 <code class="docutils literal notranslate"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAGE,</span> <span class="pre">VALUE)</span></code> 的形式。 请注意 <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code> 和 <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> 都可以为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，在此情况下你应当将 <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> 当作以 <code class="docutils literal notranslate"><span class="pre">us-ascii</span></code> 字符集来编码。 你可以总是忽略 <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code>。</p>
<p>如果你的应用不关心形参是否以 <span class="target" id="index-32"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a> 来编码，你可以通过调用 <a class="reference internal" href="email.utils.html#email.utils.collapse_rfc2231_value" title="email.utils.collapse_rfc2231_value"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.collapse_rfc2231_value()</span></code></a> 来展平形参值，传入来自 <a class="reference internal" href="#email.message.Message.get_param" title="email.message.Message.get_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_param()</span></code></a> 的返回值。 当值为元组时这将返回一个经适当编码的 Unicode 字符串，否则返回未经转换的原字符串。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">rawparam</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="n">param</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">collapse_rfc2231_value</span><span class="p">(</span><span class="n">rawparam</span><span class="p">)</span>
</pre></div>
</div>
<p>无论在哪种情况下，形参值（或为返回的字符串，或为 3 元组形式的 <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> 条目）总是未经转换的，除非 <em>unquote</em> 被设为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<p>这是一个过时的方法。 在 <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 类上它的功能已被标头访问方法所返回的单独标头对象的 <em>params</em> 特征属性所替代。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.set_param">
<span class="sig-name descname"><span class="pre">set_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Content-Type'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requote</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">charset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">language</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_param" title="永久链接至目标">¶</a></dt>
<dd><p>在 <em class="mailheader">Content-Type</em> 标头中设置一个形参。 如果该形参已存在于标头中，它的值将被替换为 <em>value</em>。 如果此消息还未定义 <em class="mailheader">Content-Type</em> 标头，它将被设为 <em class="mimetype">text/plain</em> 且新的形参值将按 <span class="target" id="index-33"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> 的要求添加。</p>
<p>可选的 <em>header</em> 指定一个 <em class="mailheader">Content-Type</em> 的替代标头，并且所有形参将根据需要被转换，除非可选的 <em>requote</em> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> (默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>)。</p>
<p>如果指定了可选的 <em>charset</em>，形参将按照 <span class="target" id="index-34"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a> 来编码。 可选的 <em>language</em> 指定了 RFC 2231 的语言，默认为空字符串。 <em>charset</em> 和 <em>language</em> 都应为字符串。</p>
<p>如果 <em>replace</em> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> （默认值），该头字段会被移动到所有头字段列表的末尾。如果 <em>replace</em> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，字段会被原地更新。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>添加了 <code class="docutils literal notranslate"><span class="pre">replace</span></code> 关键字。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.del_param">
<span class="sig-name descname"><span class="pre">del_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'content-type'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requote</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.del_param" title="永久链接至目标">¶</a></dt>
<dd><p>从 <em class="mailheader">Content-Type</em> 标头中完全移除给定的形参。 标头将被原地重写并不带该形参或它的值。  所有的值将根据需要被转换，除非 <em>requote</em> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> (默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>)。 可选的 <em>header</em> 指定 <em class="mailheader">Content-Type</em> 的一个替代项。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.set_type">
<span class="sig-name descname"><span class="pre">set_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Content-Type'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requote</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_type" title="永久链接至目标">¶</a></dt>
<dd><p>设置 <em class="mailheader">Content-Type</em> 标头的主类型和子类型。 <em>type</em> 必须为 <em class="mimetype">maintype/subtype</em> 形式的字符串，否则会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>此方法可替换 <em class="mailheader">Content-Type</em> 标头，并保持所有形参不变。 如果 <em>requote</em> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，这会保持原有标头引用转换不变，否则形参将被引用转换（默认行为）。</p>
<p>可以在 <em>header</em> 参数中指定一个替代标头。 当 <em class="mailheader">Content-Type</em> 标头被设置时也会添加一个 <em class="mailheader">MIME-Version</em> 标头。</p>
<p>这是一个过时的方法。 在 <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 类上它的功能已被 <code class="docutils literal notranslate"><span class="pre">make_</span></code> 和 <code class="docutils literal notranslate"><span class="pre">add_</span></code> 方法所替代。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_filename">
<span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_filename" title="永久链接至目标">¶</a></dt>
<dd><p>返回信息头当中 <em class="mailheader">Content-Disposition</em> 字段当中名为 <code class="docutils literal notranslate"><span class="pre">filename</span></code> 的参数值。如果该字段当中没有此参数，该方法会退而寻找 <em class="mailheader">Content-Type</em> 字段当中的 <code class="docutils literal notranslate"><span class="pre">name</span></code> 参数值。如果这个也没有找到，或者这些个字段压根就不存在，返回 <em>failobj</em> 。返回的字符串永远按照 <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a> 方法去除引号。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_boundary">
<span class="sig-name descname"><span class="pre">get_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_boundary" title="永久链接至目标">¶</a></dt>
<dd><p>返回信息头当中 <em class="mailheader">Content-Type</em> 字段当中名为 <code class="docutils literal notranslate"><span class="pre">boundary</span></code> 的参数值。如果字段当中没有此参数，或者这些个字段压根就不存在，返回 <em>failobj</em> 。返回的字符串永远按照 <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a> 方法去除引号。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.set_boundary">
<span class="sig-name descname"><span class="pre">set_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boundary</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_boundary" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em class="mailheader">Content-Type</em> 头字段的 <code class="docutils literal notranslate"><span class="pre">boundary</span></code> 参数设置为 <em>boundary</em> 。 <a class="reference internal" href="#email.message.Message.set_boundary" title="email.message.Message.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a> 方法永远都会在必要的时候为 <em>boundary</em> 添加引号。如果信息对象中没有 <em class="mailheader">Content-Type</em> 头字段，抛出 <a class="reference internal" href="email.errors.html#email.errors.HeaderParseError" title="email.errors.HeaderParseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HeaderParseError</span></code></a> 异常。</p>
<p>请注意使用这个方法与删除旧的 <em class="mailheader">Content-Type</em> 标头并通过 <a class="reference internal" href="#email.message.Message.add_header" title="email.message.Message.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a> 添加一个带有新边界的新标头有细微的差异，因为 <a class="reference internal" href="#email.message.Message.set_boundary" title="email.message.Message.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a> 会保留 <em class="mailheader">Content-Type</em> 标头在原标头列表中的顺序。 但是，它 <em>不会</em> 保留原 <em class="mailheader">Content-Type</em> 标头中可能存在的任何连续的行。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_content_charset">
<span class="sig-name descname"><span class="pre">get_content_charset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_charset" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em class="mailheader">Content-Type</em> 头字段中的 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 参数，强制小写。如果字段当中没有此参数，或者这个字段压根不存在，返回 <em>failobj</em> 。</p>
<p>请注意此方法不同于 <a class="reference internal" href="#email.message.Message.get_charset" title="email.message.Message.get_charset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_charset()</span></code></a>，后者会返回 <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> 实例作为消息体的默认编码格式。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_charsets">
<span class="sig-name descname"><span class="pre">get_charsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">failobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_charsets" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个包含了信息内所有字符集名字的列表。 如果信息是 <em class="mimetype">multipart</em> 类型的，那么列表当中的每一项都对应其载荷的子部分的字符集名字。 否则，该列表是一个长度为 1 的列表。</p>
<p>列表中的每一项都是字符串，它们是其所表示的子部分的 <em class="mailheader">Content-Type</em> 标头中 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 形参的值。 但是，如果该子部分没有 <em class="mailheader">Content-Type</em> 标头，或没有 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 形参，或者主 MIME 类型不是 <em class="mimetype">text</em>，则所返回列表中的对应项将为 <em>failobj</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.get_content_disposition">
<span class="sig-name descname"><span class="pre">get_content_disposition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_disposition" title="永久链接至目标">¶</a></dt>
<dd><p>如果信息的 <em class="mailheader">Content-Disposition</em> 头字段存在，返回其字段值；否则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。返回的值均为小写，不包含参数。如果信息遵循 <span class="target" id="index-35"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2183.html"><strong>RFC 2183</strong></a> 标准，则此方法的返回值只可能在 <em>inline</em> 、 <em>attachment</em> 和 <code class="docutils literal notranslate"><span class="pre">None</span></code> 之间选择。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.message.Message.walk">
<span class="sig-name descname"><span class="pre">walk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.walk" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#email.message.Message.walk" title="email.message.Message.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> 方法是一个多功能生成器。它可以被用来以深度优先顺序遍历信息对象树的所有部分和子部分。一般而言， <a class="reference internal" href="#email.message.Message.walk" title="email.message.Message.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> 会被用作 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环的迭代器，每一次迭代都返回其下一个子部分。</p>
<p>以下例子会打印出一封具有多部分结构之信息的每个部分的 MIME 类型。</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_type</span><span class="p">())</span>
<span class="go">multipart/report</span>
<span class="go">text/plain</span>
<span class="go">message/delivery-status</span>
<span class="go">text/plain</span>
<span class="go">text/plain</span>
<span class="go">message/rfc822</span>
<span class="go">text/plain</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">walk</span></code> 会遍历所有 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> 方法返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的部分之子部分，哪怕 <code class="docutils literal notranslate"><span class="pre">msg.get_content_maintype()</span> <span class="pre">==</span> <span class="pre">'multipart'</span></code> 返回的是 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。使用 <code class="docutils literal notranslate"><span class="pre">_structure</span></code> 除错帮助函数可以帮助我们在下面这个例子当中看清楚这一点：</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_maintype</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;multipart&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">part</span><span class="o">.</span><span class="n">is_multipart</span><span class="p">())</span>
<span class="go">True True</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_structure</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">multipart/report</span>
<span class="go">    text/plain</span>
<span class="go">    message/delivery-status</span>
<span class="go">        text/plain</span>
<span class="go">        text/plain</span>
<span class="go">    message/rfc822</span>
<span class="go">        text/plain</span>
</pre></div>
</div>
<p>在这里， <code class="docutils literal notranslate"><span class="pre">message</span></code> 的部分并非 <code class="docutils literal notranslate"><span class="pre">multiparts</span></code> ，但是它们真的包含子部分！ <code class="docutils literal notranslate"><span class="pre">is_multipart()</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> ， <code class="docutils literal notranslate"><span class="pre">walk</span></code> 也深入进这些子部分中。</p>
</dd></dl>

<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象也可以包含两个可选的实例属性，它们可被用于生成纯文本的 MIME 消息。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="email.message.Message.preamble">
<span class="sig-name descname"><span class="pre">preamble</span></span><a class="headerlink" href="#email.message.Message.preamble" title="永久链接至目标">¶</a></dt>
<dd><p>MIME 文档格式在标头之后的空白行以及第一个多部分的分界字符串之间允许添加一些文本， 通常，此文本在支持 MIME 的邮件阅读器中永远不可见，因为它处在标准 MIME 保护范围之外。 但是，当查看消息的原始文本，或当在不支持 MIME 的阅读器中查看消息时，此文本会变得可见。</p>
<p><em>preamble</em> 属性包含 MIME 文档开头部分的这些处于保护范围之外的文本。 当 <a class="reference internal" href="email.parser.html#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> 在标头之后及第一个分界字符串之前发现一些文本时，它会将这些文本赋值给消息的 <em>preamble</em> 属性。 当 <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 写出 MIME 消息的纯文本表示形式时，如果它发现消息具有 <em>preamble</em> 属性，它将在标头及第一个分界之间区域写出这些文本。 请参阅 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a> 和 <a class="reference internal" href="email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.generator</span></code></a> 了解更多细节。</p>
<p>请注意如果消息对象没有前导文本，则 <em>preamble</em> 属性将为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.message.Message.epilogue">
<span class="sig-name descname"><span class="pre">epilogue</span></span><a class="headerlink" href="#email.message.Message.epilogue" title="永久链接至目标">¶</a></dt>
<dd><p><em>epilogue</em> 属性的作用方式与 <em>preamble</em> 属性相同，区别在于它包含出现于最后一个分界与消息结尾之间的文本。</p>
<p>你不需要将 epilogue 设为空字符串以便让 <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 在文件末尾打印一个换行符。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.message.Message.defects">
<span class="sig-name descname"><span class="pre">defects</span></span><a class="headerlink" href="#email.message.Message.defects" title="永久链接至目标">¶</a></dt>
<dd><p><em>defects</em> 属性包含在解析消息时发现的所有问题的列表。 请参阅 <a class="reference internal" href="email.errors.html#module-email.errors" title="email.errors: The exception classes used by the email package."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code></a> 了解可能的解析缺陷的详细描述。</p>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="email.examples.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code>: 示例</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="email.mime.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime</span></code>: 从头创建电子邮件和 MIME 对象</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/email.compat32-message.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="email.mime.html" title="email.mime: 从头创建电子邮件和 MIME 对象"
             >下一页</a> |</li>
        <li class="right" >
          <a href="email.examples.html" title="email: 示例"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >互联网数据处理</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 电子邮件与 MIME 处理包</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message.Message</span></code>: 使用 <code class="xref py py-data docutils literal notranslate"><span class="pre">compat32</span></code> API 来表示电子邮件消息</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 11月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0创建。
    </div>

  </body>
</html>