
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>urllib.request --- 用于打开 URL 的可扩展库 &#8212; Python 3.11.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="urllib.parse 用于解析 URL" href="urllib.parse.html" />
    <link rel="prev" title="urllib --- URL 处理模块" href="urllib.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/urllib.request.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> --- 用于打开 URL 的可扩展库</a><ul>
<li><a class="reference internal" href="#request-objects">Request 对象</a></li>
<li><a class="reference internal" href="#openerdirector-objects">OpenerDirector 对象</a></li>
<li><a class="reference internal" href="#basehandler-objects">BaseHandler 对象</a></li>
<li><a class="reference internal" href="#httpredirecthandler-objects">HTTPRedirectHandler 对象</a></li>
<li><a class="reference internal" href="#httpcookieprocessor-objects">HTTPCookieProcessor 对象</a></li>
<li><a class="reference internal" href="#proxyhandler-objects">ProxyHandler 对象</a></li>
<li><a class="reference internal" href="#httppasswordmgr-objects">HTTPPasswordMgr 对象</a></li>
<li><a class="reference internal" href="#httppasswordmgrwithpriorauth-objects">HTTPPasswordMgrWithPriorAuth 对象</a></li>
<li><a class="reference internal" href="#abstractbasicauthhandler-objects">AbstractBasicAuthHandler 对象</a></li>
<li><a class="reference internal" href="#httpbasicauthhandler-objects">HTTPBasicAuthHandler 对象</a></li>
<li><a class="reference internal" href="#proxybasicauthhandler-objects">ProxyBasicAuthHandler 对象</a></li>
<li><a class="reference internal" href="#abstractdigestauthhandler-objects">AbstractDigestAuthHandler 对象</a></li>
<li><a class="reference internal" href="#httpdigestauthhandler-objects">HTTPDigestAuthHandler 对象</a></li>
<li><a class="reference internal" href="#proxydigestauthhandler-objects">ProxyDigestAuthHandler 对象</a></li>
<li><a class="reference internal" href="#httphandler-objects">HTTPHandler 对象</a></li>
<li><a class="reference internal" href="#httpshandler-objects">HTTPSHandler 对象</a></li>
<li><a class="reference internal" href="#filehandler-objects">FileHandler 对象</a></li>
<li><a class="reference internal" href="#datahandler-objects">DataHandler 对象</a></li>
<li><a class="reference internal" href="#ftphandler-objects">FTPHandler 对象</a></li>
<li><a class="reference internal" href="#cacheftphandler-objects">CacheFTPHandler 对象</a></li>
<li><a class="reference internal" href="#unknownhandler-objects">UnknownHandler 对象</a></li>
<li><a class="reference internal" href="#httperrorprocessor-objects">HTTPErrorProcessor 对象</a></li>
<li><a class="reference internal" href="#examples">例子</a></li>
<li><a class="reference internal" href="#legacy-interface">已停用的接口</a></li>
<li><a class="reference internal" href="#urllib-request-restrictions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> 的限制</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-urllib.response"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code> --- urllib 使用的 Response 类</a></li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="urllib.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code> --- URL 处理模块</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="urllib.parse.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code>  用于解析 URL</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/urllib.request.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse 用于解析 URL"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib --- URL 处理模块"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">互联网协议和支持</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> --- 用于打开 URL 的可扩展库</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-urllib.request">
<span id="urllib-request-extensible-library-for-opening-urls"></span><h1><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> --- 用于打开 URL 的可扩展库<a class="headerlink" href="#module-urllib.request" title="永久链接至标题">¶</a></h1>
<p><strong>源码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/urllib/request.py">Lib/urllib/request.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 模块定义了适用于在各种复杂情况下打开 URL（主要为 HTTP）的函数和类 --- 例如基本认证、摘要认证、重定向、cookies 及其它。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>对于更高级别的 HTTP 客户端接口，建议使用 <a class="reference external" href="https://requests.readthedocs.io/en/master/">Requests</a>  。</p>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not Emscripten, not WASI.<p>This module does not work or is not available on WebAssembly platforms
<code class="docutils literal notranslate"><span class="pre">wasm32-emscripten</span></code> and <code class="docutils literal notranslate"><span class="pre">wasm32-wasi</span></code>. See
<a class="reference internal" href="intro.html#wasm-availability"><span class="std std-ref">WebAssembly platforms</span></a> for more information.</p>
</p>
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 模块定义了以下函数：</p>
<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.urlopen">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">urlopen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data=None</span></span></em>, <span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cafile=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capath=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cadefault=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlopen" title="永久链接至目标">¶</a></dt>
<dd><p>打开统一资源定位符 <em>url</em>，可以是一个字符串或一个 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 对象。</p>
<p><em>data</em> 必须是一个对象，用于给出要发送到服务器的附加数据，若不需要发送数据则为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。详情请参阅 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 。</p>
<p>urllib.request 模块采用 HTTP/1.1 协议，并且在其 HTTP 请求中包含 <code class="docutils literal notranslate"><span class="pre">Connection:close</span></code> 头部信息。</p>
<p><em>timeout</em> 为可选参数，用于指定阻塞操作（如连接尝试）的超时时间，单位为秒。如未指定，将使用全局默认超时参数）。本参数实际仅对 HTTP、HTTPS 和 FTP 连接有效。</p>
<p>如果给定了 <em>context</em> 参数，则必须是一个 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 实例，用于描述各种 SSL 参数。更多详情请参阅 <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a> 。</p>
<p><em>cafile</em> 和 <em>capath</em> 为可选参数，用于为 HTTPS 请求指定一组受信 CA 证书。<em>cafile</em> 应指向包含CA 证书的单个文件， <em>capath</em> 则应指向哈希证书文件的目录。更多信息可参阅 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_verify_locations()</span></code></a> 。</p>
<p>参数 <em>cadefault</em> 将被忽略。</p>
<p>本函数总会返回一个对象，该对象可作为 <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> 使用，带有 <em>url</em>、<em>headers</em> 和 <em>status</em> 属性。有关这些属性的更多详细信息，请参阅 <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a> 。</p>
<p>对于 HTTP 和 HTTPS 的 URL 而言，本函数将返回一个稍经修改的 <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPResponse</span></code></a> 对象。除了上述 3 个新的方法之外，还有 msg 属性包含了与 <a class="reference internal" href="http.client.html#http.client.HTTPResponse.reason" title="http.client.HTTPResponse.reason"><code class="xref py py-attr docutils literal notranslate"><span class="pre">reason</span></code></a> 属性相同的信息---服务器返回的原因描述文字，而不是  <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a> 的文档所述的响应头部信息。</p>
<p>对于 FTP、文件、数据的URL，以及由传统的 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a>  和 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 类处理的请求，本函数将返回一个 <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a> 对象。</p>
<p>协议发生错误时，将会引发 <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> 。</p>
<p>请注意，如果没有处理函数对请求进行处理，则有可能会返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>  。尽管默认安装的全局 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 会用 <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a> 来确保不会发生这种情况。</p>
<p>此外，如果检测到设置了代理（比如设置了 <span class="target" id="index-25"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code> 之类的环境变量），默认会安装 <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> 并确保通过代理处理请求。</p>
<p>Python 2.6 以下版本中留存的 <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code> 函数已停止使用了； <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.request.urlopen()</span></code></a> 对应于传统的 <code class="docutils literal notranslate"><span class="pre">urllib2.urlopen</span></code> 。对代理服务的处理是通过将字典参数传给 <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code> 来完成的，可以用 <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> 对象获取到代理处理函数。</p>
<p class="audit-hook">默认会触发一条 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">urllib.Request</span></code> ，参数 <code class="docutils literal notranslate"><span class="pre">fullurl</span></code> 、 <code class="docutils literal notranslate"><span class="pre">data</span></code> 、<code class="docutils literal notranslate"><span class="pre">headers</span></code> 、<code class="docutils literal notranslate"><span class="pre">method</span></code> 均取自请求对象。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>增加了 <em>cafile</em> 与 <em>capath</em>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>只要条件允许（指 <a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">ssl.HAS_SNI</span></code></a> 为真），现在能够支持 HTTPS 虚拟主机。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能: </span><em>data</em> 可以是一个可迭代对象。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>cadefault</em>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4.3 版更改: </span>增加了 <em>context</em>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span>当未给出 <em>context</em> 时，HTTPS 连接现在会发送一个带有协议指示器 <code class="docutils literal notranslate"><span class="pre">http/1.1</span></code> 的 ALPN 扩展。 自定义 <em>context</em> 应当用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_alpn_protocol()</span></code> 来设置 ALPN 协议。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.6 版后已移除: </span><em>cafile</em> 、 <em>capath</em> 和 <em>cadefault</em> 已废弃，转而推荐使用 <em>context</em>。请改用 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a> 或让 <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> 选取系统信任的 CA 证书。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.install_opener">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">install_opener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opener</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.install_opener" title="永久链接至目标">¶</a></dt>
<dd><p>安装一个 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 实例，作为默认的全局打开函数。仅当 urlopen 用到该打开函数时才需要安装；否则，只需调用 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a> 而不是 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>。代码不会检查是否真的属于 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 类，所有具备适当接口的类都能适用。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.build_opener">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">build_opener</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.build_opener" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 实例，以给定顺序把处理函数串联起来。处理函数可以是 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 的实例，也可以是 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 的子类（这时构造函数必须允许不带任何参数的调用）。以下类的实例将位于 <em>处理函数</em> 之前，除非 <em>处理函数</em> 已包含这些类、其实例或其子类： <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> （如果检测到代理设置）、<a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a> 、<a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a> 、<a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a> 、<a class="reference internal" href="#urllib.request.HTTPRedirectHandler" title="urllib.request.HTTPRedirectHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPRedirectHandler</span></code></a> 、 <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a> 、 <a class="reference internal" href="#urllib.request.FileHandler" title="urllib.request.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> 、<a class="reference internal" href="#urllib.request.HTTPErrorProcessor" title="urllib.request.HTTPErrorProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPErrorProcessor</span></code></a> 。</p>
<p>若 Python 安装时已带了 SSL 支持（指可以导入 <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 模块），则还会加入 <a class="reference internal" href="#urllib.request.HTTPSHandler" title="urllib.request.HTTPSHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSHandler</span></code></a> 。</p>
<p>A <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> subclass may also change its <code class="xref py py-attr docutils literal notranslate"><span class="pre">handler_order</span></code>
attribute to modify its position in the handlers list.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.pathname2url">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">pathname2url</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.pathname2url" title="永久链接至目标">¶</a></dt>
<dd><p>将路径名 <em>path</em> 从路径本地写法转换为 URL 路径部分所采用的格式。本函数不会生成完整的 URL。返回值将会用 <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a> 函数加以编码。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.url2pathname">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">url2pathname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.url2pathname" title="永久链接至目标">¶</a></dt>
<dd><p>从百分号编码的 URL 中将 <em>path</em> 部分转换为本地路径的写法。本函数不接受完整的 URL，并利用 <a class="reference internal" href="urllib.parse.html#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">unquote()</span></code></a> 函数对 <em>path</em> 进行解码。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.getproxies">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">getproxies</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.getproxies" title="永久链接至目标">¶</a></dt>
<dd><p>此辅助函数将返回一个将各个方案映射到代理服务器 URL 的字典。 它会先为所有操作系统以大小写不敏感的方式扫描名为 <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code> 的环境变量，当无法找到时，则会在 macOS 上从系统配置中而在 Windows 上从 Windows 系统注册表中查找代理信息。 如果同时存在小写和大写形式的环境变量（且内容不一致），则会首先小写形式。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果存在环境变量 <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code> ，通常表示脚本运行于 CGI 环境中，则环境变量 <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code> （大写的 <code class="docutils literal notranslate"><span class="pre">_PROXY</span></code>）将会被忽略。这是因其可以由客户端用 HTTP 头部信息 “Proxy:”注入。若要在 CGI 环境中使用 HTTP 代理，请显式使用 <code class="docutils literal notranslate"><span class="pre">`ProxyHandler</span></code> ，或确保变量名称为小写（或至少是 <code class="docutils literal notranslate"><span class="pre">_proxy</span></code> 后缀）。</p>
</div>
</dd></dl>

<p>提供了以下类：</p>
<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.Request">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">Request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">headers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin_req_host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unverifiable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request" title="永久链接至目标">¶</a></dt>
<dd><p>URL 请求对象的抽象类。</p>
<p><em>url</em> 应为包含合法 URL 的字符串。</p>
<p><em>data</em> 必须是一个对象，用于给定发往服务器的附加数据，若无需此类数据则为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。 目前 唯一用到 <em>data</em> 的只有 HTTP 请求。支持的对象类型包括字节串、类文件对象和可遍历的类字节串对象。如果没有提供 <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> 和  <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding</span></code> 头部字段， <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a> 会根据 <em>data</em> 的类型设置这些头部字段。<code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> 将用于发送字节对象，而 <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7230.html"><strong>RFC 7230</strong></a> 第 3.3.1 节中定义的 <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding:</span> <span class="pre">chunked</span></code> 将用于发送文件和其他可遍历对象。</p>
<p>对于 HTTP POST 请求方法而言，<em>data</em> 应该是标准 <em class="mimetype">application/x-www-form-urlencoded</em> 格式的缓冲区。 <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 函数的参数为映射对象或二元组序列，并返回一个该编码格式的 ASCII 字符串。在用作 <em>data</em> 参数之前，应将其编码为字节串。</p>
<p><em>headers</em> 应当是一个字典，并将被视同附带了每个键和值作为参数去调用 <a class="reference internal" href="#urllib.request.Request.add_header" title="urllib.request.Request.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a>。 这通常被用于 &quot;伪装&quot; <code class="docutils literal notranslate"><span class="pre">User-Agent</span></code> 标头值，浏览器会使用标头值来标识自己 -- 某些 HTTP 服务器只允许来自普通浏览器的请求而不允许来自脚本的请求。 例如，Mozilla Firefox 可能将自己标识为 <code class="docutils literal notranslate"><span class="pre">&quot;Mozilla/5.0</span> <span class="pre">(X11;</span> <span class="pre">U;</span> <span class="pre">Linux</span> <span class="pre">i686)</span> <span class="pre">Gecko/20071127</span> <span class="pre">Firefox/2.0.0.11&quot;</span></code>，而 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> 的默认用户代理字符串则是 <code class="docutils literal notranslate"><span class="pre">&quot;Python-urllib/2.6&quot;</span></code> (在 Python 2.6 中)。 所有发送的标头键都使用驼峰命名法。</p>
<p>如果给出了 <em>data</em> 参数，则应当包含合适的 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 头部信息。若未提供且 <em>data</em> 不是 None，则会把 <code class="docutils literal notranslate"><span class="pre">Content-Type:</span> <span class="pre">application/x-www-form-urlencoded</span></code> 加入作为默认值。</p>
<p>接下来的两个参数，只对第三方 HTTP cookie 的处理才有用：</p>
<p><em>origin_req_host</em> 应为发起初始会话的请求主机，定义参见 <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2965.html"><strong>RFC 2965</strong></a> 。默认指为``http.cookiejar.request_host(self)`` 。这是用户发起初始请求的主机名或 IP 地址。假设请求是针对 HTML 文档中的图片数据发起的，则本属性应为对包含图像的页面发起请求的主机。</p>
<p><em>unverifiable</em> 应该标示出请求是否无法验证，定义参见 <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2965.html"><strong>RFC 2965</strong></a> 。默认值为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。所谓无法验证的请求，是指用户没有机会对请求的 URL 做验证。例如，如果请求是针对 HTML 文档中的图像，用户没有机会去许可能自动读取图像，则本参数应为 True。</p>
<p><em>method</em> 应为字符串，标示要采用的 HTTP 请求方法（例如 <code class="docutils literal notranslate"><span class="pre">'HEAD'</span></code> ）。如果给出本参数，其值会存储在 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> 属性中，并由 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a> 使用。如果 <em>data</em> 为``None`` 则默认值为 <code class="docutils literal notranslate"><span class="pre">'GET'</span></code> ，否则为 <code class="docutils literal notranslate"><span class="pre">'POST'</span></code>。子类可以设置 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> 属性来标示不同的默认请求方法。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果 data 对象无法分多次传递其内容（比如文件或只能生成一次内容的可迭代对象）并且由于 HTTP 重定向或身份验证而发生请求重试行为，则该请求不会正常工作。 <em>data</em> 是紧挨着头部信息发送给 HTTP 服务器的。现有库不支持 HTTP 100-continue 的征询。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>Request 类增加了 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>默认 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> 可以在类中标明。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>如果给出了 <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> ，且 <em>data</em> 既不为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 也不是字节串对象，则不会触发错误。而会退而求其次采用分块传输的编码格式。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.OpenerDirector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">OpenerDirector</span></span><a class="headerlink" href="#urllib.request.OpenerDirector" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 类通过串接在一起的 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 打开 URL，并负责管理 handler 链及从错误中恢复。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.BaseHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">BaseHandler</span></span><a class="headerlink" href="#urllib.request.BaseHandler" title="永久链接至目标">¶</a></dt>
<dd><p>这是所有已注册 handler 的基类，只做了简单的注册机制。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPDefaultErrorHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPDefaultErrorHandler</span></span><a class="headerlink" href="#urllib.request.HTTPDefaultErrorHandler" title="永久链接至目标">¶</a></dt>
<dd><p>为 HTTP 错误响应定义的默认 handler，所有出错响应都会转为 <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 异常。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPRedirectHandler</span></span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler" title="永久链接至目标">¶</a></dt>
<dd><p>一个用于处理重定向的类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPCookieProcessor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPCookieProcessor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cookiejar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPCookieProcessor" title="永久链接至目标">¶</a></dt>
<dd><p>一个用于处理 HTTP Cookies 的类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.ProxyHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">ProxyHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proxies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyHandler" title="永久链接至目标">¶</a></dt>
<dd><p>让请求转往代理服务。 如果给出了 <em>proxies</em>，则它必须是一个将协议名称映射到代理 URL 的字典。 默认是从环境变量 <code class="docutils literal notranslate"><span class="pre">&lt;protocol&gt;_proxy</span></code> 中读取代理列表。 如果没有设置代理服务的环境变量，则在 Windows 环境下代理设置会从注册表的 Internet Settings 部分获取，而在 macOS 环境下代理信息会从 System Configuration Framework 获取。</p>
<p>若要禁用自动检测出来的代理，请传入空的字典对象。</p>
<p>环境变量 <span class="target" id="index-29"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">no_proxy</span></code> 可用于指定不必通过代理访问的主机；应为逗号分隔的主机名后缀列表，可加上 <code class="docutils literal notranslate"><span class="pre">:port</span></code> ，例如 <code class="docutils literal notranslate"><span class="pre">cern.ch,ncsa.uiuc.edu,some.host:8080</span></code> 。</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果设置了 <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code> 变量，则会忽略 <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code> ；参阅 <a class="reference internal" href="#urllib.request.getproxies" title="urllib.request.getproxies"><code class="xref py py-func docutils literal notranslate"><span class="pre">getproxies()</span></code></a> 文档。</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPPasswordMgr</span></span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr" title="永久链接至目标">¶</a></dt>
<dd><p>维护 <code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code> 映射数据库。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithDefaultRealm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="永久链接至目标">¶</a></dt>
<dd><p>维护 <code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code> 映射数据库。realm 为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 视作全匹配，若没有其他合适的安全区域就会检索它。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithPriorAuth">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPPasswordMgrWithPriorAuth</span></span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 的一个变体，也带有 <code class="docutils literal notranslate"><span class="pre">uri</span> <span class="pre">-&gt;</span> <span class="pre">is_authenticated</span></code> 映射数据库。可被 BasicAuth 处理函数用于确定立即发送身份认证凭据的时机，而不是先等待 <code class="docutils literal notranslate"><span class="pre">401</span></code> 响应。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.AbstractBasicAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">AbstractBasicAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler" title="永久链接至目标">¶</a></dt>
<dd><p>这是一个帮助完成 HTTP 身份认证的混合类，对远程主机和代理都适用。参数 <em>password_mgr</em> 应与 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 兼容；关于必须支持哪些接口，请参阅 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 对象</span></a> 对象的章节。如果 <em>password_mgr</em> 还提供 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 和 <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code> 方法（请参阅 <a class="reference internal" href="#http-password-mgr-with-prior-auth"><span class="std std-ref">HTTPPasswordMgrWithPriorAuth 对象</span></a> 对象），则 handler 将对给定 URI 用到 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 的结果，来确定是否随请求发送身份认证凭据。如果该 URI 的 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>  返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则发送凭据。如果 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> ，则不发送凭据，然后若收到 <code class="docutils literal notranslate"><span class="pre">401</span></code> 响应，则使用身份认证凭据重新发送请求。如果身份认证成功，则调用 <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code> 设置该 URI 的 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，这样后续对该 URI 或其所有父 URI 的请求将自动包含该身份认证凭据。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能: </span>增加了对 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 的支持。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPBasicAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPBasicAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler" title="永久链接至目标">¶</a></dt>
<dd><p>处理远程主机的身份认证。 <em>password_mgr</em> 应与 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 兼容；有关哪些接口是必须支持的，请参阅 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 对象</span></a> 章节。如果给出错误的身份认证方式， HTTPBasicAuthHandler 将会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.ProxyBasicAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">ProxyBasicAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler" title="永久链接至目标">¶</a></dt>
<dd><p>处理有代理服务时的身份认证。 <em>password_mgr</em> 应与 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 兼容；有关哪些接口是必须支持的，请参阅 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 对象</span></a> 章节。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.AbstractDigestAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">AbstractDigestAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler" title="永久链接至目标">¶</a></dt>
<dd><p>这是一个帮助完成 HTTP 身份认证的混合类，对远程主机和代理都适用。参数 <em>password_mgr</em> 应与 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 兼容；关于必须支持哪些接口，请参阅 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 对象</span></a> 的章节。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPDigestAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPDigestAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler" title="永久链接至目标">¶</a></dt>
<dd><p>处理远程主机的身份认证。 <em>password_mgr</em> 应与 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 兼容；有关哪些接口是必须支持的，请参阅 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 对象</span></a> 章节。如果同时添加了 digest 身份认证 handler 和basic 身份认证 handler，则会首先尝试 digest 身份认证。如果 digest 身份认证再返回 40x 响应，会再发送到 basic 身份验证 handler 进行处理。如果给出 Digest 和 Basic 之外的身份认证方式， 本 handler 方法将会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>碰到不支持的认证方式时，将会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.ProxyDigestAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">ProxyDigestAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler" title="永久链接至目标">¶</a></dt>
<dd><p>处理有代理服务时的身份认证。 <em>password_mgr</em> 应与 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 兼容；有关哪些接口是必须支持的，请参阅 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 对象</span></a> 章节。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPHandler</span></span><a class="headerlink" href="#urllib.request.HTTPHandler" title="永久链接至目标">¶</a></dt>
<dd><p>用于打开 HTTP URL 的 handler 类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPSHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPSHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">debuglevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler" title="永久链接至目标">¶</a></dt>
<dd><p>用于打开 HTTPS URL 的 handler 类。<em>context</em> 和 <em>check_hostname</em> 的含义与  <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPSConnection</span></code></a> 的一样。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>添加 <em>context</em> 和 <em>check_hostname</em> 参数。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.FileHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">FileHandler</span></span><a class="headerlink" href="#urllib.request.FileHandler" title="永久链接至目标">¶</a></dt>
<dd><p>打开本地文件。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.DataHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">DataHandler</span></span><a class="headerlink" href="#urllib.request.DataHandler" title="永久链接至目标">¶</a></dt>
<dd><p>打开数据 URL。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.FTPHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">FTPHandler</span></span><a class="headerlink" href="#urllib.request.FTPHandler" title="永久链接至目标">¶</a></dt>
<dd><p>打开 FTP URL。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.CacheFTPHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">CacheFTPHandler</span></span><a class="headerlink" href="#urllib.request.CacheFTPHandler" title="永久链接至目标">¶</a></dt>
<dd><p>打开 FTP URL，并将打开的 FTP 连接存入缓存，以便最大程度减少延迟。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.UnknownHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">UnknownHandler</span></span><a class="headerlink" href="#urllib.request.UnknownHandler" title="永久链接至目标">¶</a></dt>
<dd><p>处理所有未知类型 URL 的兜底类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPErrorProcessor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPErrorProcessor</span></span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor" title="永久链接至目标">¶</a></dt>
<dd><p>处理出错的 HTTP 响应。</p>
</dd></dl>

<section id="request-objects">
<span id="id1"></span><h2>Request 对象<a class="headerlink" href="#request-objects" title="永久链接至标题">¶</a></h2>
<p>以下方法介绍了 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 的公开接口，因此子类可以覆盖所有这些方法。这里还定义了几个公开属性，客户端可以利用这些属性了解经过解析的请求。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.full_url">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">full_url</span></span><a class="headerlink" href="#urllib.request.Request.full_url" title="永久链接至目标">¶</a></dt>
<dd><p>传给构造函数的原始 URL。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改.</span></p>
</div>
<p>Request.full_url 是一个带有 setter、getter 和 deleter 的属性。读取 <a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">full_url</span></code></a> 属性将会返回附带片段（fragment）的初始请求 URL。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.type">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#urllib.request.Request.type" title="永久链接至目标">¶</a></dt>
<dd><p>URI 方式。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.host">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">host</span></span><a class="headerlink" href="#urllib.request.Request.host" title="永久链接至目标">¶</a></dt>
<dd><p>URI 权限，通常是整个主机，但也有可能带有冒号分隔的端口号。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.origin_req_host">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">origin_req_host</span></span><a class="headerlink" href="#urllib.request.Request.origin_req_host" title="永久链接至目标">¶</a></dt>
<dd><p>请求的原始主机，不含端口。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.selector">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">selector</span></span><a class="headerlink" href="#urllib.request.Request.selector" title="永久链接至目标">¶</a></dt>
<dd><p>URI 路径。若 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 使用代理，selector 将会是传给代理的完整 URL。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.data">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">data</span></span><a class="headerlink" href="#urllib.request.Request.data" title="永久链接至目标">¶</a></dt>
<dd><p>请求的数据体，未给出则为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>现在如果修改 <a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a> 的值，则会删除之前设置或计算过的“Content-Length”头部信息。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.unverifiable">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">unverifiable</span></span><a class="headerlink" href="#urllib.request.Request.unverifiable" title="永久链接至目标">¶</a></dt>
<dd><p>布尔值，标识本请求是否属于 <span class="target" id="index-30"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2965.html"><strong>RFC 2965</strong></a> 中定义的无法验证的情况。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.method">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">method</span></span><a class="headerlink" href="#urllib.request.Request.method" title="永久链接至目标">¶</a></dt>
<dd><p>要采用的 HTTP 请求方法。默认为 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>，表示 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a> 将对方法进行正常处理。设置本值可以覆盖 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a> 中的默认处理过程，设置方式可以是在 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 的子类中给出默认值，也可以通过 <em>method</em> 参数给 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 构造函数传入一个值。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>现在可以在子类中设置默认值；而之前只能通过构造函数的实参进行设置。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.get_method">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">get_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_method" title="永久链接至目标">¶</a></dt>
<dd><p>返回表示 HTTP  请求方法的字符串。如果 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> 不为  <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则返回其值。否则若  <a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a> 为  则返回 <code class="docutils literal notranslate"><span class="pre">'GET'</span></code>，不为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 则返回 <code class="docutils literal notranslate"><span class="pre">'POST'</span></code> 。只对 HTTP 请求有效。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>现在 get_method 会兼顾 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> 的值。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.add_header">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">add_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_header" title="永久链接至目标">¶</a></dt>
<dd><p>向请求添加一个标头。 标头目前会被所有处理句柄忽略但只有 HTTP 处理句柄是例外，该处理句柄会将它们加入发给服务器的标头列表中。 请注意同名的标头只能有一个，当 <em>key</em> 发生冲突时后续的调用将会覆盖之前的调用。 目前，这并不会造成 HTTP 功能的损失，因为所有可多次使用而仍有意义的标头都有（特定标头专属的）方式来获得与仅使用一个标头时相同的功能。 请注意使用此方法添加的标头也会被添加到重定向的请求中。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.add_unredirected_header">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">add_unredirected_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_unredirected_header" title="永久链接至目标">¶</a></dt>
<dd><p>添加一项不会被加入重定向请求的头部信息。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.has_header">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">has_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">header</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.has_header" title="永久链接至目标">¶</a></dt>
<dd><p>返回本实例是否带有命名头部信息（对常规数据和非重定向数据都会检测）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.remove_header">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">remove_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">header</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.remove_header" title="永久链接至目标">¶</a></dt>
<dd><p>从本请求实例中移除指定命名的头部信息（对常规数据和非重定向数据都会检测）。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.get_full_url">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">get_full_url</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_full_url" title="永久链接至目标">¶</a></dt>
<dd><p>返回构造器中给定的 URL。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改.</span></p>
</div>
<p>返回 <a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.full_url</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.set_proxy">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">set_proxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.set_proxy" title="永久链接至目标">¶</a></dt>
<dd><p>连接代理服务器，为当前请求做准备。 <em>host</em> 和 <em>type</em> 将会取代本实例中的对应值，selector 将会是构造函数中给出的初始 URL。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.get_header">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">get_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">header_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_header" title="永久链接至目标">¶</a></dt>
<dd><p>返回给定头部信息的数据。如果该头部信息不存在，返回默认值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.header_items">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">header_items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.header_items" title="永久链接至目标">¶</a></dt>
<dd><p>返回头部信息，形式为（名称, 数据）的元组列表。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>自 3.3 起已弃用的下列方法已被删除：add_data、has_data、get_data、get_type、get_host、get_selector、get_origin_req_host 和 is_unverifiable 。</p>
</div>
</section>
<section id="openerdirector-objects">
<span id="opener-director-objects"></span><h2>OpenerDirector 对象<a class="headerlink" href="#openerdirector-objects" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 实例有以下方法：</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.OpenerDirector.add_handler">
<span class="sig-prename descclassname"><span class="pre">OpenerDirector.</span></span><span class="sig-name descname"><span class="pre">add_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.add_handler" title="永久链接至目标">¶</a></dt>
<dd><p><em>handler</em> 应为 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 的实例。将检索以下类型的方法，并将其添加到对应的处理链中（注意 HTTP 错误是特殊情况）。请注意，下文中的 <em>protocol</em> 应替换为要处理的实际协议，例如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code> 将是 HTTP 协议响应处理函数。并且 <em>type</em> 也应替换为实际的 HTTP 代码，例如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_404()</span></code> 将处理 HTTP 404 错误。</p>
<ul>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> — 表明该  handler 知道如何打开 <em>protocol</em> 协议的URL。</p>
<p>更多信息请参阅 <a class="reference internal" href="#protocol-open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_open()</span></code></a> 。</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> — 表明该  handler 知道如何处理代码为 <em>type</em> 的 HTTP 错误。</p>
<p>更多信息请参阅 <a class="reference internal" href="#http-error-nnn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.http_error_&lt;nnn&gt;()</span></code></a> 。</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_error()</span></code> — 表明该 handler 知道如何处理来自协议为 <em>protocol</em> （非<code class="docutils literal notranslate"><span class="pre">http</span></code>）的错误。</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> — 表明该 handler 知道如何预处理协议为 <em>protocol</em> 的请求。</p>
<p>更多信息请参阅 <a class="reference internal" href="#protocol-request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_request()</span></code></a> 。</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> — 表明该 handler 知道如何后处理协议为 <em>protocol</em> 的响应。</p>
<p>更多信息请参阅 <a class="reference internal" href="#protocol-response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_response()</span></code></a> 。</p>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.OpenerDirector.open">
<span class="sig-prename descclassname"><span class="pre">OpenerDirector.</span></span><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.open" title="永久链接至目标">¶</a></dt>
<dd><p>打开给定的 <em>url</em> (可以是一个请求对象或一个字符串），可以选择传入给定的 <em>data</em>。 参数、返回值和被引发的异常均与 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 的相同 (它只是简单地在当前安装的全局 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 上调用 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> 方法)。 可选的 <em>timeout</em> 形参指定了针对阻塞操作例如连接尝试的超时值 (如果未指明，则将使用全局默认的超时设置)。 超时特性仅适用于 HTTP, HTTPS 和 FTP 连接。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.OpenerDirector.error">
<span class="sig-prename descclassname"><span class="pre">OpenerDirector.</span></span><span class="sig-name descname"><span class="pre">error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proto</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.error" title="永久链接至目标">¶</a></dt>
<dd><p>处理给定协议的错误。将用给定的参数（协议相关）调用已注册的给定协议的错误处理程序。HTTP 协议是特殊情况，采用 HTTP 响应码来确定具体的错误处理程序；请参考 handler 类的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> 方法。</p>
<p>返回值和异常均与 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 相同。</p>
</dd></dl>

<p>OpenerDirector 对象分 3 个阶段打开 URL：</p>
<p>每个阶段中调用这些方法的次序取决于 handler 实例的顺序。</p>
<ol class="arabic">
<li><p>每个具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_request()</span></code> 这类方法的 handler 都会调用本方法对请求进行预处理。</p></li>
<li><p>调用具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_open()</span></code> 这类方法的 handler 来处理请求。当 handler 返回非<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 值（即响应）或引发异常（通常是 <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>）时，本阶段结束。本阶段能够传播异常。</p>
<p>事实上，以上算法首先会尝试名为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code> 的方法。 如果这些方法全都返回 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>，则会对名为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> 的方法重复此算法。 如果这些方法也全都返回 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>，则会继续对名为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">unknown_open()</span></code> 的方法重复此算法。</p>
<p>请注意，这些方法的代码可能会调用 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 父实例的 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> 和 <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a> 方法。</p>
</li>
<li><p>每个具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_response()</span></code> 这类方法的 handler 都会调用这些方法，以对响应进行后处理。</p></li>
</ol>
</section>
<section id="basehandler-objects">
<span id="base-handler-objects"></span><h2>BaseHandler 对象<a class="headerlink" href="#basehandler-objects" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 对象提供了一些直接可用的方法，以及其他一些可供派生类使用的方法。以下是可供直接使用的方法：</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.add_parent">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">add_parent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">director</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.add_parent" title="永久链接至目标">¶</a></dt>
<dd><p>将 director 加为父 OpenerDirector。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.close">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.close" title="永久链接至目标">¶</a></dt>
<dd><p>移除所有父 OpenerDirector。</p>
</dd></dl>

<p>以下属性和方法仅供 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 的子类使用：</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>以下约定已被采纳：定义 <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> 方法的子类应命名为 <code class="xref py py-class docutils literal notranslate"><span class="pre">*Processor</span></code>；所有其他子类都应命名为 <code class="xref py py-class docutils literal notranslate"><span class="pre">*Handler</span></code> 。</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.parent">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">parent</span></span><a class="headerlink" href="#urllib.request.BaseHandler.parent" title="永久链接至目标">¶</a></dt>
<dd><p>一个可用的 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>，可用于以其他协议打开 URI，或处理错误。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.default_open">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">default_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.default_open" title="永久链接至目标">¶</a></dt>
<dd><p>本方法在 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 中 <em>未</em> 予定义，但其子类若要捕获所有 URL 则应进行定义。</p>
<p>如果实现了本方法，则它将被父类 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 所调用。 它应当返回一个如 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 的 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> 方法的返回值所描述的文件类对象，或是返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 它应当引发 <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>，除非发生真正的异常 (例如，<a class="reference internal" href="exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> 就不应被映射为 <code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code>)。</p>
<p>本方法将会在所有协议的 open 方法之前被调用。</p>
</dd></dl>

<span class="target" id="protocol-open"></span><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BaseHandler.&lt;protocol&gt;_open(req)</span></span></dt>
<dd><p>本方法在 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 中 <em>未</em> 予定义，但其子类若要处理给定协议的 URL 则应进行定义。</p>
<p>若定义了本方法，将会被父 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 对象调用。返回值和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code> 的一样。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.unknown_open">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">unknown_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.unknown_open" title="永久链接至目标">¶</a></dt>
<dd><p>本方法在 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 中 <em>未</em> 予定义，但其子类若要捕获并打开所有未注册 handler 的 URL，则应进行定义。</p>
<p>若实现了本方法，将会被 <a class="reference internal" href="#urllib.request.BaseHandler.parent" title="urllib.request.BaseHandler.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parent</span></code></a> 属性指向的父 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 调用。返回值和 <a class="reference internal" href="#urllib.request.BaseHandler.default_open" title="urllib.request.BaseHandler.default_open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code></a> 的一样。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.http_error_default">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_default</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.http_error_default" title="永久链接至目标">¶</a></dt>
<dd><p>本方法在 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 中 <em>未</em> 予定义，但其子类若要为所有未定义 handler 的 HTTP 错误提供一个兜底方法，则应进行重写。<a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 会自动调用本方法，获取错误信息，而通常在其他时候不应去调用。</p>
<p><em>req</em> 会是一个 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 对象，<em>fp</em> 是一个带有 HTTP 错误体的文件类对象，<em>code</em> 是三位数的错误码，<em>msg</em> 是供用户阅读的解释信息，<em>hdrs</em> 则是一个包含出错头部信息的字典对象。</p>
<p>返回值和触发的异常应与 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 的相同。</p>
</dd></dl>

<span class="target" id="http-error-nnn"></span><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BaseHandler.http_error_&lt;nnn&gt;(req,</span> <span class="pre">fp,</span> <span class="pre">code,</span> <span class="pre">msg,</span> <span class="pre">hdrs)</span></span></dt>
<dd><p><em>nnn</em> 应为三位数的 HTTP 错误码。本方法在 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 中也未予定义，但当子类的实例发生代码为 <em>nnn</em> 的 HTTP 错误时，若方法存在则会被调用。</p>
<p>子类应该重写本方法，以便能处理相应的 HTTP 错误。</p>
<p>参数、返回值和触发的异常应与 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code> 相同。</p>
</dd></dl>

<span class="target" id="protocol-request"></span><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BaseHandler.&lt;protocol&gt;_request(req)</span></span></dt>
<dd><p>本方法在 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 中 <em>未</em> 予定义，但其子类若要对给定协议的请求进行预处理，则应进行定义。</p>
<p>若实现了本方法，将会被父 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 调用。<em>req</em> 将为 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 对象。返回值应为 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 对象。</p>
</dd></dl>

<span class="target" id="protocol-response"></span><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BaseHandler.&lt;protocol&gt;_response(req,</span> <span class="pre">response)</span></span></dt>
<dd><p>本方法在 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 中 <em>未</em> 予定义，但其子类若要对给定协议的请求进行后处理，则应进行定义。</p>
<p>若实现了本方法，将会被父 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 调用。<em>req</em> 将为 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 对象。<em>response</em> 应实现与  <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 返回值相同的接口。返回值应实现与 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 返回值相同的接口。</p>
</dd></dl>

</section>
<section id="httpredirecthandler-objects">
<span id="http-redirect-handler"></span><h2>HTTPRedirectHandler 对象<a class="headerlink" href="#httpredirecthandler-objects" title="永久链接至标题">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>某些 HTTP 重定向操作需要本模块的客户端代码提供的功能。这时会触发 <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>。有关各种重定向代码的确切含义，请参阅 <span class="target" id="index-31"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2616.html"><strong>RFC 2616</strong></a> 。</p>
<p>如果给到 HTTPRedirectHandler 的重定向 URL 不是 HTTP、HTTPS 或 FTP URL，则出于安全考虑将触发 <code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPError</span></code> 异常。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.redirect_request">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">redirect_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newurl</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.redirect_request" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 或 <code class="docutils literal notranslate"><span class="pre">None</span></code> 对象作为重定向行为的响应。当服务器接收到重定向请求时， <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code> 方法的默认实现代码将会调用本方法。如果确实应该发生重定向，则返回一个新的 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 对象，使得 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code> 能重定向至 <em>newurl</em>。否则，若没有 handler 会处理此 URL，则会引发 <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>；或者本方法不能处理但或许会有其他 handler 会处理，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>本方法的默认实现代码并未严格遵循 <span class="target" id="index-32"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2616.html"><strong>RFC 2616</strong></a>，即 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 请求的 301 和 302 响应不得在未经用户确认的情况下自动进行重定向。现实情况下，浏览器确实允许自动重定向这些响应，将 POST 更改为 <code class="docutils literal notranslate"><span class="pre">GET</span></code> ，于是默认实现代码就复现了这种处理方式。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.http_error_301">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_301</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="永久链接至目标">¶</a></dt>
<dd><p>重定向到 <code class="docutils literal notranslate"><span class="pre">Location:</span></code> 或 <code class="docutils literal notranslate"><span class="pre">URI:</span></code> URL。 当得到 HTTP 'moved permanently' 响应时，本方法会被父级 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 调用。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.http_error_302">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_302</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_302" title="永久链接至目标">¶</a></dt>
<dd><p>与  <a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a> 相同，不过是发生“found”响应时的调用。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.http_error_303">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_303</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_303" title="永久链接至目标">¶</a></dt>
<dd><p>与  <a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a> 相同，不过是发生“see other”响应时的调用。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.http_error_307">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_307</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_307" title="永久链接至目标">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>, but called for the 'temporary redirect'
response. It does not allow changing the request method from <code class="docutils literal notranslate"><span class="pre">POST</span></code>
to <code class="docutils literal notranslate"><span class="pre">GET</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.http_error_308">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_308</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_308" title="永久链接至目标">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>, but called for the 'permanent redirect'
response. It does not allow changing the request method from <code class="docutils literal notranslate"><span class="pre">POST</span></code>
to <code class="docutils literal notranslate"><span class="pre">GET</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.11 新版功能.</span></p>
</div>
</dd></dl>

</section>
<section id="httpcookieprocessor-objects">
<span id="http-cookie-processor"></span><h2>HTTPCookieProcessor 对象<a class="headerlink" href="#httpcookieprocessor-objects" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.HTTPCookieProcessor" title="urllib.request.HTTPCookieProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPCookieProcessor</span></code></a> 的实例具备一个属性：</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.HTTPCookieProcessor.cookiejar">
<span class="sig-prename descclassname"><span class="pre">HTTPCookieProcessor.</span></span><span class="sig-name descname"><span class="pre">cookiejar</span></span><a class="headerlink" href="#urllib.request.HTTPCookieProcessor.cookiejar" title="永久链接至目标">¶</a></dt>
<dd><p>cookie 存放在 <a class="reference internal" href="http.cookiejar.html#http.cookiejar.CookieJar" title="http.cookiejar.CookieJar"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.cookiejar.CookieJar</span></code></a> 中。</p>
</dd></dl>

</section>
<section id="proxyhandler-objects">
<span id="proxy-handler"></span><h2>ProxyHandler 对象<a class="headerlink" href="#proxyhandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProxyHandler.&lt;protocol&gt;_open(request)</span></span></dt>
<dd><p><a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> 将为每种 <em>protocol</em> 准备一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_open()</span></code> 方法，在构造函数给出的 <em>proxies</em> 字典中包含对应的代理服务器信息。通过调用 <code class="docutils literal notranslate"><span class="pre">request.set_proxy()</span></code>，本方法将把请求转为通过代理服务器，并会调用 handler 链中的下一个 handler 来完成对应的协议处理。</p>
</dd></dl>

</section>
<section id="httppasswordmgr-objects">
<span id="http-password-mgr"></span><h2>HTTPPasswordMgr 对象<a class="headerlink" href="#httppasswordmgr-objects" title="永久链接至标题">¶</a></h2>
<p>以下方法 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 和 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 对象均有提供。</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgr.add_password">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgr.</span></span><span class="sig-name descname"><span class="pre">add_password</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">realm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">passwd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.add_password" title="永久链接至目标">¶</a></dt>
<dd><p><em>uri</em> 可以是单个 URI，也可以是 URI 列表。<em>realm</em>、<em>user</em> 和 <em>passwd</em> 必须是字符串。这使得在为 <em>realm</em> 和超级 URI 进行身份认证时，<code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">passwd)</span></code> 可用作认证令牌。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgr.find_user_password">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgr.</span></span><span class="sig-name descname"><span class="pre">find_user_password</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">realm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">authuri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.find_user_password" title="永久链接至目标">¶</a></dt>
<dd><p>为给定 realm 和 URI 获取用户名和密码。如果没有匹配的用户名和密码，本方法将会返回 <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code> 。</p>
<p>对于 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 对象，如果给定 <em>realm</em> 没有匹配的用户名和密码，将搜索 realm  <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

</section>
<section id="httppasswordmgrwithpriorauth-objects">
<span id="http-password-mgr-with-prior-auth"></span><h2>HTTPPasswordMgrWithPriorAuth 对象<a class="headerlink" href="#httppasswordmgrwithpriorauth-objects" title="永久链接至标题">¶</a></h2>
<p>这是 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 的扩展，以便对那些需要一直发送认证凭证的 URI 进行跟踪。</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithPriorAuth.add_password">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgrWithPriorAuth.</span></span><span class="sig-name descname"><span class="pre">add_password</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">realm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">passwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_authenticated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.add_password" title="永久链接至目标">¶</a></dt>
<dd><p><em>realm</em>、<em>uri</em>、<em>user</em>、<em>passwd</em> 的含义与 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr.add_password" title="urllib.request.HTTPPasswordMgr.add_password"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HTTPPasswordMgr.add_password()</span></code></a> 的相同。<em>is_authenticated</em> 为给定 URI 或 URI 列表设置 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 标志的初始值。如果 <em>is_authenticated</em> 设为 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，则会忽略 <em>realm</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithPriorAuth.find_user_password">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgrWithPriorAuth.</span></span><span class="sig-name descname"><span class="pre">find_user_password</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">realm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">authuri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.find_user_password" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 对象的相同。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgrWithPriorAuth.</span></span><span class="sig-name descname"><span class="pre">update_authenticated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_authenticated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated" title="永久链接至目标">¶</a></dt>
<dd><p>更新给定 <em>uri</em> 或 URI 列表的 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 标志。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgrWithPriorAuth.</span></span><span class="sig-name descname"><span class="pre">is_authenticated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">authuri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated" title="永久链接至目标">¶</a></dt>
<dd><p>返回给定 URI <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 标志的当前状态。</p>
</dd></dl>

</section>
<section id="abstractbasicauthhandler-objects">
<span id="abstract-basic-auth-handler"></span><h2>AbstractBasicAuthHandler 对象<a class="headerlink" href="#abstractbasicauthhandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed">
<span class="sig-prename descclassname"><span class="pre">AbstractBasicAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_auth_reqed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">authreq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">headers</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed" title="永久链接至目标">¶</a></dt>
<dd><p>通过获取用户名和密码并重新尝试请求，以处理身份认证请求。 <em>authreq</em> 应该是请求中包含 realm 的头部信息名称，<em>host</em> 指定了需要进行身份认证的 URL 和路径，<em>req</em> 应为 (已失败的) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 对象 ,  <em>headers</em> 应该是出错的头部信息。</p>
<p><em>host</em> 要么是一个认证信息（例如 <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code> ），要么是一个包含认证信息的 URL（如``&quot;<a class="reference external" href="http://python.org/">http://python.org/</a>&quot;`` ）。 不论是哪种格式，认证信息中都不能包含用户信息（因此，<code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;python.org:80&quot;</span></code> 没问题，而 <code class="docutils literal notranslate"><span class="pre">&quot;joe:password&#64;python.org&quot;</span></code> 则不行）。</p>
</dd></dl>

</section>
<section id="httpbasicauthhandler-objects">
<span id="http-basic-auth-handler"></span><h2>HTTPBasicAuthHandler 对象<a class="headerlink" href="#httpbasicauthhandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPBasicAuthHandler.http_error_401">
<span class="sig-prename descclassname"><span class="pre">HTTPBasicAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_401</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler.http_error_401" title="永久链接至目标">¶</a></dt>
<dd><p>如果可用的话，请用身份认证信息重试请求。</p>
</dd></dl>

</section>
<section id="proxybasicauthhandler-objects">
<span id="proxy-basic-auth-handler"></span><h2>ProxyBasicAuthHandler 对象<a class="headerlink" href="#proxybasicauthhandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.ProxyBasicAuthHandler.http_error_407">
<span class="sig-prename descclassname"><span class="pre">ProxyBasicAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_407</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler.http_error_407" title="永久链接至目标">¶</a></dt>
<dd><p>如果可用的话，请用身份认证信息重试请求。</p>
</dd></dl>

</section>
<section id="abstractdigestauthhandler-objects">
<span id="abstract-digest-auth-handler"></span><h2>AbstractDigestAuthHandler 对象<a class="headerlink" href="#abstractdigestauthhandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed">
<span class="sig-prename descclassname"><span class="pre">AbstractDigestAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_auth_reqed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">authreq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">headers</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed" title="永久链接至目标">¶</a></dt>
<dd><p><em>authreq</em> 应为请求中有关 realm 的头部信息名称，<em>host</em> 应为需要进行身份认证的主机，<em>req</em> 应为（已失败的） <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 对象， <em>headers</em> 则应为出错的头部信息。</p>
</dd></dl>

</section>
<section id="httpdigestauthhandler-objects">
<span id="http-digest-auth-handler"></span><h2>HTTPDigestAuthHandler 对象<a class="headerlink" href="#httpdigestauthhandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPDigestAuthHandler.http_error_401">
<span class="sig-prename descclassname"><span class="pre">HTTPDigestAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_401</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler.http_error_401" title="永久链接至目标">¶</a></dt>
<dd><p>如果可用的话，请用身份认证信息重试请求。</p>
</dd></dl>

</section>
<section id="proxydigestauthhandler-objects">
<span id="proxy-digest-auth-handler"></span><h2>ProxyDigestAuthHandler 对象<a class="headerlink" href="#proxydigestauthhandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.ProxyDigestAuthHandler.http_error_407">
<span class="sig-prename descclassname"><span class="pre">ProxyDigestAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_407</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler.http_error_407" title="永久链接至目标">¶</a></dt>
<dd><p>如果可用的话，请用身份认证信息重试请求。</p>
</dd></dl>

</section>
<section id="httphandler-objects">
<span id="http-handler-objects"></span><h2>HTTPHandler 对象<a class="headerlink" href="#httphandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPHandler.http_open">
<span class="sig-prename descclassname"><span class="pre">HTTPHandler.</span></span><span class="sig-name descname"><span class="pre">http_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPHandler.http_open" title="永久链接至目标">¶</a></dt>
<dd><p>发送 HTTP 请求，根据 <code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code> 的结果，可能是 GET 或 POST 格式。</p>
</dd></dl>

</section>
<section id="httpshandler-objects">
<span id="https-handler-objects"></span><h2>HTTPSHandler 对象<a class="headerlink" href="#httpshandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPSHandler.https_open">
<span class="sig-prename descclassname"><span class="pre">HTTPSHandler.</span></span><span class="sig-name descname"><span class="pre">https_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler.https_open" title="永久链接至目标">¶</a></dt>
<dd><p>发送 HTTPS 请求，根据 <code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code> 的结果，可能是 GET 或 POST 格式。</p>
</dd></dl>

</section>
<section id="filehandler-objects">
<span id="file-handler-objects"></span><h2>FileHandler 对象<a class="headerlink" href="#filehandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.FileHandler.file_open">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">file_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FileHandler.file_open" title="永久链接至目标">¶</a></dt>
<dd><p>若无主机名或主机名为 <code class="docutils literal notranslate"><span class="pre">'localhost'</span></code> ，则打开本地文件。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>本方法仅适用于本地主机名。如果给出的是远程主机名，将会触发 <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> 。</p>
</div>
</dd></dl>

</section>
<section id="datahandler-objects">
<span id="data-handler-objects"></span><h2>DataHandler 对象<a class="headerlink" href="#datahandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.DataHandler.data_open">
<span class="sig-prename descclassname"><span class="pre">DataHandler.</span></span><span class="sig-name descname"><span class="pre">data_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.DataHandler.data_open" title="永久链接至目标">¶</a></dt>
<dd><p>读取内含数据的 URL。这种 URL 本身包含了经过编码的数据。 <span class="target" id="index-33"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2397.html"><strong>RFC 2397</strong></a> 中给出了数据 URL 的语法定义。目前的代码库将忽略经过 base64 编码的数据 URL 中的空白符，因此 URL 可以放入任何源码文件中。如果数据 URL 的 base64 编码尾部缺少填充，即使某些浏览器不介意，但目前的代码库仍会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</dd></dl>

</section>
<section id="ftphandler-objects">
<span id="ftp-handler-objects"></span><h2>FTPHandler 对象<a class="headerlink" href="#ftphandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.FTPHandler.ftp_open">
<span class="sig-prename descclassname"><span class="pre">FTPHandler.</span></span><span class="sig-name descname"><span class="pre">ftp_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FTPHandler.ftp_open" title="永久链接至目标">¶</a></dt>
<dd><p>打开由 <em>req</em> 给出的 FTP 文件。登录时的用户名和密码总是为空。</p>
</dd></dl>

</section>
<section id="cacheftphandler-objects">
<span id="cacheftp-handler-objects"></span><h2>CacheFTPHandler 对象<a class="headerlink" href="#cacheftphandler-objects" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.CacheFTPHandler" title="urllib.request.CacheFTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CacheFTPHandler</span></code></a> 对象即为加入以下方法的 <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a> 对象：</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.CacheFTPHandler.setTimeout">
<span class="sig-prename descclassname"><span class="pre">CacheFTPHandler.</span></span><span class="sig-name descname"><span class="pre">setTimeout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setTimeout" title="永久链接至目标">¶</a></dt>
<dd><p>设置连接超时为 <em>t</em> 秒。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.CacheFTPHandler.setMaxConns">
<span class="sig-prename descclassname"><span class="pre">CacheFTPHandler.</span></span><span class="sig-name descname"><span class="pre">setMaxConns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setMaxConns" title="永久链接至目标">¶</a></dt>
<dd><p>设置已缓存的最大连接数为 <em>m</em> 。</p>
</dd></dl>

</section>
<section id="unknownhandler-objects">
<span id="unknown-handler-objects"></span><h2>UnknownHandler 对象<a class="headerlink" href="#unknownhandler-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.UnknownHandler.unknown_open">
<span class="sig-prename descclassname"><span class="pre">UnknownHandler.</span></span><span class="sig-name descname"><span class="pre">unknown_open</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.UnknownHandler.unknown_open" title="永久链接至目标">¶</a></dt>
<dd><p>触发 <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> 异常。</p>
</dd></dl>

</section>
<section id="httperrorprocessor-objects">
<span id="http-error-processor-objects"></span><h2>HTTPErrorProcessor 对象<a class="headerlink" href="#httperrorprocessor-objects" title="永久链接至标题">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPErrorProcessor.http_response">
<span class="sig-prename descclassname"><span class="pre">HTTPErrorProcessor.</span></span><span class="sig-name descname"><span class="pre">http_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.http_response" title="永久链接至目标">¶</a></dt>
<dd><p>处理出错的 HTTP 响应。</p>
<p>对于 200 错误码，响应对象应立即返回。</p>
<p>对于 200 以外的错误码，只通过 <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.error()</span></code></a> 将任务传给 handler 的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> 方法。如果最终没有 handler 处理错误， <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a> 将触发 <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPErrorProcessor.https_response">
<span class="sig-prename descclassname"><span class="pre">HTTPErrorProcessor.</span></span><span class="sig-name descname"><span class="pre">https_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.https_response" title="永久链接至目标">¶</a></dt>
<dd><p>HTTPS 出错响应的处理。</p>
<p>与 <a class="reference internal" href="#urllib.request.HTTPErrorProcessor.http_response" title="urllib.request.HTTPErrorProcessor.http_response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code></a> 方法相同。</p>
</dd></dl>

</section>
<section id="examples">
<span id="urllib-request-examples"></span><h2>例子<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="../howto/urllib2.html#urllib-howto"><span class="std std-ref">如何利用 urllib 包获取网络资源</span></a> 中给出了更多的示例。</p>
<p>以下示例将读取 python.org 主页并显示前 300 个字节的内容：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">300</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">b&#39;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n\n\n&lt;html</span>
<span class="go">xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n</span>
<span class="go">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n</span>
<span class="go">&lt;title&gt;Python Programming &#39;</span>
</pre></div>
</div>
<p>请注意，urlopen 将返回字节对象。这是因为 urlopen 无法自动确定由 HTTP 服务器收到的字节流的编码。通常，只要能确定或猜出编码格式，就应将返回的字节对象解码为字符串。</p>
<p>下述 W3C 文档 <a class="reference external" href="https://www.w3.org/International/O-charset">https://www.w3.org/International/O-charset</a>列出了可用于指明（X）HTML 或 XML 文档编码信息的多种方案。</p>
<p>python.org 网站已在 meta 标签中指明，采用的是 <em>utf-8</em> 编码，因此这里将用同样的格式对字节串进行解码。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p>不用 <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> 方法也能获得同样的结果：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p>以下示例将会把数据流发送给某 CGI 的 stdin，并读取返回数据。请注意，该示例只能工作于 Python 装有 SSL 支持的环境。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;https://localhost/cgi-bin/test.cgi&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">data</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;This data is passed to stdin of the CGI&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">Got Data: &quot;This data is passed to stdin of the CGI&quot;</span>
</pre></div>
</div>
<p>上述示例中的 CGI 代码如下所示：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Content-type: text/plain</span><span class="se">\n\n</span><span class="s1">Got Data: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是利用 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 发送``PUT`` 请求的示例：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;some data&#39;</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;http://localhost:8080&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">DATA</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;PUT&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p>基本 HTTP 认证示例：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="c1"># Create an OpenerDirector with support for Basic HTTP Authentication...</span>
<span class="n">auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">HTTPBasicAuthHandler</span><span class="p">()</span>
<span class="n">auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="n">realm</span><span class="o">=</span><span class="s1">&#39;PDQ Application&#39;</span><span class="p">,</span>
                          <span class="n">uri</span><span class="o">=</span><span class="s1">&#39;https://mahler:8092/site-updates.py&#39;</span><span class="p">,</span>
                          <span class="n">user</span><span class="o">=</span><span class="s1">&#39;klem&#39;</span><span class="p">,</span>
                          <span class="n">passwd</span><span class="o">=</span><span class="s1">&#39;kadidd!ehopper&#39;</span><span class="p">)</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">auth_handler</span><span class="p">)</span>
<span class="c1"># ...and install it globally so it can be used with urlopen.</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">install_opener</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.build_opener" title="urllib.request.build_opener"><code class="xref py py-func docutils literal notranslate"><span class="pre">build_opener()</span></code></a> 默认提供了很多现成的 handler，包括 <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>。 默认情况下，<a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> 会使用名为 <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code> 的环境变量，其中的 <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;</span></code> 是相关的 URL 协议。 例如，可以读取 <span class="target" id="index-34"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code> 环境变量来获取 HTTP 代理的 URL。</p>
<p>This example replaces the default <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> with one that uses
programmatically supplied proxy URLs, and adds proxy authorization support with
<a class="reference internal" href="#urllib.request.ProxyBasicAuthHandler" title="urllib.request.ProxyBasicAuthHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyBasicAuthHandler</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">proxy_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyHandler</span><span class="p">({</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://www.example.com:3128/&#39;</span><span class="p">})</span>
<span class="n">proxy_auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyBasicAuthHandler</span><span class="p">()</span>
<span class="n">proxy_auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="s1">&#39;realm&#39;</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">,</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">)</span>

<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">proxy_handler</span><span class="p">,</span> <span class="n">proxy_auth_handler</span><span class="p">)</span>
<span class="c1"># This time, rather than install the OpenerDirector, we use it directly:</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>添加 HTTP 头部信息：</p>
<p>可利用 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 构造函数的 <em>headers</em> 参数，或者是：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Referer&#39;</span><span class="p">,</span> <span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="c1"># Customize the default User-Agent header value:</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;User-Agent&#39;</span><span class="p">,</span> <span class="s1">&#39;urllib-example/0.1 (Contact: . . .)&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 自动会在每个 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 中加入一项 <em class="mailheader">User-Agent</em> 头部信息。若要修改，请参见以下语句：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">()</span>
<span class="n">opener</span><span class="o">.</span><span class="n">addheaders</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;User-agent&#39;</span><span class="p">,</span> <span class="s1">&#39;Mozilla/5.0&#39;</span><span class="p">)]</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>另请记得，当 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 传给  <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>  （或 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a>）时，会加入一些标准的头部信息（ <em class="mailheader">Content-Length</em> 、 <em class="mailheader">Content-Type</em> 和 <em class="mailheader">Host</em>）。</p>
<p id="urllib-examples">以下会话示例用 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 方法读取包含参数的 URL。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://www.musi-cal.com/cgi-bin/query?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">params</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>以下示例换用 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 方法。请注意 urlencode 输出结果先被编码为字节串 data，再送入 urlopen。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://requestb.in/xrbl82xr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>以下示例显式指定了 HTTP 代理，以覆盖环境变量中的设置：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://proxy.example.com:8080/&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">(</span><span class="n">proxies</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>以下示例根本不用代理，也覆盖了环境变量中的设置：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">({})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org/&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</section>
<section id="legacy-interface">
<h2>已停用的接口<a class="headerlink" href="#legacy-interface" title="永久链接至标题">¶</a></h2>
<p>以下函数和类是由 Python 2 模块 <code class="docutils literal notranslate"><span class="pre">urllib``（相对早于</span> <span class="pre">``urllib2</span></code> ）移植过来的。将来某个时候可能会停用。</p>
<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.urlretrieve">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">urlretrieve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reporthook</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlretrieve" title="永久链接至目标">¶</a></dt>
<dd><p>将 URL 形式的网络对象复制为本地文件。如果 URL 指向本地文件，则必须提供文件名才会执行复制。返回值为元组 <code class="docutils literal notranslate"><span class="pre">(filename,</span> <span class="pre">headers)</span></code> ，其中 <em>filename</em> 是保存网络对象的本地文件名， <em>headers</em> 是由 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 返回的远程对象 <code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code> 方法的调用结果。可能触发的异常与 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 相同。</p>
<p>第二个参数指定文件的保存位置（若未给出，则会是名称随机生成的临时文件）。第三个参数是个可调用对象，在建立网络连接时将会调用一次，之后每次读完数据块后会调用一次。该可调用对象将会传入 3 个参数：已传输的块数、块的大小（以字节为单位）和文件总的大小。如果面对的是老旧 FTP 服务器，文件大小参数可能会是 <code class="docutils literal notranslate"><span class="pre">-1</span></code> ，这些服务器响应读取请求时不会返回文件大小。</p>
<p>以下例子演示了大部分常用场景：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_filename</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="s1">&#39;http://python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">local_filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>如果 <em>url</em> 使用 <code class="file docutils literal notranslate"><span class="pre">http:</span></code> 方式的标识符，则可能给出可选的 <em>data</em> 参数来指定一个 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 请求 (通常的请求类型为 <code class="docutils literal notranslate"><span class="pre">GET</span></code>)。 <em>data</em> 参数必须是标准 <em class="mimetype">application/x-www-form-urlencoded</em> 格式的字节串对象；参见 <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 函数。</p>
<p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> 在检测到可用数据少于预期的大小（即由 <em>Content-Length</em> 标头所报告的大小）时将引发 <code class="xref py py-exc docutils literal notranslate"><span class="pre">ContentTooShortError</span></code>。 例如，这可能会在下载中断时发生。</p>
<p><em>Content-Length</em> 会被视为大小的下限：如果存在更多的可用数据，urlretrieve 会读取更多的数据，但是如果可用数据少于该值，则会引发异常。</p>
<p>在这种情况下你仍然能够获取已下载的数据，它会存放在异常实例的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">content</span></code> 属性中。</p>
<p>如果未提供 <em>Content-Length</em> 标头，urlretrieve 就无法检查它所下载的数据大小，只是简单地返回它。 在这种情况下你只能假定下载是成功的。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.urlcleanup">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">urlcleanup</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlcleanup" title="永久链接至目标">¶</a></dt>
<dd><p>清理之前调用 <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> 时可能留下的临时文件。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.URLopener">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">URLopener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proxies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">x509</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener" title="永久链接至目标">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">3.3 版后已移除.</span></p>
</div>
<p>用于打开和读取 URL 的基类。 除非你需要支持使用 <code class="file docutils literal notranslate"><span class="pre">http:</span></code>, <code class="file docutils literal notranslate"><span class="pre">ftp:</span></code> 或 <code class="file docutils literal notranslate"><span class="pre">file:</span></code> 以外的方式来打开对象，那你也许可以使用 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>。</p>
<p>在默认情况下，<a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 类会发送一个内容为 <code class="docutils literal notranslate"><span class="pre">urllib/VVV</span></code> 的 <em class="mailheader">User-Agent</em> 标头，其中 <em>VVV</em> 是 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> 的版本号。 应用程序可以通过子类化 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 或 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 并在子类定义中将类属性 <a class="reference internal" href="#urllib.request.URLopener.version" title="urllib.request.URLopener.version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">version</span></code></a> 设为适当的字符串值来定义自己的 <em class="mailheader">User-Agent</em> 标头。</p>
<p>可选的 <em>proxies</em> 形参应当是一个将方式名称映射到代理 URL 的字典，如为空字典则会完全关闭代理。 它的默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，在这种情况下如果存在环境代理设置则将使用它，正如上文 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 的定义中所描述的。</p>
<p>一些归属于 <em>x509</em> 的额外关键字形参可在使用 <code class="file docutils literal notranslate"><span class="pre">https:</span></code> 方式时被用于客户端的验证。 支持通过关键字 <em>key_file</em> 和 <em>cert_file</em> 来提供 SSL 密钥和证书；对客户端验证的支持需要提供这两个形参。</p>
<p>如果服务器返回错误代码则 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 对象将引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常。</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.URLopener.open">
<span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullurl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open" title="永久链接至目标">¶</a></dt>
<dd><p>使用适当的协议打开 <em>fullurl</em>。 此方法会设置缓存和代理信息，然后调用适当的打开方法并附带其输入参数。 如果方式无法被识别，则会调用 <a class="reference internal" href="#urllib.request.URLopener.open_unknown" title="urllib.request.URLopener.open_unknown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open_unknown()</span></code></a>。 <em>data</em> 参数的含义与 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 中的 <em>data</em> 参数相同。</p>
<p>此方法总是会使用 <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a> 来对 <em>fullurl</em> 进行转码。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.URLopener.open_unknown">
<span class="sig-name descname"><span class="pre">open_unknown</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullurl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open_unknown" title="永久链接至目标">¶</a></dt>
<dd><p>用于打开未知 URL 类型的可重载接口。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.URLopener.retrieve">
<span class="sig-name descname"><span class="pre">retrieve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reporthook</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.retrieve" title="永久链接至目标">¶</a></dt>
<dd><p>提取 <em>url</em> 的内容并将其存放到 <em>filename</em> 中。 返回值为元组，由一个本地文件名和一个包含响应标头 (对于远程 URL) 的 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a> 对象或者 <code class="docutils literal notranslate"><span class="pre">None</span></code>  (对于本地 URL)。 之后调用方必须打开并读取 <em>filename</em> 的内容。 如果 <em>filename</em> 未给出并且 URL 指向一个本地文件，则会返回输入文件名。 如果 URL 非本地并且 <em>filename</em> 未给出，则文件名为带有与输入 URL 的路径末尾部分后缀相匹配的后缀的 <a class="reference internal" href="tempfile.html#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.mktemp()</span></code></a> 的输出。 如果给出了 <em>reporthook</em>，它必须为接受三个数字形参的函数：数据分块编号、读入分块的最大数据量和下载的总数据量 (未知则为 -1)。 它将在开始时和从网络读取每个数据分块之后被调用。 对于本地 URL <em>reporthook</em> 会被忽略。</p>
<p>如果 <em>url</em> 使用 <code class="file docutils literal notranslate"><span class="pre">http:</span></code> 方式的标识符，则可能给出可选的 <em>data</em> 参数来指定一个 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 请求 (通常的请求类型为 <code class="docutils literal notranslate"><span class="pre">GET</span></code>)。 <em>data</em> 参数必须为标准的 <em class="mimetype">application/x-www-form-urlencoded</em> 格式 ；参见 <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 函数。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.URLopener.version">
<span class="sig-name descname"><span class="pre">version</span></span><a class="headerlink" href="#urllib.request.URLopener.version" title="永久链接至目标">¶</a></dt>
<dd><p>指明打开器对象的用户代理名称的变量。  以便让 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> 告诉服务器它是某个特定的用户代理，请在子类中将其作为类变量来设置或是在调用基类构造器之前在构造器中设置。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.FancyURLopener">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">FancyURLopener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener" title="永久链接至目标">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">3.3 版后已移除.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 子类化了 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 以提供对以下 HTTP 响应代码的默认处理: 301, 302, 303, 307 和 401。 对于上述的 30x 响应代码，会使用 <em class="mailheader">Location</em> 标头来获取实际 URL。 对于 401 响应代码 (authentication required)，则会执行基本 HTTP 验证。 对于 30x 响应代码，递归层数会受 <em>maxtries</em> 属性值的限制，该值默认为 10。</p>
<p>对于所有其他响应代码，会调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code> 方法，你可以在子类中重载此方法来正确地处理错误。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>根据 <span class="target" id="index-35"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2616.html"><strong>RFC 2616</strong></a> 的说明，对 POST 请求的 301 和 302 响应不可在未经用户确认的情况下自动进行重定向。 在现实情况下，浏览器确实允许自动重定义这些响应，将 POST 更改为 GET，于是 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> 就会复现这种行为。</p>
</div>
<p>传给此构造器的形参与 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 的相同。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当执行基本验证时，<a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 实例会调用其 <a class="reference internal" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="urllib.request.FancyURLopener.prompt_user_passwd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prompt_user_passwd()</span></code></a> 方法。 默认的实现将向用户询问控制终端所要求的信息。 如有必要子类可以重载此方法来支持更适当的行为。</p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 类附带了一个额外方法，它应当被重载以提供适当的行为:</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.FancyURLopener.prompt_user_passwd">
<span class="sig-name descname"><span class="pre">prompt_user_passwd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">realm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="永久链接至目标">¶</a></dt>
<dd><p>返回指定的安全体系下在给定的主机上验证用户所需的信息。 返回的值应当是一个元组 <code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">password)</span></code>，它可被用于基本验证。</p>
<p>该实现会在终端上提示此信息；应用程序应当重载此方法以使用本地环境下适当的交互模型。</p>
</dd></dl>

</dd></dl>

</section>
<section id="urllib-request-restrictions">
<h2><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 的限制<a class="headerlink" href="#urllib-request-restrictions" title="永久链接至标题">¶</a></h2>
<blockquote>
<div></div></blockquote>
<ul id="index-11">
<li><p>目前，仅支持下列协议: HTTP (0.9 和 1.0 版), FTP, 本地文件, 以及数据 URL。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>增加了对数据URL 的支持。</p>
</div>
</li>
<li><p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> 的缓存特性已被禁用，等待有人有时间去正确地解决过期时间标头的处理问题。</p></li>
<li><p>应当有一个函数来查询特定 URL 是否在缓存中。</p></li>
<li><p>为了保持向下兼容性，如果某个 URL 看起来是指向本地文件但该文件无法被打开，则该 URL 会使用 FTP 协议来重新解读。 这有时可能会导致令人迷惑的错误消息。</p></li>
<li><p><a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 和 <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> 函数在等待网络连接建立时会导致任意长时间的延迟。 这意味着在不使用线程的情况下搭建一个可交互的 Web 客户端是非常困难的。</p>
</li>
<li id="index-12"><p>由 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 或 <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> 返回的数据就是服务器所返回的原始数据。 这可以是二进制数据（如图片）、纯文本或 HTML 代码等。 HTTP 协议在响应标头中提供了类型信息，这可以通过读取 <em class="mailheader">Content-Type</em> 标头来查看。 如果返回的数据是 HTML，你可以使用 <a class="reference internal" href="html.parser.html#module-html.parser" title="html.parser: A simple parser that can handle HTML and XHTML."><code class="xref py py-mod docutils literal notranslate"><span class="pre">html.parser</span></code></a> 模块来解析它。</p>
</li>
<li id="index-13"><p>处理 FTP 协议的代码无法区分文件和目录。 这在尝试读取指向不可访问的 URL 时可能导致意外的行为。 如果 URL 以一个 <code class="docutils literal notranslate"><span class="pre">/</span></code> 结束，它会被认为指向一个目录并将作相应的处理。 但是如果读取一个文件的尝试导致了 550 错误（表示 URL 无法找到或不可访问，这常常是由于权限原因），则该路径会被视为一个目录以便处理 URL 是指定一个目录但略去了末尾 <code class="docutils literal notranslate"><span class="pre">/</span></code> 的情况。 这在你尝试获取一个因其设置了读取权限因而无法访问的文件时会造成误导性的结果；FTP 代码将尝试读取它，因 550 错误而失败，然后又为这个不可读取的文件执行目录列表操作。 如果需要细粒度的控制，请考虑使用 <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> 模块，子类化 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>，或是修改 <em>_urlopener</em> 来满足你的需求。</p></li>
</ul>
</section>
</section>
<section id="module-urllib.response">
<span id="urllib-response-response-classes-used-by-urllib"></span><h1><a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> --- urllib 使用的 Response 类<a class="headerlink" href="#module-urllib.response" title="永久链接至标题">¶</a></h1>
<p><a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> 模块定义了一些函数和提供最小化文件类接口包括 <code class="docutils literal notranslate"><span class="pre">read()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">readline()</span></code> 等的类。 此模块定义的函数会由 <a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 模块在内部使用。 典型的响应对象是一个 <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a> 实例:</p>
<dl class="py class">
<dt class="sig sig-object py" id="urllib.response.addinfourl">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.response.</span></span><span class="sig-name descname"><span class="pre">addinfourl</span></span><a class="headerlink" href="#urllib.response.addinfourl" title="永久链接至目标">¶</a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="urllib.response.addinfourl.url">
<span class="sig-name descname"><span class="pre">url</span></span><a class="headerlink" href="#urllib.response.addinfourl.url" title="永久链接至目标">¶</a></dt>
<dd><p>已读取资源的 URL，通常用于确定是否进行了重定向。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.response.addinfourl.headers">
<span class="sig-name descname"><span class="pre">headers</span></span><a class="headerlink" href="#urllib.response.addinfourl.headers" title="永久链接至目标">¶</a></dt>
<dd><p>以 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 实例的形式返回响应的标头。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.response.addinfourl.status">
<span class="sig-name descname"><span class="pre">status</span></span><a class="headerlink" href="#urllib.response.addinfourl.status" title="永久链接至目标">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">3.9 新版功能.</span></p>
</div>
<p>由服务器返回的状态码。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.response.addinfourl.geturl">
<span class="sig-name descname"><span class="pre">geturl</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.geturl" title="永久链接至目标">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span>已弃用，建议改用 <a class="reference internal" href="#urllib.response.addinfourl.url" title="urllib.response.addinfourl.url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">url</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.response.addinfourl.info">
<span class="sig-name descname"><span class="pre">info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.info" title="永久链接至目标">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span>已弃用，建议改用 <a class="reference internal" href="#urllib.response.addinfourl.headers" title="urllib.response.addinfourl.headers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">headers</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.response.addinfourl.code">
<span class="sig-name descname"><span class="pre">code</span></span><a class="headerlink" href="#urllib.response.addinfourl.code" title="永久链接至目标">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span>已弃用，建议改用 <a class="reference internal" href="#urllib.response.addinfourl.status" title="urllib.response.addinfourl.status"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.response.addinfourl.getstatus">
<span class="sig-name descname"><span class="pre">getstatus</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.getstatus" title="永久链接至目标">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span>已弃用，建议改用 <a class="reference internal" href="#urllib.response.addinfourl.status" title="urllib.response.addinfourl.status"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status</span></code></a>。</p>
</div>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> --- 用于打开 URL 的可扩展库</a><ul>
<li><a class="reference internal" href="#request-objects">Request 对象</a></li>
<li><a class="reference internal" href="#openerdirector-objects">OpenerDirector 对象</a></li>
<li><a class="reference internal" href="#basehandler-objects">BaseHandler 对象</a></li>
<li><a class="reference internal" href="#httpredirecthandler-objects">HTTPRedirectHandler 对象</a></li>
<li><a class="reference internal" href="#httpcookieprocessor-objects">HTTPCookieProcessor 对象</a></li>
<li><a class="reference internal" href="#proxyhandler-objects">ProxyHandler 对象</a></li>
<li><a class="reference internal" href="#httppasswordmgr-objects">HTTPPasswordMgr 对象</a></li>
<li><a class="reference internal" href="#httppasswordmgrwithpriorauth-objects">HTTPPasswordMgrWithPriorAuth 对象</a></li>
<li><a class="reference internal" href="#abstractbasicauthhandler-objects">AbstractBasicAuthHandler 对象</a></li>
<li><a class="reference internal" href="#httpbasicauthhandler-objects">HTTPBasicAuthHandler 对象</a></li>
<li><a class="reference internal" href="#proxybasicauthhandler-objects">ProxyBasicAuthHandler 对象</a></li>
<li><a class="reference internal" href="#abstractdigestauthhandler-objects">AbstractDigestAuthHandler 对象</a></li>
<li><a class="reference internal" href="#httpdigestauthhandler-objects">HTTPDigestAuthHandler 对象</a></li>
<li><a class="reference internal" href="#proxydigestauthhandler-objects">ProxyDigestAuthHandler 对象</a></li>
<li><a class="reference internal" href="#httphandler-objects">HTTPHandler 对象</a></li>
<li><a class="reference internal" href="#httpshandler-objects">HTTPSHandler 对象</a></li>
<li><a class="reference internal" href="#filehandler-objects">FileHandler 对象</a></li>
<li><a class="reference internal" href="#datahandler-objects">DataHandler 对象</a></li>
<li><a class="reference internal" href="#ftphandler-objects">FTPHandler 对象</a></li>
<li><a class="reference internal" href="#cacheftphandler-objects">CacheFTPHandler 对象</a></li>
<li><a class="reference internal" href="#unknownhandler-objects">UnknownHandler 对象</a></li>
<li><a class="reference internal" href="#httperrorprocessor-objects">HTTPErrorProcessor 对象</a></li>
<li><a class="reference internal" href="#examples">例子</a></li>
<li><a class="reference internal" href="#legacy-interface">已停用的接口</a></li>
<li><a class="reference internal" href="#urllib-request-restrictions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> 的限制</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-urllib.response"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code> --- urllib 使用的 Response 类</a></li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="urllib.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code> --- URL 处理模块</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="urllib.parse.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code>  用于解析 URL</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/urllib.request.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse 用于解析 URL"
             >下一页</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib --- URL 处理模块"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >互联网协议和支持</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> --- 用于打开 URL 的可扩展库</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 11月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0创建。
    </div>

  </body>
</html>