
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>xml.etree.ElementTree --- ElementTree XML API &#8212; Python 3.11.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="xml.dom --- 文档对象模型 API" href="xml.dom.html" />
    <link rel="prev" title="XML处理模块" href="xml.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/xml.etree.elementtree.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code> ---  ElementTree XML API</a><ul>
<li><a class="reference internal" href="#tutorial">教程</a><ul>
<li><a class="reference internal" href="#xml-tree-and-elements">XML 树和元素</a></li>
<li><a class="reference internal" href="#parsing-xml">解析 XML</a></li>
<li><a class="reference internal" href="#pull-api-for-non-blocking-parsing">用于非阻塞解析的拉取 API</a></li>
<li><a class="reference internal" href="#finding-interesting-elements">查找感兴趣的元素</a></li>
<li><a class="reference internal" href="#modifying-an-xml-file">修改XML文件</a></li>
<li><a class="reference internal" href="#building-xml-documents">构建 XML 文档</a></li>
<li><a class="reference internal" href="#parsing-xml-with-namespaces">解析带有命名空间的 XML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xpath-support">XPath支持</a><ul>
<li><a class="reference internal" href="#example">示例</a></li>
<li><a class="reference internal" href="#supported-xpath-syntax">支持的XPath语法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference">参考</a><ul>
<li><a class="reference internal" href="#functions">函数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xinclude-support">XInclude 支持</a><ul>
<li><a class="reference internal" href="#id3">示例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">参考</a><ul>
<li><a class="reference internal" href="#elementinclude-functions">函数</a></li>
<li><a class="reference internal" href="#element-objects">元素对象</a></li>
<li><a class="reference internal" href="#elementtree-objects">ElementTree 对象</a></li>
<li><a class="reference internal" href="#qname-objects">QName 对象</a></li>
<li><a class="reference internal" href="#treebuilder-objects">TreeBuilder 对象</a></li>
<li><a class="reference internal" href="#xmlparser-objects">XMLParser对象</a></li>
<li><a class="reference internal" href="#xmlpullparser-objects">XMLPullParser对象</a></li>
<li><a class="reference internal" href="#exceptions">异常</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="xml.html"
                          title="上一章">XML处理模块</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="xml.dom.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom</span></code> --- 文档对象模型 API</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/xml.etree.elementtree.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="xml.dom.html" title="xml.dom --- 文档对象模型 API"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="xml.html" title="XML处理模块"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="markup.html" accesskey="U">结构化标记处理工具</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code> ---  ElementTree XML API</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-xml.etree.ElementTree">
<span id="xml-etree-elementtree-the-elementtree-xml-api"></span><h1><a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> ---  ElementTree XML API<a class="headerlink" href="#module-xml.etree.ElementTree" title="永久链接至标题">¶</a></h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/xml/etree/ElementTree.py">Lib/xml/etree/ElementTree.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> 模块实现了一个简单高效的API，用于解析和创建XML数据。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>此模块将在可能的情况下使用快速实现。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.3 版后已移除: </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.cElementTree</span></code> 模块已被弃用。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> 模块对于恶意构建的数据是不安全的。如果需要解析不可信或未经身份验证的数据，请参见 <a class="reference internal" href="xml.html#xml-vulnerabilities"><span class="std std-ref">XML 漏洞</span></a> 。</p>
</div>
<section id="tutorial">
<h2>教程<a class="headerlink" href="#tutorial" title="永久链接至标题">¶</a></h2>
<p>这是一个使用 <a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> （简称 <code class="docutils literal notranslate"><span class="pre">ET</span></code> ）的简短教程。目标是演示模块的一些构建块和基本概念。</p>
<section id="xml-tree-and-elements">
<h3>XML 树和元素<a class="headerlink" href="#xml-tree-and-elements" title="永久链接至标题">¶</a></h3>
<p>XML 是一种继承性的分层数据格式，最自然的表示方法是使用树。 为此， <code class="docutils literal notranslate"><span class="pre">ET</span></code> 有两个类 -- <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 将整个XML文档表示为一个树， <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 表示该树中的单个节点。 与整个文档的交互（读写文件）通常在 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 级别完成。 与单个 XML 元素及其子元素的交互是在 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 级别完成的。</p>
</section>
<section id="parsing-xml">
<span id="elementtree-parsing-xml"></span><h3>解析 XML<a class="headerlink" href="#parsing-xml" title="永久链接至标题">¶</a></h3>
<p>我们将使用以下 XML 文档作为本节的示例数据：</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Liechtenstein&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank&gt;</span>1<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2008<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>141100<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Austria&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Switzerland&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Singapore&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank&gt;</span>4<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>59900<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Malaysia&quot;</span> <span class="na">direction=</span><span class="s">&quot;N&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Panama&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank&gt;</span>68<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>13600<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Costa Rica&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Colombia&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
<span class="nt">&lt;/data&gt;</span>
</pre></div>
</div>
<p>可以通过从文件中读取来导入此数据：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;country_data.xml&#39;</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
</pre></div>
</div>
<p>或直接从字符串中解析：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">country_data_as_string</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#xml.etree.ElementTree.fromstring" title="xml.etree.ElementTree.fromstring"><code class="xref py py-func docutils literal notranslate"><span class="pre">fromstring()</span></code></a> 将 XML 从字符串直接解析为 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> ，该元素是已解析树的根元素。 其他解析函数可能会创建一个 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 。 确切信息请查阅文档。</p>
<p>作为 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> ， <code class="docutils literal notranslate"><span class="pre">root</span></code> 具有标签和属性字典:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">tag</span>
<span class="go">&#39;data&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span>
<span class="go">{}</span>
</pre></div>
</div>
<p>还有可以迭代的子节点：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">country {&#39;name&#39;: &#39;Liechtenstein&#39;}</span>
<span class="go">country {&#39;name&#39;: &#39;Singapore&#39;}</span>
<span class="go">country {&#39;name&#39;: &#39;Panama&#39;}</span>
</pre></div>
</div>
<p>子级是可以嵌套的，我们可以通过索引访问特定的子级节点：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span>
<span class="go">&#39;2008&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>并非 XML 输入的所有元素都将作为解析树的元素结束。 目前，此模块跳过输入中的任何 XML 注释、处理指令和文档类型声明。 然而，使用这个模块的 API 而不是从 XML 文本解析构建的树可以包含注释和处理指令，生成 XML 输出时同样包含这些注释和处理指令。 可以通过将自定义 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> 实例传递给 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 构造器来访问文档类型声明。</p>
</div>
</section>
<section id="pull-api-for-non-blocking-parsing">
<span id="elementtree-pull-parsing"></span><h3>用于非阻塞解析的拉取 API<a class="headerlink" href="#pull-api-for-non-blocking-parsing" title="永久链接至标题">¶</a></h3>
<p>此模块所提供了大多数解析函数都要求在返回任何结果之前一次性读取整个文档。 可以使用 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 并以增量方式添加数据，但这是在回调目标上调用方法的推送式 API。 有时用户真正想要的是能够以增量方式解析 XML 而无需阻塞操作，同时享受完整的已构造 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 对象。</p>
<p>针对此需求的最强大工具是 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a>。 它不要求通过阻塞式读取来获得 XML 数据，而是通过执行 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.feed" title="xml.etree.ElementTree.XMLPullParser.feed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLPullParser.feed()</span></code></a> 调用来增量式地添加数据。  要获得已解析的 XML 元素，应调用 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLPullParser.read_events()</span></code></a>。 下面是一个示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XMLPullParser</span><span class="p">([</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s1">&#39;&lt;mytag&gt;sometext&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">read_events</span><span class="p">())</span>
<span class="go">[(&#39;start&#39;, &lt;Element &#39;mytag&#39; at 0x7fa66db2be58&gt;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s1">&#39; more text&lt;/mytag&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">read_events</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s1">&#39;text=&#39;</span><span class="p">,</span> <span class="n">elem</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">end</span>
</pre></div>
</div>
<p>常见的用例是针对以非阻塞方式进行的应用程序，其中 XML 是从套接字接收或从某些存储设备增量式读取的。 在这些用例中，阻塞式读取是不可接受的。</p>
<p>因为其非常灵活，<a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a> 在更简单的用例中使用起来可能并不方便。 如果你不介意你的应用程序在读取 XML 数据时造成阻塞但仍希望具有增量解析能力，可以考虑 <a class="reference internal" href="#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterparse()</span></code></a>。 它在你读取大型 XML 文档并且不希望将它完全放去内存时会很适用。</p>
</section>
<section id="finding-interesting-elements">
<h3>查找感兴趣的元素<a class="headerlink" href="#finding-interesting-elements" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 有一些很有效的方法，可帮助递归遍历其下的所有子树（包括子级，子级的子级，等等）。例如 <a class="reference internal" href="#xml.etree.ElementTree.Element.iter" title="xml.etree.ElementTree.Element.iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.iter()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;neighbor&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">{&#39;name&#39;: &#39;Austria&#39;, &#39;direction&#39;: &#39;E&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Switzerland&#39;, &#39;direction&#39;: &#39;W&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Malaysia&#39;, &#39;direction&#39;: &#39;N&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Costa Rica&#39;, &#39;direction&#39;: &#39;W&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Colombia&#39;, &#39;direction&#39;: &#39;E&#39;}</span>
</pre></div>
</div>
<p><a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.findall()</span></code></a> 仅查找当前元素的直接子元素中带有指定标签的元素。 <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.find()</span></code></a> 找带有特定标签的 <em>第一个</em> 子级，然后可以用 <a class="reference internal" href="#xml.etree.ElementTree.Element.text" title="xml.etree.ElementTree.Element.text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Element.text</span></code></a> 访问元素的文本内容。 <a class="reference internal" href="#xml.etree.ElementTree.Element.get" title="xml.etree.ElementTree.Element.get"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Element.get</span></code></a> 访问元素的属性:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">country</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;country&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">rank</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Liechtenstein 1</span>
<span class="go">Singapore 4</span>
<span class="go">Panama 68</span>
</pre></div>
</div>
<p>通过使用 <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">XPath</span></a> ，可以更精确地指定要查找的元素。</p>
</section>
<section id="modifying-an-xml-file">
<h3>修改XML文件<a class="headerlink" href="#modifying-an-xml-file" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 提供了一种构建XML文档并将其写入文件的简单方法。调用 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code></a> 方法就可以实现。</p>
<p>创建后可以直接操作 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 对象。例如：使用 <a class="reference internal" href="#xml.etree.ElementTree.Element.text" title="xml.etree.ElementTree.Element.text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Element.text</span></code></a> 修改文本字段，使用 <a class="reference internal" href="#xml.etree.ElementTree.Element.set" title="xml.etree.ElementTree.Element.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.set()</span></code></a> 方法添加和修改属性，以及使用  <a class="reference internal" href="#xml.etree.ElementTree.Element.append" title="xml.etree.ElementTree.Element.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.append()</span></code></a> 添加新的子元素。</p>
<p>假设我们要为每个国家/地区的中添加一个排名，并在排名元素中添加一个 <code class="docutils literal notranslate"><span class="pre">updated</span></code> 属性：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">new_rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rank</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">rank</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_rank</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">rank</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;updated&#39;</span><span class="p">,</span> <span class="s1">&#39;yes&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>生成的XML现在看起来像这样：</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Liechtenstein&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>2<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2008<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>141100<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Austria&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Switzerland&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Singapore&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>5<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>59900<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Malaysia&quot;</span> <span class="na">direction=</span><span class="s">&quot;N&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Panama&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>69<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>13600<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Costa Rica&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Colombia&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
<span class="nt">&lt;/data&gt;</span>
</pre></div>
</div>
<p>可以使用 <a class="reference internal" href="#xml.etree.ElementTree.Element.remove" title="xml.etree.ElementTree.Element.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.remove()</span></code></a> 删除元素。假设我们要删除排名高于50的所有国家/地区:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">country</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;country&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># using root.findall() to avoid removal during traversal</span>
<span class="gp">... </span>    <span class="n">rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">country</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">root</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">country</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>请注意在迭代时进行并发修改可能会导致问题，就像在迭代并修改 Python 列表或字典时那样。 因此，这个示例先通过 <code class="docutils literal notranslate"><span class="pre">root.findall()</span></code> 收集了所有匹配的元素，在此之后再对匹配项列表进行迭代。</p>
<p>生成的XML现在看起来像这样：</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Liechtenstein&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>2<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2008<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>141100<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Austria&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Switzerland&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Singapore&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>5<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>59900<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Malaysia&quot;</span> <span class="na">direction=</span><span class="s">&quot;N&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
<span class="nt">&lt;/data&gt;</span>
</pre></div>
</div>
</section>
<section id="building-xml-documents">
<h3>构建 XML 文档<a class="headerlink" href="#building-xml-documents" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#xml.etree.ElementTree.SubElement" title="xml.etree.ElementTree.SubElement"><code class="xref py py-func docutils literal notranslate"><span class="pre">SubElement()</span></code></a> 函数还提供了一种便捷方法来为给定元素创建新的子元素:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ET</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;a&gt;&lt;b /&gt;&lt;c&gt;&lt;d /&gt;&lt;/c&gt;&lt;/a&gt;</span>
</pre></div>
</div>
</section>
<section id="parsing-xml-with-namespaces">
<h3>解析带有命名空间的 XML<a class="headerlink" href="#parsing-xml-with-namespaces" title="永久链接至标题">¶</a></h3>
<p>如果 XML 输入带有 <a class="reference external" href="https://en.wikipedia.org/wiki/XML_namespace">命名空间</a>，则具有前缀的 <code class="docutils literal notranslate"><span class="pre">prefix:sometag</span></code> 形式的标记和属性将被扩展为 <code class="docutils literal notranslate"><span class="pre">{uri}sometag</span></code>，其中 <em>prefix</em> 会被完整 <em>URI</em> 所替换。 并且，如果存在 <a class="reference external" href="https://www.w3.org/TR/xml-names/#defaulting">默认命名空间</a>，则完整 URI 会被添加到所有未加前缀的标记之前。</p>
<p>下面的 XML 示例包含两个命名空间，一个具有前缀 &quot;fictional&quot; 而另一个则作为默认命名空间:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;actors</span> <span class="na">xmlns:fictional=</span><span class="s">&quot;http://characters.example.com&quot;</span>
        <span class="na">xmlns=</span><span class="s">&quot;http://people.example.com&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;actor&gt;</span>
        <span class="nt">&lt;name&gt;</span>John Cleese<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Lancelot<span class="nt">&lt;/fictional:character&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Archie Leach<span class="nt">&lt;/fictional:character&gt;</span>
    <span class="nt">&lt;/actor&gt;</span>
    <span class="nt">&lt;actor&gt;</span>
        <span class="nt">&lt;name&gt;</span>Eric Idle<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Sir Robin<span class="nt">&lt;/fictional:character&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Gunther<span class="nt">&lt;/fictional:character&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Commander Clement<span class="nt">&lt;/fictional:character&gt;</span>
    <span class="nt">&lt;/actor&gt;</span>
<span class="nt">&lt;/actors&gt;</span>
</pre></div>
</div>
<p>搜索和探查这个 XML 示例的一种方式是手动为 <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> 或 <a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">findall()</span></code></a> 的 xpath 中的每个标记或属性添加 URI:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">fromstring</span><span class="p">(</span><span class="n">xml_text</span><span class="p">)</span>
<span class="k">for</span> <span class="n">actor</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;{http://people.example.com}actor&#39;</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;{http://people.example.com}name&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">actor</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;{http://characters.example.com}character&#39;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; |--&gt;&#39;</span><span class="p">,</span> <span class="n">char</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>一种更好的方式是搜索带命名空间的 XML 示例创建一个字典来存放你自己的前缀并在搜索函数中使用它们:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ns</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;real_person&#39;</span><span class="p">:</span> <span class="s1">&#39;http://people.example.com&#39;</span><span class="p">,</span>
      <span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;http://characters.example.com&#39;</span><span class="p">}</span>

<span class="k">for</span> <span class="n">actor</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;real_person:actor&#39;</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;real_person:name&#39;</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">actor</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;role:character&#39;</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; |--&gt;&#39;</span><span class="p">,</span> <span class="n">char</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>这两种方式都会输出:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">John</span> <span class="n">Cleese</span>
 <span class="o">|--&gt;</span> <span class="n">Lancelot</span>
 <span class="o">|--&gt;</span> <span class="n">Archie</span> <span class="n">Leach</span>
<span class="n">Eric</span> <span class="n">Idle</span>
 <span class="o">|--&gt;</span> <span class="n">Sir</span> <span class="n">Robin</span>
 <span class="o">|--&gt;</span> <span class="n">Gunther</span>
 <span class="o">|--&gt;</span> <span class="n">Commander</span> <span class="n">Clement</span>
</pre></div>
</div>
</section>
</section>
<section id="xpath-support">
<span id="elementtree-xpath"></span><h2>XPath支持<a class="headerlink" href="#xpath-support" title="永久链接至标题">¶</a></h2>
<p>此模块提供了对 <a class="reference external" href="https://www.w3.org/TR/xpath">XPath 表达式</a> 的有限支持用于在树中定位元素。 其目标是支持一个简化语法的较小子集；完整的 XPath 引擎超出了此模块的适用范围。</p>
<section id="example">
<h3>示例<a class="headerlink" href="#example" title="永久链接至标题">¶</a></h3>
<p>下面是一个演示此模块的部分 XPath 功能的例子。 我们将使用来自 <a class="reference internal" href="#elementtree-parsing-xml"><span class="std std-ref">解析 XML</span></a> 小节的 <code class="docutils literal notranslate"><span class="pre">countrydata</span></code> XML 文档:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">countrydata</span><span class="p">)</span>

<span class="c1"># Top-level elements</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

<span class="c1"># All &#39;neighbor&#39; grand-children of &#39;country&#39; children of the top-level</span>
<span class="c1"># elements</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;./country/neighbor&quot;</span><span class="p">)</span>

<span class="c1"># Nodes with name=&#39;Singapore&#39; that have a &#39;year&#39; child</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//year/..[@name=&#39;Singapore&#39;]&quot;</span><span class="p">)</span>

<span class="c1"># &#39;year&#39; nodes that are children of nodes with name=&#39;Singapore&#39;</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//*[@name=&#39;Singapore&#39;]/year&quot;</span><span class="p">)</span>

<span class="c1"># All &#39;neighbor&#39; nodes that are the second child of their parent</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//neighbor[2]&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>对于带有命名空间的 XML，应使用通常的限定 <code class="docutils literal notranslate"><span class="pre">{namespace}tag</span></code> 标记法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># All dublin-core &quot;title&quot; tags in the document</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//{http://purl.org/dc/elements/1.1/}title&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="supported-xpath-syntax">
<h3>支持的XPath语法<a class="headerlink" href="#supported-xpath-syntax" title="永久链接至标题">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>语法</p></th>
<th class="head"><p>含意</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tag</span></code></p></td>
<td><p>选择具有给定标记的所有子元素。 例如，<code class="docutils literal notranslate"><span class="pre">spam</span></code> 是选择名为 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 的所有子元素，而 <code class="docutils literal notranslate"><span class="pre">spam/egg</span></code> 是在名为 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 的子元素中选择所有名为 <code class="docutils literal notranslate"><span class="pre">egg</span></code> 的孙元素，<code class="docutils literal notranslate"><span class="pre">{*}spam</span></code> 是在任意（或无）命名空间中选择名为 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 的标记，而 <code class="docutils literal notranslate"><span class="pre">{}*</span></code> 是只选择不在一个命名空间中的标记。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>增加了对星号通配符的支持。</p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
<td><p>选择所有子元素，包括注释和处理说明。例如 <code class="docutils literal notranslate"><span class="pre">*/egg</span></code> 选择所有名为 <code class="docutils literal notranslate"><span class="pre">egg</span></code> 的孙元素。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
<td><p>选择当前节点。这在路径的开头非常有用，用于指示它是相对路径。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">//</span></code></p></td>
<td><p>选择所有子元素 在当前元素的所有下级中选择所有下级元素。 例如，<code class="docutils literal notranslate"><span class="pre">.//egg</span></code> 是在整个树中选择所有 <code class="docutils literal notranslate"><span class="pre">egg</span></code> 元素。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">..</span></code></p></td>
<td><p>选择父元素。 如果路径试图前往起始元素的上级（元素的 <code class="docutils literal notranslate"><span class="pre">find</span></code> 被调用）则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[&#64;attrib]</span></code></p></td>
<td><p>选择具有给定属性的所有元素。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[&#64;attrib='value']</span></code></p></td>
<td><p>选择给定属性具有给定值的所有元素。该值不能包含引号。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[&#64;attrib!='value']</span></code></p></td>
<td><p>选择给定属性不具有给定值的所有元素。 该值不能包含引号。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[tag]</span></code></p></td>
<td><p>选择所有包含 <code class="docutils literal notranslate"><span class="pre">tag</span></code> 子元素的元素。只支持直系子元素。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[.='text']</span></code></p></td>
<td><p>选择完整文本内容等于 <code class="docutils literal notranslate"><span class="pre">text</span></code> 的所有元素（包括后代）。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[.!='text']</span></code></p></td>
<td><p>选择完整文本内容包括其下级内容不等于给定的 <code class="docutils literal notranslate"><span class="pre">text</span></code> 的所有元素。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[tag='text']</span></code></p></td>
<td><p>选择所有包含名为 <code class="docutils literal notranslate"><span class="pre">tag</span></code> 的子元素的元素，这些子元素（包括后代）的完整文本内容等于给定的 <code class="docutils literal notranslate"><span class="pre">text</span></code> 。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[tag!='text']</span></code></p></td>
<td><p>选择具有名为 <code class="docutils literal notranslate"><span class="pre">tag</span></code> 的子元素的所有元素，这些子元素包括其下级元素的完整文本内容不等于给定的 <code class="docutils literal notranslate"><span class="pre">text</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[position]</span></code></p></td>
<td><p>选择位于给定位置的所有元素。 位置可以是一个整数 (1 表示首位)，表达式 <code class="docutils literal notranslate"><span class="pre">last()</span></code> (表示末位)，或者相对于末位的位置 (例如 <code class="docutils literal notranslate"><span class="pre">last()-1</span></code>)。</p></td>
</tr>
</tbody>
</table>
<p>谓词（方括号内的表达式）之前必须带有标签名称，星号或其他谓词。<code class="docutils literal notranslate"><span class="pre">position</span></code> 谓词前必须有标签名称。</p>
</section>
</section>
<section id="reference">
<h2>参考<a class="headerlink" href="#reference" title="永久链接至标题">¶</a></h2>
<section id="functions">
<span id="elementtree-functions"></span><h3>函数<a class="headerlink" href="#functions" title="永久链接至标题">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.canonicalize">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xml_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.canonicalize" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference external" href="https://www.w3.org/TR/xml-c14n2/">C14N 2.0</a>  转换功能。.</p>
<p>规整化是标准化 XML 输出的一种方式，该方式允许按字节比较和数字签名。 它降低了 XML 序列化器所具有的自由度并改为生成更受约束的 XML 表示形式。 主要限制涉及命名空间声明的位置、属性的顺序和可忽略的空白符等。</p>
<p>此函数接受一个 XML 数字字符串 (<em>xml_data</em>) 或文件路径或者文件类对象 (<em>from_file</em>) 作为输入，将其转换为规整形式，并在提供了 <em>out</em> 文件（类）对象的情况下将其写到该对象的话，或者如果未提供则将其作为文本字符串返回。 输出文件接受文本而非字节数据。  因此它应当以使用 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> 编码格式的文本模式来打开。</p>
<p>典型使用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">xml_data</span> <span class="o">=</span> <span class="s2">&quot;&lt;root&gt;...&lt;/root&gt;&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">xml_data</span><span class="p">))</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;c14n_output.xml&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
    <span class="n">canonicalize</span><span class="p">(</span><span class="n">xml_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out_file</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;c14n_output.xml&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
    <span class="n">canonicalize</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s2">&quot;inputfile.xml&quot;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out_file</span><span class="p">)</span>
</pre></div>
</div>
<p>配置选项 <em>options</em> 如下:</p>
<ul class="simple">
<li><p><em>with_comments</em>: 设为真值以包括注释 (默认为假值)</p></li>
<li><dl class="simple">
<dt><em>strip_text</em>: 设为真值以去除文本内容前后的空白符</dt><dd><p>（默认值：否）</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>rewrite_prefixes</em>: 设为真值以替换带有 &quot;n{number}&quot; 前缀的命名空间</dt><dd><p>（默认值：否）</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>qname_aware_tags</em>: 一组可感知限定名称的标记名称，其中的前缀</dt><dd><p>应当在文本内容中被替换 (默认为空值)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>qname_aware_attrs</em>: 一组可感知限定名称的属性名称，其中的前缀</dt><dd><p>应当在文本内容中被替换 (默认为空值)</p>
</dd>
</dl>
</li>
<li><p><em>exclude_attrs</em>: 一组不应当被序列化的属性名称</p></li>
<li><p><em>exclude_tags</em>: 一组不应当被序列化的标记名称</p></li>
</ul>
<p>在上面的选项列表中，&quot;一组&quot; 是指任意多项集或包含字符串的可迭代对象，排序是不必要的。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Comment">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">Comment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Comment" title="永久链接至目标">¶</a></dt>
<dd><p>注释元素工厂函数。 这个工厂函数可创建一个特殊元素，它将被标准序列化器当作 XML 注释来进行序列化。 注释字串可以是字节串或是 Unicode 字符串。 <em>text</em> 是包含注释字串的字符串。 返回一个表示注释的元素实例。</p>
<p>请注意 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 会跳过输入中的注释而不会为其创建注释对象。 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 将只在当使用某个 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 方法向树插入了注释节点时才会包含注释节点。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.dump">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">dump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.dump" title="永久链接至目标">¶</a></dt>
<dd><p>将一个元素树或元素结构体写入到 sys.stdout。 此函数应当只被用于调试。</p>
<p>实际输出格式是依赖于具体实现的。 在这个版本中，它将以普通 XML 文件的格式写入。</p>
<p><em>elem</em> 是一个元素树或单独元素。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span><a class="reference internal" href="#xml.etree.ElementTree.dump" title="xml.etree.ElementTree.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> 函数现在会保留用户指定的属性顺序。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.fromstring">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">fromstring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.fromstring" title="永久链接至目标">¶</a></dt>
<dd><p>根据一个字符串常量解析 XML 的节。 与 <a class="reference internal" href="#xml.etree.ElementTree.XML" title="xml.etree.ElementTree.XML"><code class="xref py py-func docutils literal notranslate"><span class="pre">XML()</span></code></a> 类似。 <em>text</em> 是包含 XML 数据的字符串。 <em>parser</em> 是可选的解析器实例。 如果未给出，则会使用标准 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 解析器。 返回一个 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.fromstringlist">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">fromstringlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.fromstringlist" title="永久链接至目标">¶</a></dt>
<dd><p>根据一个字符串片段序列解析 XML 文档。 <em>sequence</em> 是包含 XML 数据片段的列表或其他序列对象。 <em>parser</em> 是可选的解析器实例。 如果未给出，则会使用标准的 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 解析器。 返回一个 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 实例。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.indent">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">indent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span>&#160; <span class="pre">'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.indent" title="永久链接至目标">¶</a></dt>
<dd><p>添加空格到子树来实现树的缩进效果。 这可以被用来生成美化打印的 XML 输出。 <em>tree</em> 可以为 Element 或 ElementTree。 <em>space</em> 是对应将被插入的每个缩进层级的空格字符串，默认为两个空格符。 要对已缩进的树的部分子树进行缩进，请传入初始缩进层级作为 <em>level</em>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.iselement">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">iselement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.iselement" title="永久链接至目标">¶</a></dt>
<dd><p>检测一个对象是否为有效的元素对象。 <em>element</em> 是一个元素实例。 如果对象是一个元素对象则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.iterparse">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">iterparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">events</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.iterparse" title="永久链接至目标">¶</a></dt>
<dd><p>以增量方式将一个 XML 节解析为元素树，并向用户报告执行情况。 <em>source</em> 是包含 XML 数据的文件名或 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>。 <em>events</em> 是要报告的事件序列。 所支持的事件字符串有 <code class="docutils literal notranslate"><span class="pre">&quot;start&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;comment&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;pi&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;start-ns&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;end-ns&quot;</span></code> (&quot;ns&quot; 事件用于获取详细的命名空间信息)。 如果 <em>events</em> 被省略，则只有 <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code> 事件会被报告。 <em>parser</em> 是可选的解析器实例。 如果未给出，则会使用标准的 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 解析器。 <em>parser</em> 必须为 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 的子类并且只能使用默认的 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> 作为目标。 返回一个提供 <code class="docutils literal notranslate"><span class="pre">(event,</span> <span class="pre">elem)</span></code> 对的 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>。</p>
<p>请注意虽然 <a class="reference internal" href="#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterparse()</span></code></a> 是以增量方式构建树，但它会对 <em>source</em> (或其所指定的文件) 发出阻塞式读取。 因此，它不适用于不可执行阻塞式读取的应用。 对于完全非阻塞式的解析，请参看 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterparse()</span></code></a> 只会确保当发出 &quot;start&quot; 事件时看到了开始标记的 &quot;&gt;&quot; 字符，因而在这个点上属性已被定义，但文本容和末尾属性还未被定义。 这同样适用于元素的下级；它们可能存在也可能不存在。</p>
<p>如果你需要已完全填充的元素，请改为查找 &quot;end&quot; 事件。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span><em>parser</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>增加了 <code class="docutils literal notranslate"><span class="pre">comment</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pi</span></code> 事件。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.parse">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.parse" title="永久链接至目标">¶</a></dt>
<dd><p>将一个 XML 的节解析为元素树。 <em>source</em> 是包含 XML 数据的文件名或文件对象。 <em>parser</em> 是可选的解析器实例。 如果未给出，则会使用标准的 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 解析器。 返回一个 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ProcessingInstruction">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">ProcessingInstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ProcessingInstruction" title="永久链接至目标">¶</a></dt>
<dd><p>PI 元素工厂函数。 这个工厂函数可创建一个特殊元素，它将被当作 XML 处理指令来进行序列化。 <em>target</em> 是包含 PI 目标的字符串。 <em>text</em> 如果给出则是包含 PI 内容的字符串。 返回一个表示处理指令的元素实例。</p>
<p>请注意 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 会跳过输入中的处理指令而不会为其创建注释对象。 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 将只在当使用某个 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 方法向树插入了处理指令节点时才会包含处理指令节点。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.register_namespace">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">register_namespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.register_namespace" title="永久链接至目标">¶</a></dt>
<dd><p>注册一个命名空间前缀。 这个注册表是全局的，并且任何对应给定前缀或命名空间 URI 的现有映射都会被移除。 <em>prefix</em> 是命名空间前缀。 <em>uri</em> 是命名空间 URI。 如果可能的话，这个命名空间中的标记和属性将附带给定的前缀来进行序列化。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.SubElement">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">SubElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrib</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">extra</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.SubElement" title="永久链接至目标">¶</a></dt>
<dd><p>子元素工厂函数。 这个函数会创建一个元素实例，并将其添加到现有的元素。</p>
<p>元素名、属性名和属性值可以是字节串或 Unicode 字符串。 <em>parent</em> 是父元素。 <em>tag</em> 是子元素名。 <em>attrib</em> 是一个可选的字典，其中包含元素属性。  <em>extra</em> 包含额外的属性，以关键字参数形式给出。 返回一个元素实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.tostring">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">tostring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'us-ascii'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xml'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xml_declaration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_namespace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">short_empty_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.tostring" title="永久链接至目标">¶</a></dt>
<dd><p>生成一个 XML 元素的字符串表示形式，包括所有子元素。 <em>element</em> 是一个 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 实例。 <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id1">1</a> 是输出编码格式（默认为 US-ASCII）。 请使用 <code class="docutils literal notranslate"><span class="pre">encoding=&quot;unicode&quot;</span></code> 来生成 Unicode 字符串（否则生成字节串）。 <em>method</em> 是 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;text&quot;</span></code> (默认为 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>)。 <em>xml_declaration</em>, <em>default_namespace</em> 和 <em>short_empty_elements</em> 具有与 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code></a> 中一致的含义。 返回一个包含 XML 数据（可选）已编码的字符串。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能: </span><em>short_empty_elements</em> 形参。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能: </span><em>xml_declaration</em> 和 <em>default_namespace</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span><a class="reference internal" href="#xml.etree.ElementTree.tostring" title="xml.etree.ElementTree.tostring"><code class="xref py py-func docutils literal notranslate"><span class="pre">tostring()</span></code></a> 函数现在会保留用户指定的属性顺序。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.tostringlist">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">tostringlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'us-ascii'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xml'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xml_declaration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_namespace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">short_empty_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.tostringlist" title="永久链接至目标">¶</a></dt>
<dd><p>生成一个 XML 元素的字符串表示形式，包括所有子元素。 <em>element</em> 是一个 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 实例。 <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id2">1</a> 是输出编码格式（默认为 US-ASCII）。 请使用 <code class="docutils literal notranslate"><span class="pre">encoding=&quot;unicode&quot;</span></code> 来生成 Unicode 字符串（否则生成字节串）。 <em>method</em> 是 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;text&quot;</span></code> (默认为 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>)。 <em>xml_declaration</em>, <em>default_namespace</em> 和 <em>short_empty_elements</em> 具有与 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code></a> 中一致的含义。 返回一个包含 XML 数据（可选）已编码字符串的列表。 它并不保证任何特定的序列，除了 <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;.join(tostringlist(element))</span> <span class="pre">==</span> <span class="pre">tostring(element)</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能: </span><em>short_empty_elements</em> 形参。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能: </span><em>xml_declaration</em> 和 <em>default_namespace</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span><a class="reference internal" href="#xml.etree.ElementTree.tostringlist" title="xml.etree.ElementTree.tostringlist"><code class="xref py py-func docutils literal notranslate"><span class="pre">tostringlist()</span></code></a> 函数现在会保留用户指定的属性顺序。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XML">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">XML</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XML" title="永久链接至目标">¶</a></dt>
<dd><p>根据一个字符串常量解析 XML 的节。 此函数可被用于在 Python 代码中嵌入“XML 字面值”。 <em>text</em> 是包含 XML 数据的字符串。 <em>parser</em> 是可选的解析器实例。 如果未给出，则会使用标准的 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 解析器。 返回一个 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLID">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">XMLID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLID" title="永久链接至目标">¶</a></dt>
<dd><p>根据一个字符串常量解析 XML 的节，并且还将返回一个将元素的 id:s 映射到元素的字典。 <em>text</em> 是包含 XML 数据的字符串。 <em>parser</em> 是可选的解析器实例。 如果未给出，则会使用标准的 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 解析器。 返回一个包含 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 实例和字典的元组。</p>
</dd></dl>

</section>
</section>
<section id="xinclude-support">
<span id="elementtree-xinclude"></span><h2>XInclude 支持<a class="headerlink" href="#xinclude-support" title="永久链接至标题">¶</a></h2>
<p>此模块通过 <code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementInclude</span></code> 辅助模块提供了对 <a class="reference external" href="https://www.w3.org/TR/xinclude/">XInclude 指令</a> 的有限支持，这个模块可被用来根据元素树的信息在其中插入子树和文本字符串。</p>
<section id="id3">
<h3>示例<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>以下是一个演示 XInclude 模块用法的例子。 要在当前文本中包括一个 XML 文档，请使用 <code class="docutils literal notranslate"><span class="pre">{http://www.w3.org/2001/XInclude}include</span></code> 元素并将 <strong>parse</strong> 属性设为 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>，并使用 <strong>href</strong> 属性来指定要包括的文档。</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;xi:include</span> <span class="na">href=</span><span class="s">&quot;source.xml&quot;</span> <span class="na">parse=</span><span class="s">&quot;xml&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
<p>默认情况下，<strong>href</strong> 属性会被当作文件名来处理。 你可以使用自定义加载器来重载此行为。 还要注意标准辅助器不支持 XPointer 语法。</p>
<p>要处理这个文件，请正常加载它，并将根元素传给 <a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> 模块:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.etree</span> <span class="kn">import</span> <span class="n">ElementTree</span><span class="p">,</span> <span class="n">ElementInclude</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">ElementTree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;document.xml&quot;</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>

<span class="n">ElementInclude</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
<p>ElementInclude 模块使用来自 <strong>source.xml</strong> 文档的根元素替代 <code class="docutils literal notranslate"><span class="pre">{http://www.w3.org/2001/XInclude}include</span></code> 元素。 结果看起来大概是这样:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;para&gt;</span>This is a paragraph.<span class="nt">&lt;/para&gt;</span>
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
<p>如果省略了 <strong>parse</strong> 属性，它会取默认的 &quot;xml&quot;。 要求有 href 属性。</p>
<p>要包括文本文档，请使用 <code class="docutils literal notranslate"><span class="pre">{http://www.w3.org/2001/XInclude}include</span></code> 元素，并将 <strong>parse</strong> 属性设为 &quot;text&quot;:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  Copyright (c) <span class="nt">&lt;xi:include</span> <span class="na">href=</span><span class="s">&quot;year.txt&quot;</span> <span class="na">parse=</span><span class="s">&quot;text&quot;</span> <span class="nt">/&gt;</span>.
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
<p>结果可能如下所示：</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  Copyright (c) 2003.
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
</section>
</section>
<section id="id4">
<h2>参考<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<section id="elementinclude-functions">
<span id="id5"></span><h3>函数<a class="headerlink" href="#elementinclude-functions" title="永久链接至标题">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementInclude.default_loader">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementInclude.</span></span><span class="sig-name descname"><span class="pre">default_loader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">href</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementInclude.default_loader" title="永久链接至目标">¶</a></dt>
<dd><p>默认的加载器。 这个默认的加载器会从磁盘读取所包括的资源。 <em>href</em> 是一个 URL。 <em>parse</em> 是 &quot;xml&quot; 或 &quot;text&quot; 表示解析模式。 <em>encoding</em> 是可选的文本编码格式。 如果未给出，则编码格式为 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code>。 返回已扩展的资源。 如果解析模式为 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>，则它是一个 ElementTree 实例。 如果解析模式为 &quot;text&quot;，则它是一个 Unicode 字符串。 如果加载器失败，它可以返回 None 或者引发异常。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementInclude.include">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementInclude.</span></span><span class="sig-name descname"><span class="pre">include</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_url</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementInclude.include" title="永久链接至目标">¶</a></dt>
<dd><p>这个函数会扩展 XInclude 指令。 <em>elem</em> 是根元素。 <em>loader</em> 是可选的资源加载器。 如果省略，则它默认为 <a class="reference internal" href="#xml.etree.ElementInclude.default_loader" title="xml.etree.ElementInclude.default_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">default_loader()</span></code></a>。 如果给出，则它应当是一个实现了与 <a class="reference internal" href="#xml.etree.ElementInclude.default_loader" title="xml.etree.ElementInclude.default_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">default_loader()</span></code></a> 相同的接口的可调用对象。 <em>base_url</em> 是原文件的基准 URL，用于求解相对的包括文件引用。 <em>max_depth</em> 是递归包括的最大数量。  此限制是为了降低恶意内容爆破的风险。 传入一个负值可禁用此限制。</p>
<p>返回已扩展的资源。 如果解析模式为 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>，则它是一个 ElementTree 实例。 如果解析模式为 &quot;text&quot;，则它是一个 Unicode 字符串。 如果加载器失败，它可以返回 None 或者引发异常。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.9 新版功能: </span><em>base_url</em> 和 <em>max_depth</em> 形参。</p>
</div>
</dd></dl>

</section>
<section id="element-objects">
<span id="elementtree-element-objects"></span><h3>元素对象<a class="headerlink" href="#element-objects" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">Element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrib</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">extra</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element" title="永久链接至目标">¶</a></dt>
<dd><p>元素类。 这个类定义了 Element 接口，并提供了这个接口的引用实现。</p>
<p>元素名、属性名和属性值可以是字节串或 Unicode 字符串。 <em>tag</em> 是元素名。 <em>attrib</em> 是一个可选的字典，其中包含元素属性。 <em>extra</em> 包含额外的属性，以关键字参数形式给出。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.tag">
<span class="sig-name descname"><span class="pre">tag</span></span><a class="headerlink" href="#xml.etree.ElementTree.Element.tag" title="永久链接至目标">¶</a></dt>
<dd><p>一个标识此元素意味着何种数据的字符串(换句话说，元素类型)。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.text">
<span class="sig-name descname"><span class="pre">text</span></span><a class="headerlink" href="#xml.etree.ElementTree.Element.text" title="永久链接至目标">¶</a></dt>
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.tail">
<span class="sig-name descname"><span class="pre">tail</span></span><a class="headerlink" href="#xml.etree.ElementTree.Element.tail" title="永久链接至目标">¶</a></dt>
<dd><p>这些属性可被用于存放与元素相关联的额外数据。 它们的值通常为字符串但也可以是任何应用专属的对象。 如果元素是基于 XML 文件创建的，<em>text</em> 属性会存放元素的开始标记及其第一个子元素或结束标记之间的文本，或者为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，而 <em>tail</em> 属性会存放元素的结束标记及下一个标记之间的文本，或者为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 对于 XML 数据</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;a&gt;&lt;b&gt;</span>1<span class="nt">&lt;c&gt;</span>2<span class="nt">&lt;d/&gt;</span>3<span class="nt">&lt;/c&gt;&lt;/b&gt;</span>4<span class="nt">&lt;/a&gt;</span>
</pre></div>
</div>
<p><em>a</em> 元素的 <em>text</em> 和 <em>tail</em> 属性均为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，<em>b</em> 元素的 <em>text</em> 为 <code class="docutils literal notranslate"><span class="pre">&quot;1&quot;</span></code> 而 <em>tail</em> 为 <code class="docutils literal notranslate"><span class="pre">&quot;4&quot;</span></code>，<em>c</em> 元素的 <em>text</em> 为 <code class="docutils literal notranslate"><span class="pre">&quot;2&quot;</span></code> 而 <em>tail</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，<em>d</em> 元素的 <em>text</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 而 <em>tail</em> 为 <code class="docutils literal notranslate"><span class="pre">&quot;3&quot;</span></code>。</p>
<p>要获取一个元素的内部文本，请参阅 <a class="reference internal" href="#xml.etree.ElementTree.Element.itertext" title="xml.etree.ElementTree.Element.itertext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itertext()</span></code></a>，例如 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;.join(element.itertext())</span></code>。</p>
<p>应用程序可以将任意对象存入这些属性。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.attrib">
<span class="sig-name descname"><span class="pre">attrib</span></span><a class="headerlink" href="#xml.etree.ElementTree.Element.attrib" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含元素属性的字典。 请注意虽然 <em>attrib</em> 值总是一个真正可变的 Python 字典，但 ElementTree 实现可以选择其他内部表示形式，并只在有需要时才创建字典。 为了发挥这种实现的优势，请在任何可能情况下使用下列字典方法。</p>
</dd></dl>

<p>以下字典类方法作用于元素属性。</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.clear" title="永久链接至目标">¶</a></dt>
<dd><p>重设一个元素。 此方法会移除所有子元素，清空所有属性，并将 text 和 tail 属性设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.get" title="永久链接至目标">¶</a></dt>
<dd><p>获取名为 <em>key</em> 的元素属性。</p>
<p>返回属性的值，或者如果属性未找到则返回 <em>default</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.items" title="永久链接至目标">¶</a></dt>
<dd><p>将元素属性以 (name, value) 对序列的形式返回。 所返回属性的顺序任意。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.keys" title="永久链接至目标">¶</a></dt>
<dd><p>将元素属性名称以列表的形式返回。 所返回名称的顺序任意。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.set" title="永久链接至目标">¶</a></dt>
<dd><p>将元素的 <em>key</em> 属性设为 <em>value</em>。</p>
</dd></dl>

<p>以下方法作用于元素的下级（子元素）。</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subelement</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.append" title="永久链接至目标">¶</a></dt>
<dd><p>将元素 <em>subelement</em> 添加到此元素的子元素内部列表。 如果 <em>subelement</em> 不是一个 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 则会引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subelements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.extend" title="永久链接至目标">¶</a></dt>
<dd><p>使用具有零个或多个元素的序列对象添加 <em>subelements</em>。 如果某个子元素不是 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 则会引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.find" title="永久链接至目标">¶</a></dt>
<dd><p>查找第一个匹配 <em>match</em> 的子元素。 <em>match</em> 可以是一个标记名称或者 <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">路径</span></a>。 返回一个元素实例或 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 <em>namespaces</em> 是可选的从命名空间前缀到完整名称的映射。 传入 <code class="docutils literal notranslate"><span class="pre">''</span></code> 作为前缀可将表达式中所有无前缀的标记名称移动到给定的命名空间。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.findall">
<span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.findall" title="永久链接至目标">¶</a></dt>
<dd><p>根据标记名称或者 <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">路径</span></a> 查找所有匹配的子元素。 返回一个包含所有匹配元素按文档顺序排序的列表。 <em>namespaces</em> 是可选的从命名空间前缀到完整名称的映射。 传入 <code class="docutils literal notranslate"><span class="pre">''</span></code> 作为前缀可将表达式中所有无前缀的标记名称移动到给定的命名空间。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.findtext">
<span class="sig-name descname"><span class="pre">findtext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.findtext" title="永久链接至目标">¶</a></dt>
<dd><p>查找第一个匹配 <em>match</em> 的子元素的文本。 <em>match</em> 可以是一个标记名称或者 <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">路径</span></a>。 反回第一个匹配的元素的文本内容，或者如果元素未找到则返回 <em>default</em>。 请注意如果匹配的元素没有文本内容则会返回一个空字符串。 <em>namespaces</em> 是可选的从命名空间前缀到完整名称的映射。 传入 <code class="docutils literal notranslate"><span class="pre">''</span></code> 作为前缀可将表达式中所有无前缀的标记名称移动到给定的命名空间。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subelement</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.insert" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>subelement</em> 插入到此元素的给定位置中。 如果 <em>subelement</em> 不是一个 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 则会引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.iter">
<span class="sig-name descname"><span class="pre">iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.iter" title="永久链接至目标">¶</a></dt>
<dd><p>创建一个以当前元素为根元素的树的 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>。 该迭代器将以文档（深度优先）顺序迭代此元素及其所有下级元素。 如果 <em>tag</em> 不为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'*'</span></code>，则迭代器只返回标记为 <em>tag</em> 的元素。 如果树结构在迭代期间被修改，则结果是未定义的。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.iterfind">
<span class="sig-name descname"><span class="pre">iterfind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.iterfind" title="永久链接至目标">¶</a></dt>
<dd><p>根据标记名称或者 <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">路径</span></a> 查找所有匹配的子元素。 返回一个按文档顺序产生所有匹配元素的可迭代对象。 <em>namespaces</em> 是可选的从命名空间前缀到完整名称的映射。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.itertext">
<span class="sig-name descname"><span class="pre">itertext</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.itertext" title="永久链接至目标">¶</a></dt>
<dd><p>创建一个文本迭代器。 该迭代器将按文档顺序遍历此元素及其所有子元素，并返回所有内部文本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.makeelement">
<span class="sig-name descname"><span class="pre">makeelement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrib</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.makeelement" title="永久链接至目标">¶</a></dt>
<dd><p>创建一个与此元素类型相同的新元素对象。 请不要调用此方法，而应改用 <a class="reference internal" href="#xml.etree.ElementTree.SubElement" title="xml.etree.ElementTree.SubElement"><code class="xref py py-func docutils literal notranslate"><span class="pre">SubElement()</span></code></a> 工厂函数。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subelement</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.remove" title="永久链接至目标">¶</a></dt>
<dd><p>从元素中移除 <em>subelement</em>。 与 find* 方法不同的是此方法会基于实例的标识来比较元素，而不是基于标记的值或内容。</p>
</dd></dl>

<p><a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 对象还支持下列序列类型方法以配合子元素使用: <a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a>。</p>
<p>注意：不带子元素的元素将被检测为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 此行为将在未来的版本中发生变化。 请改用 <code class="docutils literal notranslate"><span class="pre">len(elem)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">elem</span> <span class="pre">is</span> <span class="pre">None</span></code> 进行检测。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>  <span class="c1"># careful!</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;element not found, or element has no subelements&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">element</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;element not found&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>在 Python 3.8 之前，元素的 XML 属性的序列化顺序会通过按其名称排序来强制使其可被预期。 由于现在字典已保证是有序的，这个强制重排序在 Python 3.8 中已被移除以保留原本由用户代码解析或创建的属性顺序。</p>
<p>通常，用户代码应当尽量不依赖于特定的属性顺序，因为 <a class="reference external" href="https://www.w3.org/TR/xml-infoset/">XML 信息设定</a> 明确地排除了用属性顺序转递信息的做法。 代码应当准备好处理任何输入顺序。 对于要求确定性的 XML 输出的情况，例如加密签名或检测数据集等，可以通过规范化 <a class="reference internal" href="#xml.etree.ElementTree.canonicalize" title="xml.etree.ElementTree.canonicalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">canonicalize()</span></code></a> 函数来进行传统的序列化。</p>
<p>对于规范化输出不可用但仍然要求输出特定属性顺序的情况，代码应当设法直接按要求的顺序来创建属性，以避免代码阅读者产生不匹配的感觉。 如果这一点是难以做到的，可以在序列化之前应用以下写法来强制实现顺序不依赖于元素的创建:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reorder_attributes</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">():</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">attrib</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrib</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># adjust attribute order, e.g. by sorting</span>
            <span class="n">attribs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">attrib</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">attrib</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">attrib</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attribs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="elementtree-objects">
<span id="elementtree-elementtree-objects"></span><h3>ElementTree 对象<a class="headerlink" href="#elementtree-objects" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">ElementTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree" title="永久链接至目标">¶</a></dt>
<dd><p>ElementTree 包装器类。 这个类表示一个完整的元素层级结构，并添加了一些对于标准 XML 序列化的额外支持。</p>
<p><em>element</em> 是根元素。 如果给出 XML <em>file</em> 则将使用其内容来初始化树结构。</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree._setroot">
<span class="sig-name descname"><span class="pre">_setroot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree._setroot" title="永久链接至目标">¶</a></dt>
<dd><p>替换该树结构的根元素。 这将丢弃该树结构的当前内容，并将其替换为给定的元素。 请小心使用。  <em>element</em> 是一个元素实例。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.find" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.find()</span></code></a> 类似，从树的根节点开始。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.findall">
<span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.findall" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.findall()</span></code></a> 类似，从树的根节点开始。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.findtext">
<span class="sig-name descname"><span class="pre">findtext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.findtext" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#xml.etree.ElementTree.Element.findtext" title="xml.etree.ElementTree.Element.findtext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.findtext()</span></code></a> 类似，从树的根节点开始。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.getroot">
<span class="sig-name descname"><span class="pre">getroot</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.getroot" title="永久链接至目标">¶</a></dt>
<dd><p>返回这个树的根元素。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.iter">
<span class="sig-name descname"><span class="pre">iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.iter" title="永久链接至目标">¶</a></dt>
<dd><p>创建并返回根元素的树结构迭代器。 该迭代器会以节顺序遍历这个树的所有元素。 <em>tag</em> 是要查找的标记（默认返回所有元素）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.iterfind">
<span class="sig-name descname"><span class="pre">iterfind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.iterfind" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#xml.etree.ElementTree.Element.iterfind" title="xml.etree.ElementTree.Element.iterfind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.iterfind()</span></code></a> 类似，从树的根节点开始。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.parse">
<span class="sig-name descname"><span class="pre">parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.parse" title="永久链接至目标">¶</a></dt>
<dd><p>将一个外部 XML 节载入到此元素树。 <em>source</em> 是一个文件名或 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>。 <em>parser</em> 是可选的解析器实例。 如果未给出，则会使用标准的 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 解析器。 返回该节的根元素。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'us-ascii'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xml_declaration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_namespace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xml'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">short_empty_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.write" title="永久链接至目标">¶</a></dt>
<dd><p>将元素树以 XML 格式写入到文件。 <em>file</em> 为文件名，或是以写入模式打开的 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>。 <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id6">1</a> 为输出编码格式 (默认为 US-ASCII)。 <em>xml_declaration</em> 控制是否要将 XML 声明添加到文件中。 使用 <code class="docutils literal notranslate"><span class="pre">False</span></code> 表示从不添加，<code class="docutils literal notranslate"><span class="pre">True</span></code> 表示总是添加，<code class="docutils literal notranslate"><span class="pre">None</span></code> 表示仅在非 US-ASCII 或 UTF-8 或 Unicode 时添加 (默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>)。 <em>default_namespace</em> 设置默认 XML 命名空间 (用于 &quot;xmlns&quot;)。 <em>method</em> 为 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;text&quot;</span></code> (默认为 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>)。 仅限关键字形参 <em>short_empty_elements</em> 控制不包含内容的元素的格式。 如为 <code class="docutils literal notranslate"><span class="pre">True</span></code> (默认值)，它们会被输出为单个自结束标记，否则它们会被输出为一对开始/结束标记。</p>
<p>输出是一个字符串 (<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) 或字节串 (<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>)。 由*encoding* 参数来控制。 如果 <em>encoding</em> 为 <code class="docutils literal notranslate"><span class="pre">&quot;unicode&quot;</span></code>，则输出是一个字符串；否则为字节串；请注意这可能与 <em>file</em> 的类型相冲突，如果它是一个打开的 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> 的话；请确保你不会试图写入字符串到二进制流或者反向操作。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能: </span><em>short_empty_elements</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span><a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> 方法现在会保留用户指定的属性顺序。</p>
</div>
</dd></dl>

</dd></dl>

<p>这是将要被操作的 XML 文件:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">head</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">Example</span> <span class="n">page</span><span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">head</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Moved</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.org/&quot;</span><span class="o">&gt;</span><span class="n">example</span><span class="o">.</span><span class="n">org</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
        <span class="ow">or</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/&quot;</span><span class="o">&gt;</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;.&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">body</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">html</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>修改第一段中的每个链接的 &quot;target&quot;  属性的示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">ElementTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">ElementTree</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;index.xhtml&quot;</span><span class="p">)</span>
<span class="go">&lt;Element &#39;html&#39; at 0xb77e6fac&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;body/p&quot;</span><span class="p">)</span>     <span class="c1"># Finds first occurrence of tag p in body</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">&lt;Element &#39;p&#39; at 0xb77ec26c&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">links</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">))</span>   <span class="c1"># Returns list of all links</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">links</span>
<span class="go">[&lt;Element &#39;a&#39; at 0xb77ec2ac&gt;, &lt;Element &#39;a&#39; at 0xb77ec1cc&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>             <span class="c1"># Iterates through all found links</span>
<span class="gp">... </span>    <span class="n">i</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;blank&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;output.xhtml&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="qname-objects">
<span id="elementtree-qname-objects"></span><h3>QName 对象<a class="headerlink" href="#qname-objects" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.QName">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">QName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text_or_uri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.QName" title="永久链接至目标">¶</a></dt>
<dd><p>QName 包装器。 这可被用来包装 QName 属性值，以便在输出中获得适当的命名空间处理。 <em>text_or_uri</em> 是一个包含 QName 值的字符串，其形式为 {uri}local，或者如果给出了 tag 参数，则为 QName 的 URI 部分。 如果给出了 <em>tag</em>，则第一个参数会被解读为 URI，而这个参数会被解读为本地名称。 <a class="reference internal" href="#xml.etree.ElementTree.QName" title="xml.etree.ElementTree.QName"><code class="xref py py-class docutils literal notranslate"><span class="pre">QName</span></code></a> 实例是不透明的。</p>
</dd></dl>

</section>
<section id="treebuilder-objects">
<span id="elementtree-treebuilder-objects"></span><h3>TreeBuilder 对象<a class="headerlink" href="#treebuilder-objects" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">TreeBuilder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element_factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pi_factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insert_comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insert_pis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder" title="永久链接至目标">¶</a></dt>
<dd><p>通用元素结构构建器。  此构建器会将包含 start, data, end, comment 和 pi 方法调用的序列转换为格式良好的元素结构。 你可以通过这个类使用一个自定义 XML 解析器或其他 XML 类格式的解析器来构建元素结构。</p>
<p>如果给出 <em>element_factory</em>，它必须为接受两个位置参数的可调用对象：一个标记和一个属性字典。  它预期会返回一个新的元素实例。</p>
<p>如果给出 <em>comment_factory</em> 和 <em>pi_factory</em> 函数，它们的行为应当像 <a class="reference internal" href="#xml.etree.ElementTree.Comment" title="xml.etree.ElementTree.Comment"><code class="xref py py-func docutils literal notranslate"><span class="pre">Comment()</span></code></a> 和 <a class="reference internal" href="#xml.etree.ElementTree.ProcessingInstruction" title="xml.etree.ElementTree.ProcessingInstruction"><code class="xref py py-func docutils literal notranslate"><span class="pre">ProcessingInstruction()</span></code></a> 函数一样创建注释和处理指令。 如果未给出，则将使用默认工厂函数。 当 <em>insert_comments</em> 和/或 <em>insert_pis</em> 为真值时，如果 comments/pis 在根元素之中（但不在其之外）出现则它们将被插入到树中。</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.close" title="永久链接至目标">¶</a></dt>
<dd><p>刷新构建器缓存，并返回最高层级的文档元素。 返回一个 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 实例。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.data">
<span class="sig-name descname"><span class="pre">data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.data" title="永久链接至目标">¶</a></dt>
<dd><p>将文本添加到当前元素。 <em>data</em> 为要添加的文本。 这应当是一个字节串或 Unicode 字符串。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.end">
<span class="sig-name descname"><span class="pre">end</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.end" title="永久链接至目标">¶</a></dt>
<dd><p>关闭当前元素。 <em>tag</em> 是元素名称。 返回已关闭的元素。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.start" title="永久链接至目标">¶</a></dt>
<dd><p>打开一个新元素。 <em>tag</em> 是元素名称。 <em>attrs</em> 是包含元素属性的字典。 返回打开的元素。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.comment">
<span class="sig-name descname"><span class="pre">comment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.comment" title="永久链接至目标">¶</a></dt>
<dd><p>使用给定的 <em>text</em> 创建一条注释。 如果 <code class="docutils literal notranslate"><span class="pre">insert_comments</span></code> 为真值，这还会将其添加到树结构中。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.pi">
<span class="sig-name descname"><span class="pre">pi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.pi" title="永久链接至目标">¶</a></dt>
<dd><p>使用给定的 <em>target</em> 名称和 <em>text</em> 创建一条注释。 如果 <code class="docutils literal notranslate"><span class="pre">insert_pis</span></code> 为真值，这还会将其添加到树结构中。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<p>此外，自定义的 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> 对象还提供了以下方法:</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.doctype">
<span class="sig-name descname"><span class="pre">doctype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pubid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.doctype" title="永久链接至目标">¶</a></dt>
<dd><p>处理一条 doctype 声明。 <em>name</em> 为 doctype 名称。 <em>pubid</em> 为公有标识。 <em>system</em> 为系统标识。 此方法不存在于默认的 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> 类中。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.start_ns">
<span class="sig-name descname"><span class="pre">start_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.start_ns" title="永久链接至目标">¶</a></dt>
<dd><p>在定义了 <code class="docutils literal notranslate"><span class="pre">start()</span></code> 回调的打开元素的该回调被调用之前，当解析器遇到新的命名空间声明时都会被调用。 <em>prefix</em> 对于默认命名空间为 <code class="docutils literal notranslate"><span class="pre">''</span></code> 或者在其他情况下为被声明的命名空间前缀名称。 <em>uri</em> 是命名空间 URI。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.end_ns">
<span class="sig-name descname"><span class="pre">end_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.end_ns" title="永久链接至目标">¶</a></dt>
<dd><p>在声明了命名空间前缀映射的元素的 <code class="docutils literal notranslate"><span class="pre">end()</span></code> 回调之后被调用，附带超出作用域的 <em>prefix</em> 的名称。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.C14NWriterTarget">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">C14NWriterTarget</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">write</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strip_text</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rewrite_prefixes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qname_aware_tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qname_aware_attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.C14NWriterTarget" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference external" href="https://www.w3.org/TR/xml-c14n2/">C14N 2.0</a> 写入器。 其参数与 <a class="reference internal" href="#xml.etree.ElementTree.canonicalize" title="xml.etree.ElementTree.canonicalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">canonicalize()</span></code></a> 函数的相同。 这个类并不会构建树结构而是使用 <em>write</em> 函数将回调事件直接转换为序列化形式。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

</section>
<section id="xmlparser-objects">
<span id="elementtree-xmlparser-objects"></span><h3>XMLParser对象<a class="headerlink" href="#xmlparser-objects" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLParser">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">XMLParser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLParser" title="永久链接至目标">¶</a></dt>
<dd><p>这个类是此模块的低层级构建单元。 它使用 <a class="reference internal" href="pyexpat.html#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.parsers.expat</span></code></a> 来实现高效、基于事件的 XML 解析。  它可以通过 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser.feed" title="xml.etree.ElementTree.XMLParser.feed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">feed()</span></code></a> 方法增量式地收受 XML 数据，并且解析事件会被转换为推送式 API —— 通过在 <em>target</em> 对象上发起对回调的调用。 如果省略 <em>target</em>，则会使用标准的 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a>。 如果给出了 <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id8">1</a> ，该值将覆盖在 XML 文件中指定的编码格式。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>所有形参现在都是 <a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">仅限关键字形参</span></a>。 <em>html</em> 参数不再受支持。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLParser.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLParser.close" title="永久链接至目标">¶</a></dt>
<dd><p>结束向解析器提供数据。 返回调用在构造期间传入的 <em>target</em> 的 <code class="docutils literal notranslate"><span class="pre">close()</span></code> 方法的结果；在默认情况下，这是最高层级的文档元素。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLParser.feed">
<span class="sig-name descname"><span class="pre">feed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLParser.feed" title="永久链接至目标">¶</a></dt>
<dd><p>将数据送入解析器。 <em>data</em> 是编码后的数据。</p>
</dd></dl>

<p><a class="reference internal" href="#xml.etree.ElementTree.XMLParser.feed" title="xml.etree.ElementTree.XMLParser.feed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLParser.feed()</span></code></a> 会为每个打开的标记调用 <em>target</em> 的 <code class="docutils literal notranslate"><span class="pre">start(tag,</span> <span class="pre">attrs_dict)</span></code> 方法，为每个关闭的标记调用它的 <code class="docutils literal notranslate"><span class="pre">end(tag)</span></code> 方法，并通过 <code class="docutils literal notranslate"><span class="pre">data(data)</span></code> 方法来处理数据。 有关更多受支持的回调方法，请参阅 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> 类。  <a class="reference internal" href="#xml.etree.ElementTree.XMLParser.close" title="xml.etree.ElementTree.XMLParser.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLParser.close()</span></code></a> 会调用 <em>target</em> 的 <code class="docutils literal notranslate"><span class="pre">close()</span></code> 方法。 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 不仅仅可被用来构建树结构。 下面是一个统计 XML 文件最大深度的示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">XMLParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MaxDepth</span><span class="p">:</span>                     <span class="c1"># The target object of the parser</span>
<span class="gp">... </span>    <span class="n">maxDepth</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">attrib</span><span class="p">):</span>   <span class="c1"># Called for each opening tag.</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span><span class="p">:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>             <span class="c1"># Called for each closing tag.</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>            <span class="c1"># We do not need to do anything with data.</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>    <span class="c1"># Called when all data has been parsed.</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="n">MaxDepth</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">XMLParser</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exampleXml</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s2">&lt;a&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;b&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;/b&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;b&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;c&gt;</span>
<span class="gp">... </span><span class="s2">      &lt;d&gt;</span>
<span class="gp">... </span><span class="s2">      &lt;/d&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;/c&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;/b&gt;</span>
<span class="gp">... </span><span class="s2">&lt;/a&gt;&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="n">exampleXml</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="xmlpullparser-objects">
<span id="elementtree-xmlpullparser-objects"></span><h3>XMLPullParser对象<a class="headerlink" href="#xmlpullparser-objects" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLPullParser">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">XMLPullParser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser" title="永久链接至目标">¶</a></dt>
<dd><p>适用于非阻塞应用程序的拉取式解析器。 它的输入侧 API 与 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 的类似，但不是向回调目标推送调用，<a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a> 会收集一个解析事件的内部列表并让用户来读取它。 <em>events</em> 是要报告的事件序列。 受支持的事件字符串有 <code class="docutils literal notranslate"><span class="pre">&quot;start&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;comment&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;pi&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;start-ns&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;end-ns&quot;</span></code> (&quot;ns&quot; 事件被用于获取详细的命名空间信息)。 如果 <em>events</em> 被省略，则只报告 <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code> 事件。</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLPullParser.feed">
<span class="sig-name descname"><span class="pre">feed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser.feed" title="永久链接至目标">¶</a></dt>
<dd><p>将给定的字节数据送入解析器。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLPullParser.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser.close" title="永久链接至目标">¶</a></dt>
<dd><p>通知解析器数据流已终结。 不同于 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser.close" title="xml.etree.ElementTree.XMLParser.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLParser.close()</span></code></a>，此方法总是返回 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>。 当解析器被关闭时任何还未被获取的事件仍可通过 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_events()</span></code></a> 被读取。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLPullParser.read_events">
<span class="sig-name descname"><span class="pre">read_events</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="永久链接至目标">¶</a></dt>
<dd><p>返回包含在送入解析器的数据中遇到的事件的迭代器。 此迭代器会产生 <code class="docutils literal notranslate"><span class="pre">(event,</span> <span class="pre">elem)</span></code> 对，其中 <em>event</em> 是代表事件类型的字符串 (例如 <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code>) 而 <em>elem</em> 是遇到的 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 对象，或者以下的其他上下文值。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>: 当前元素。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">comment</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>: 当前注释 / 处理指令</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start-ns</span></code>: 一个指定所声明命名空间映射的元组 <code class="docutils literal notranslate"><span class="pre">(prefix,</span> <span class="pre">uri)</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">end-ns</span></code>: <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> (这可能在未来版本中改变)</p></li>
</ul>
<p>在之前对 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_events()</span></code></a> 的调用中提供的事件将不会被再次产生。 事件仅当它们从迭代器中被取出时才会在内部队列中被消费，因此多个读取方对获取自 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_events()</span></code></a> 的迭代器进行平行迭代将产生无法预料的结果。</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">备注</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a> 只会确保当发出 &quot;start&quot; 事件时看到了开始标记的 &quot;&gt;&quot; 字符，因而在这个点上属性已被定义，但文本内容和末尾属性还未被定义。 这同样适用于元素的下级；它们可能存在也可能不存在。</p>
<p>如果你需要已完全填充的元素，请改为查找 &quot;end&quot; 事件。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>增加了 <code class="docutils literal notranslate"><span class="pre">comment</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pi</span></code> 事件。</p>
</div>
</dd></dl>

</section>
<section id="exceptions">
<h3>异常<a class="headerlink" href="#exceptions" title="永久链接至标题">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ParseError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">ParseError</span></span><a class="headerlink" href="#xml.etree.ElementTree.ParseError" title="永久链接至目标">¶</a></dt>
<dd><p>XML 解析器错误，由此模块中的多个解析方法在解析失败时引发。 此异常的实例的字符串表示将包含用户友好的错误消息。 此外，它将具有下列可用属性:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ParseError.code">
<span class="sig-name descname"><span class="pre">code</span></span><a class="headerlink" href="#xml.etree.ElementTree.ParseError.code" title="永久链接至目标">¶</a></dt>
<dd><p>来自外部解析器的数字错误代码。 请参阅 <a class="reference internal" href="pyexpat.html#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.parsers.expat</span></code></a> 的文档查看错误代码列表及它们的含义。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ParseError.position">
<span class="sig-name descname"><span class="pre">position</span></span><a class="headerlink" href="#xml.etree.ElementTree.ParseError.position" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含 <em>line</em>, <em>column</em> 数值的元组，指明错误发生的位置。</p>
</dd></dl>

</dd></dl>

<p class="rubric">备注</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id6">3</a>,<a href="#id8">4</a>)</span></dt>
<dd><p>包括在 XML 输出中的编码格式字符串应当符合适当的标准。 例如 &quot;UTF-8&quot; 是有效的，但 &quot;UTF8&quot; 是无效的。 请参阅 <a class="reference external" href="https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl">https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl</a> 和 <a class="reference external" href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">https://www.iana.org/assignments/character-sets/character-sets.xhtml</a>。</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code> ---  ElementTree XML API</a><ul>
<li><a class="reference internal" href="#tutorial">教程</a><ul>
<li><a class="reference internal" href="#xml-tree-and-elements">XML 树和元素</a></li>
<li><a class="reference internal" href="#parsing-xml">解析 XML</a></li>
<li><a class="reference internal" href="#pull-api-for-non-blocking-parsing">用于非阻塞解析的拉取 API</a></li>
<li><a class="reference internal" href="#finding-interesting-elements">查找感兴趣的元素</a></li>
<li><a class="reference internal" href="#modifying-an-xml-file">修改XML文件</a></li>
<li><a class="reference internal" href="#building-xml-documents">构建 XML 文档</a></li>
<li><a class="reference internal" href="#parsing-xml-with-namespaces">解析带有命名空间的 XML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xpath-support">XPath支持</a><ul>
<li><a class="reference internal" href="#example">示例</a></li>
<li><a class="reference internal" href="#supported-xpath-syntax">支持的XPath语法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference">参考</a><ul>
<li><a class="reference internal" href="#functions">函数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xinclude-support">XInclude 支持</a><ul>
<li><a class="reference internal" href="#id3">示例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">参考</a><ul>
<li><a class="reference internal" href="#elementinclude-functions">函数</a></li>
<li><a class="reference internal" href="#element-objects">元素对象</a></li>
<li><a class="reference internal" href="#elementtree-objects">ElementTree 对象</a></li>
<li><a class="reference internal" href="#qname-objects">QName 对象</a></li>
<li><a class="reference internal" href="#treebuilder-objects">TreeBuilder 对象</a></li>
<li><a class="reference internal" href="#xmlparser-objects">XMLParser对象</a></li>
<li><a class="reference internal" href="#xmlpullparser-objects">XMLPullParser对象</a></li>
<li><a class="reference internal" href="#exceptions">异常</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="xml.html"
                          title="上一章">XML处理模块</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="xml.dom.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom</span></code> --- 文档对象模型 API</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/xml.etree.elementtree.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="xml.dom.html" title="xml.dom --- 文档对象模型 API"
             >下一页</a> |</li>
        <li class="right" >
          <a href="xml.html" title="XML处理模块"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="markup.html" >结构化标记处理工具</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code> ---  ElementTree XML API</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 11月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0创建。
    </div>

  </body>
</html>